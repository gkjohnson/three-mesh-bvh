{"version":3,"file":"webgpu_sdfGeneration-Cc6-Bwdi.js","sources":["../../../src/webgpu/distance_functions.wgsl.js","../../utils/RayMarchSDFNodeMaterial.js","../../utils/RenderSDFLayerNodeMaterial.js","../../webgpu_sdfGeneration.js"],"sourcesContent":["import { wgslFn, wgsl } from 'three/tsl';\nimport { bvhNodeStruct } from './common_functions.wgsl.js';\n\nexport const closestPointToPointResultStruct = wgsl( /* wgsl */ `\n\tstruct ClosestPointToPointResult {\n\t\tfaceIndices: vec4u,\n\t\tfaceNormal: vec3f,\n\t\tbarycoord: vec3f,\n\t\tpoint: vec3f,\n\t\tside: f32,\n\t\tdistanceSq: f32,\n\t\tfound: bool,\n\t};\n` );\n\nexport const closestPointToTriangleResultStruct = wgsl( /* wgsl */ `\n\tstruct ClosestPointToTriangleResult {\n\t\tbarycoord: vec3f,\n\t\tpoint: vec3f,\n\t};\n` );\n\nexport const closestPointToTriangle = wgslFn( /* wgsl */ `\n\n\tfn closestPointToTriangle( p: vec3f, v0: vec3f, v1: vec3f, v2: vec3f ) -> ClosestPointToTriangleResult {\n\t\t// https://www.shadertoy.com/view/ttfGWl\n\n\t\tlet v10 = v1 - v0;\n\t\tlet v21 = v2 - v1;\n\t\tlet v02 = v0 - v2;\n\n\t\tlet p0 = p - v0;\n\t\tlet p1 = p - v1;\n\t\tlet p2 = p - v2;\n\n\t\tlet nor = cross( v10, v02 );\n\n\t\t// method 2, in barycentric space\n\t\tlet  q = cross( nor, p0 );\n\t\tlet d = 1.0 / dot( nor, nor );\n\t\tvar u = d * dot( q, v02 );\n\t\tvar v = d * dot( q, v10 );\n\t\tvar w = 1.0 - u - v;\n\n\t\tif( u < 0.0 ) {\n\n\t\t\tw = clamp( dot( p2, v02 ) / dot( v02, v02 ), 0.0, 1.0 );\n\t\t\tu = 0.0;\n\t\t\tv = 1.0 - w;\n\n\t\t} else if( v < 0.0 ) {\n\n\t\t\tu = clamp( dot( p0, v10 ) / dot( v10, v10 ), 0.0, 1.0 );\n\t\t\tv = 0.0;\n\t\t\tw = 1.0 - u;\n\n\t\t} else if( w < 0.0 ) {\n\n\t\t\tv = clamp( dot( p1, v21 ) / dot( v21, v21 ), 0.0, 1.0 );\n\t\t\tw = 0.0;\n\t\t\tu = 1.0 - v;\n\n\t\t}\n\n\t\tvar result: ClosestPointToTriangleResult;\n\t\tresult.barycoord = vec3f( u, v, w );\n\t\tresult.point = u * v1 + v * v2 + w * v0;\n\n\t\treturn result;\n\n\t}\n`, [ closestPointToTriangleResultStruct ] );\n\nexport const distanceToTriangles = wgslFn( /* wgsl */ `\n\tfn distanceToTriangles(\n\t\t// geometry info and triangle range\n\t\tbvh_index: ptr<storage, array<vec3u>, read>,\n\t\tbvh_position: ptr<storage, array<vec3f>, read>,\n\n\t\toffset: u32, count: u32,\n\n\t\t// point and current result. Cut off range is taken from the struct\n\t\tpoint: vec3f,\n\t\tioRes: ptr<function, ClosestPointToPointResult>,\n\t) -> void {\n\n\t\tfor ( var i = offset; i < offset + count; i = i + 1u ) {\n\n\t\t\tlet indices = bvh_index[ i ];\n\t\t\tlet a = bvh_position[ indices.x ];\n\t\t\tlet b = bvh_position[ indices.y ];\n\t\t\tlet c = bvh_position[ indices.z ];\n\n\t\t\t// get the closest point and barycoord\n\t\t\tlet pointRes = closestPointToTriangle( point, a, b, c );\n\t\t\tlet delta = point - pointRes.point;\n\t\t\tlet distSq = dot( delta, delta );\n\t\t\tif ( distSq < ioRes.distanceSq ) {\n\n\t\t\t\t// set the output results\n\t\t\t\tioRes.distanceSq = distSq;\n\t\t\t\tioRes.faceIndices = vec4u( indices.xyz, i );\n\t\t\t\tioRes.faceNormal = normalize( cross( a - b, b - c ) );\n\t\t\t\tioRes.barycoord = pointRes.barycoord;\n\t\t\t\tioRes.point = pointRes.point;\n\t\t\t\tioRes.side = sign( dot( ioRes.faceNormal, delta ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n`, [ closestPointToTriangle, closestPointToPointResultStruct ] );\n\nexport const distanceSqToBounds = wgslFn( /* wgsl */ `\n\tfn distanceSqToBounds( point: vec3f, boundsMin: vec3f, boundsMax: vec3f ) -> f32 {\n\n\t\tlet clampedPoint = clamp( point, boundsMin, boundsMax );\n\t\tlet delta = point - clampedPoint;\n\t\treturn dot( delta, delta );\n\n\t}\n` );\n\nexport const distanceSqToBVHNodeBoundsPoint = wgslFn( /* wgsl */ `\n\tfn distanceSqToBVHNodeBoundsPoint(\n\t\tpoint: vec3f,\n\t\tbvh: ptr<storage, array<BVHNode>, read>,\n\t\tcurrNodeIndex: u32,\n\t) -> f32 {\n\n\t\tlet node = bvh[ currNodeIndex ];\n\t\tlet minBounds = vec3f(node.bounds.min[0], node.bounds.min[1], node.bounds.min[2]);\n\t\tlet maxBounds = vec3f(node.bounds.max[0], node.bounds.max[1], node.bounds.max[2]);\n\t\treturn distanceSqToBounds( point, minBounds, maxBounds );\n\n\t}\n`, [ distanceSqToBounds, bvhNodeStruct ] );\n\nexport const closestPointToPoint = wgslFn( /* wgsl */ `\n\tfn bvhClosestPointToPoint(\n\t\tbvh_index: ptr<storage, array<vec3u>, read>,\n\t\tbvh_position: ptr<storage, array<vec3f>, read>,\n\t\tbvh: ptr<storage, array<BVHNode>, read>,\n\n\t\tpoint: vec3f,\n\t\tmaxDistance: f32\n\t) -> ClosestPointToPointResult {\n\n\t\tconst BVH_STACK_DEPTH = 64;\n\n\t\t// stack needs to be twice as long as the deepest tree we expect because\n\t\t// we push both the left and right child onto the stack every traversal\n\t\tvar pointer = 0;\n\t\tvar stack: array<u32, BVH_STACK_DEPTH>;\n\t\tstack[ 0 ] = 0u;\n\n\t\tvar res: ClosestPointToPointResult;\n\t\tres.distanceSq = maxDistance * maxDistance;\n\n\t\twhile pointer > - 1 && pointer < BVH_STACK_DEPTH {\n\n\t\t\tlet currNodeIndex = stack[ pointer ];\n\t\t\tlet node = bvh[ currNodeIndex ];\n\t\t\tpointer = pointer - 1;\n\n\t\t\t// check if we intersect the current bounds\n\t\t\tlet boundsDistance = distanceSqToBVHNodeBoundsPoint( point, bvh, currNodeIndex );\n\t\t\tif ( boundsDistance > res.distanceSq ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tlet boundsInfox = node.splitAxisOrTriangleCount;\n\t\t\tlet boundsInfoy = node.rightChildOrTriangleOffset;\n\n\t\t\tlet isLeaf = ( boundsInfox & 0xffff0000u ) != 0u;\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tlet count = boundsInfox & 0x0000ffffu;\n\t\t\t\tlet offset = boundsInfoy;\n\t\t\t\tdistanceToTriangles(\n\t\t\t\t\tbvh_index, bvh_position,\n\t\t\t\t\toffset, count,\n\t\t\t\t\tpoint, &res\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tlet leftIndex = currNodeIndex + 1u;\n\t\t\t\tlet splitAxis = boundsInfox & 0x0000ffffu;\n\t\t\t\tlet rightIndex = currNodeIndex + boundsInfoy;\n\n\t\t\t\tlet leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh, rightIndex );\n\t\t\t\tlet c1 = select( rightIndex, leftIndex, leftToRight );\n\t\t\t\tlet c2 = select( leftIndex, rightIndex, leftToRight );\n\n\t\t\t\tpointer = pointer + 1;\n\t\t\t\tstack[ pointer ] = c2;\n\n\t\t\t\tpointer = pointer + 1;\n\t\t\t\tstack[ pointer ] = c1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n`, [ bvhNodeStruct, closestPointToPointResultStruct, distanceToTriangles, distanceSqToBVHNodeBoundsPoint ] );\n","import { NodeMaterial, Vector3, Matrix4 } from 'three/webgpu';\nimport { uniform, wgslFn, uv, varying, texture3D, sampler, positionGeometry } from 'three/tsl';\n\nexport class RayMarchSDFNodeMaterial extends NodeMaterial {\n\n\tconstructor( sdfTexture ) {\n\n\t\tsuper();\n\n\t\tconst raymarchFragmentParams = {\n\t\t\tsurface: uniform( 0 ),\n\t\t\tnormalStep: uniform( new Vector3() ),\n\t\t\tprojectionInverse: uniform( new Matrix4() ),\n\t\t\tsdfTransformInverse: uniform( new Matrix4() ),\n\t\t\tsdfTransform: uniform( new Matrix4() ),\n\n\t\t\tuv: varying( uv() ),\n\t\t\tsdf_sampler: sampler( sdfTexture ),\n\t\t\tsdf: texture3D( sdfTexture ),\n\t\t};\n\n\t\tconst rayBoxDistFn = wgslFn( /* wgsl */ `\n\t\t\tfn rayBoxDist(boundsMin: vec3f, boundsMax: vec3f, rayOrigin: vec3f, rayDir: vec3f) -> vec2f {\n\t\t\t\tlet t0 = (boundsMin - rayOrigin) / rayDir;\n\t\t\t\tlet t1 = (boundsMax - rayOrigin) / rayDir;\n\t\t\t\tlet tmin = min(t0, t1);\n\t\t\t\tlet tmax = max(t0, t1);\n\n\t\t\t\tlet distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\tlet distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\tlet distToBox = max( 0.0, distA );\n\t\t\t\tlet distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\treturn vec2f( distToBox, distInsideBox );\n\t\t\t}\n\t\t` );\n\n\t\tconst raymarchFragmentShader = wgslFn( /* wgsl */ `\n\t\t\tfn raymarch(\n\t\t\t\tsurface: f32,\n\t\t\t\tprojectionInverse: mat4x4f,\n\t\t\t\tsdfTransformInverse: mat4x4f,\n\t\t\t\tsdfTransform: mat4x4f,\n\t\t\t\tnormalStep: vec3f,\n\n\t\t\t\tuv: vec2f,\n\t\t\t\tsdf_sampler: sampler,\n\t\t\t\tsdf: texture_3d<f32>,\n\t\t\t) -> vec4f {\n\t\t\t\tconst MAX_STEPS: i32 = 500;\n\t\t\t\tconst SURFACE_EPSILON: f32 = 0.001;\n\n\t\t\t\tlet clipSpace = 2.0 * uv - vec2f( 1.0, 1.0 );\n\n\t\t\t\tlet rayOrigin = vec3f( 0.0, 0.0, 0.0 );\n\t\t\t\tlet homogenousDirection = projectionInverse * vec4f( clipSpace, -1.0, 1.0 );\n\t\t\t\tlet rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\tlet sdfRayOrigin = ( sdfTransformInverse * vec4f( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\tlet sdfRayDirection = normalize( ( sdfTransformInverse * vec4f( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\tlet boxIntersectionInfo = rayBoxDist( vec3f( -0.5 ), vec3f( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\tlet distToBox = boxIntersectionInfo.x;\n\t\t\t\tlet distInsideBox = boxIntersectionInfo.y;\n\t\t\t\tlet intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\tvar color = vec4f( 0.0 );\n\n\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\tvar intersectsSurface = false;\n\t\t\t\t\tvar localPoint = vec4f( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\tvar point = sdfTransform * localPoint;\n\n\t\t\t\t\tfor ( var i: i32 = 0; i < MAX_STEPS; i = i + 1 ) {\n\n\t\t\t\t\t\tlet uv3 = ( sdfTransformInverse * point ).xyz + vec3f( 0.5 );\n\n\t\t\t\t\t\tif ( uv3.x < 0.0 || uv3.x > 1.0 || uv3.y < 0.0 || uv3.y > 1.0 || uv3.z < 0.0 || uv3.z > 1.0 ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet distanceToSurface = textureSample( sdf, sdf_sampler, uv3 ).r - surface;\n\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpoint = vec4f(point.xyz + rayDirection * distanceToSurface, point.w);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\tlet uv3 = ( sdfTransformInverse * point ).xyz + vec3f( 0.5 );\n\n\t\t\t\t\t\tlet dx = textureSample( sdf, sdf_sampler, uv3 + vec3f( normalStep.x, 0.0, 0.0 ) ).r\n\t\t\t\t\t\t\t- textureSample( sdf, sdf_sampler, uv3 - vec3f( normalStep.x, 0.0, 0.0 ) ).r;\n\n\t\t\t\t\t\tlet dy = textureSample( sdf, sdf_sampler, uv3 + vec3f( 0.0, normalStep.y, 0.0 ) ).r\n\t\t\t\t\t\t\t- textureSample( sdf, sdf_sampler, uv3 - vec3f( 0.0, normalStep.y, 0.0 ) ).r;\n\n\t\t\t\t\t\tlet dz = textureSample( sdf, sdf_sampler, uv3 + vec3f( 0.0, 0.0, normalStep.z ) ).r\n\t\t\t\t\t\t\t- textureSample( sdf, sdf_sampler, uv3 - vec3f( 0.0, 0.0, normalStep.z ) ).r;\n\n\t\t\t\t\t\tlet normal = normalize( vec3f( dx, dy, dz ) );\n\n\t\t\t\t\t\tlet lightDirection = normalize( vec3f( 1.0, 1.0, 1.0 ) );\n\t\t\t\t\t\tlet lightIntensity =\n\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\tsaturate( dot( normal, -lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t0.1;\n\n\t\t\t\t\t\tcolor = vec4f( vec3f( lightIntensity ), 1.0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn color;\n\t\t\t}\n\t\t`, [ rayBoxDistFn ] );\n\n\t\tthis.fragmentNode = raymarchFragmentShader( raymarchFragmentParams );\n\n\n\t\tconst vertexShaderParams = {\n\t\t\tposition: positionGeometry,\n\t\t};\n\t\tconst fullScreenQuadVertex = wgslFn( /* wgsl */ `\n\n\t\t\tfn noop(position: vec4f) -> vec4f {\n\t\t\t\treturn position;\n\t\t\t}\n\n\t\t` );\n\n\t\tthis.vertexNode = fullScreenQuadVertex( vertexShaderParams );\n\n\t}\n\n}\n","import { NodeMaterial } from 'three/webgpu';\nimport { uniform, wgslFn, uv, varying, texture3D, positionGeometry, sampler, } from 'three/tsl';\n\nexport class RenderSDFLayerNodeMaterial extends NodeMaterial {\n\n\tconstructor( sdfTexture ) {\n\n\t\tsuper();\n\n\t\tconst distToColor = wgslFn( /* wgsl */`\n\t\t\tfn distToColor(dist: f32) -> vec4f {\n\t\t\t\tif (dist > 0.0) {\n\t\t\t\t\treturn vec4f(0.0, dist, 0.0, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\treturn vec4f(-dist, 0.0, 0.0, 1.0);\n\t\t\t\t}\n\t\t\t}\n\t\t` );\n\n\t\tconst fragmentShaderParams = {\n\t\t\tlayer: uniform( 0 ),\n\t\t\tgrid_mode: uniform( false ),\n\n\t\t\tuv: varying( uv() ),\n\t\t\tsdf_sampler: sampler( sdfTexture ),\n\t\t\tsdf: texture3D( sdfTexture ),\n\t\t};\n\n\t\tlet sdfLayerMaterialFragmentShader = wgslFn( /* wgsl */ `\n\t\t\tfn layer(\n\t\t\t\tlayer: u32,\n\t\t\t\tgrid_mode: bool,\n\n\t\t\t\tuv: vec2f,\n\t\t\t\tsdf_sampler: sampler,\n\t\t\t\tsdf: texture_3d<f32>,\n\t\t\t) -> vec4f {\n\t\t\t\tlet dim = textureDimensions( sdf ).x;\n\n\t\t\t\tvar texelCoords = vec3f(uv, f32(layer) / f32(dim));\n\n\t\t\t\tif (grid_mode) {\n\t\t\t\t\tlet square_size = ceil(sqrt(f32(dim)));\n\t\t\t\t\tlet max_image_offset = vec2f(square_size - 1.0, square_size - 1.0);\n\t\t\t\t\tlet new_uv = uv * square_size;\n\t\t\t\t\tlet image_offset = min(floor(new_uv), max_image_offset);\n\t\t\t\t\tlet in_image_uv = new_uv - image_offset;\n\t\t\t\t\tlet z_layer = image_offset.x + (square_size - 1 - image_offset.y) * square_size;\n\t\t\t\t\tif (z_layer >= f32(dim)) {\n\t\t\t\t\t\treturn vec4f(0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\t}\n\t\t\t\t\ttexelCoords = vec3f(in_image_uv, z_layer / f32(dim));\n\t\t\t\t}\n\t\t\t\tlet dist = textureSample(sdf, sdf_sampler, texelCoords).r;\n\t\t\t\treturn distToColor(dist);\n\t\t\t}\n\n\t\t`, [ distToColor ] );\n\n\t\tthis.fragmentNode = sdfLayerMaterialFragmentShader( fragmentShaderParams );\n\n\t\tconst vertexShaderParams = {\n\t\t\tposition: positionGeometry,\n\t\t};\n\t\tconst fullScreenQuadVertex = wgslFn( /* wgsl */ `\n\n\t\t\tfn noop(position: vec4f) -> vec4f {\n\t\t\t\treturn position;\n\t\t\t}\n\n\t\t` );\n\t\tthis.vertexNode = fullScreenQuadVertex( vertexShaderParams );\n\n\t}\n\n}\n","import * as THREE from 'three/webgpu';\nimport { uniform, wgslFn, storage, globalId, storageTexture, } from 'three/tsl';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'stats.js';\n\nimport { GenerateMeshBVHWorker } from 'three-mesh-bvh/worker';\nimport { StaticGeometryGenerator } from 'three-mesh-bvh';\nimport { closestPointToPoint } from 'three-mesh-bvh/webgpu';\n\nimport { RayMarchSDFNodeMaterial } from './utils/RayMarchSDFNodeMaterial';\nimport { RenderSDFLayerNodeMaterial } from './utils/RenderSDFLayerNodeMaterial';\n\nconst WORKGROUP_SIZE = [ 4, 4, 4 ];\nconst params = {\n\n\tresolution: 75,\n\tmargin: 0.2,\n\tregenerate: () => updateSDF(),\n\n\tmode: 'raymarching',\n\tlayer: 0,\n\tsurface: 0.1,\n\n};\n\nlet renderer, camera, scene, gui, stats, boxHelper;\nlet outputContainer, bvh, geometry, sdfTex, mesh;\nlet layerPass, raymarchPass;\nlet bvhGenerationWorker;\nlet computeKernel;\nconst inverseBoundsMatrix = new THREE.Matrix4();\n\ninit().then( render );\n\nasync function init() {\n\n\tif ( Boolean( await navigator.gpu.requestAdapter() ) === false ) {\n\n\t\tdocument.body.appendChild( getErrorMessage() );\n\n\t\tthrow new Error( 'No WebGPU support' );\n\n\t}\n\n\toutputContainer = document.getElementById( 'output' );\n\n\t// renderer setup\n\trenderer = new THREE.WebGPURenderer();\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 0 );\n\tdocument.body.appendChild( renderer.domElement );\n\tawait renderer.init();\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 1, 1, 2 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tboxHelper = new THREE.Box3Helper( new THREE.Box3() );\n\tscene.add( boxHelper );\n\n\tnew OrbitControls( camera, renderer.domElement );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// load model and generate bvh\n\tbvhGenerationWorker = new GenerateMeshBVHWorker();\n\n\tconst gltf = await new GLTFLoader()\n\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t.loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb' );\n\n\tgltf.scene.updateMatrixWorld( true );\n\n\tconst staticGen = new StaticGeometryGenerator( gltf.scene );\n\tstaticGen.attributes = [ 'position', 'normal' ];\n\tstaticGen.useGroups = false;\n\n\tgeometry = staticGen.generate().center();\n\n\tbvh = await bvhGenerationWorker.generate( geometry, { maxLeafSize: 1 } );\n\n\tmesh = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\tscene.add( mesh );\n\n\tconst geom_index = new THREE.StorageBufferAttribute( mesh.geometry.index.array, 3 );\n\tconst geom_position = new THREE.StorageBufferAttribute( mesh.geometry.attributes.position.array, 3 );\n\tconst bvhNodes = new THREE.StorageBufferAttribute( new Float32Array( bvh._roots[ 0 ] ), 8 );\n\n\tconst computeShaderParams = {\n\t\tmatrix: uniform( new THREE.Matrix4() ),\n\t\tdim: uniform( 0 ),\n\n\t\tbvh_index: storage( geom_index, 'uvec3', geom_index.count ).toReadOnly(),\n\t\tbvh_position: storage( geom_position, 'vec3', geom_position.count ).toReadOnly(),\n\t\tbvh: storage( bvhNodes, 'BVHNode', bvhNodes.count ).toReadOnly(),\n\n\t\tglobalId: globalId,\n\t\toutput: storageTexture( sdfTex ),\n\t};\n\n\tconst computeShader = wgslFn( /* wgsl */ `\n\n\t\tfn computeSdf(\n\t\t\tbvh_index: ptr<storage, array<vec3u>, read>,\n\t\t\tbvh_position: ptr<storage, array<vec3f>, read>,\n\t\t\tbvh: ptr<storage, array<BVHNode>, read>,\n\n\t\t\tmatrix: mat4x4f,\n\t\t\tdim: u32,\n\t\t\tglobalId: vec3u,\n\n\t\t\toutput: texture_storage_3d<r32float, write>,\n\t\t) -> void {\n\t\t\tif (globalId.x >= dim) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (globalId.y >= dim) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (globalId.z >= dim) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet pxWidth = 1.0 / f32(dim);\n\t\t\tlet halfWidth = 0.5 * pxWidth;\n\t\t\tlet pointHomo = vec4f(\n\t\t\t\thalfWidth + f32(globalId.x) * pxWidth - 0.5,\n\t\t\t\thalfWidth + f32(globalId.y) * pxWidth - 0.5,\n\t\t\t\thalfWidth + f32(globalId.z) * pxWidth - 0.5,\n\t\t\t\t1.0\n\t\t\t) * matrix;\n\t\t\tlet point = pointHomo.xyz / pointHomo.w;\n\n\t\t\tlet res = bvhClosestPointToPoint(bvh_index, bvh_position, bvh, point, 10000.0);\n\t\t\tlet value = res.side * sqrt( res.distanceSq );\n\n\t\t\tlet mipLevel = 0;\n\t\t\ttextureStore(output, globalId, vec4f(value, 0.0, 0.0, 0.0));\n\t\t}\n\n\t`, [ closestPointToPoint ] );\n\n\tcomputeKernel = computeShader( computeShaderParams ).computeKernel( WORKGROUP_SIZE );\n\n\trebuildGUI();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n\tupdateSDF();\n\n\tlayerPass = new FullScreenQuad( new RenderSDFLayerNodeMaterial( sdfTex ) );\n\traymarchPass = new FullScreenQuad( new RayMarchSDFNodeMaterial( sdfTex ) );\n\n}\n\n// build the gui with parameters based on the selected display mode\nfunction rebuildGUI() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tparams.layer = Math.min( params.resolution, params.layer );\n\n\tgui = new GUI();\n\n\tconst generationFolder = gui.addFolder( 'generation' );\n\n\tgenerationFolder.add( params, 'resolution', 10, 200, 1 );\n\tgenerationFolder.add( params, 'margin', 0, 1 );\n\tgenerationFolder.add( params, 'regenerate' );\n\n\tconst displayFolder = gui.addFolder( 'display' );\n\tdisplayFolder.add( params, 'mode', [ 'geometry', 'raymarching', 'layer', 'grid layers' ] ).onChange( () => {\n\n\t\trebuildGUI();\n\n\t} );\n\n\tif ( params.mode === 'layer' ) {\n\n\t\tdisplayFolder.add( params, 'layer', 0, params.resolution - 1, 1 );\n\n\t}\n\n\tif ( params.mode === 'raymarching' ) {\n\n\t\tdisplayFolder.add( params, 'surface', - 0.2, 0.5 );\n\n\t}\n\n}\n\n// update the sdf texture based on the selected parameters\nfunction updateSDF() {\n\n\tconst dim = params.resolution;\n\tconst matrix = new THREE.Matrix4();\n\tconst center = new THREE.Vector3();\n\tconst quat = new THREE.Quaternion();\n\tconst scale = new THREE.Vector3();\n\n\t// compute the bounding box of the geometry including the margin which is used to\n\t// define the range of the SDF\n\tgeometry.boundingBox.getCenter( center );\n\tscale.subVectors( geometry.boundingBox.max, geometry.boundingBox.min );\n\tscale.x += 2 * params.margin;\n\tscale.y += 2 * params.margin;\n\tscale.z += 2 * params.margin;\n\tmatrix.compose( center, quat, scale );\n\tinverseBoundsMatrix.copy( matrix ).invert();\n\n\t// update the box helper\n\tboxHelper.box.copy( geometry.boundingBox );\n\tboxHelper.box.min.x -= params.margin;\n\tboxHelper.box.min.y -= params.margin;\n\tboxHelper.box.min.z -= params.margin;\n\tboxHelper.box.max.x += params.margin;\n\tboxHelper.box.max.y += params.margin;\n\tboxHelper.box.max.z += params.margin;\n\n\t// dispose and recreate storage 3D texture for this update\n\tif ( sdfTex ) {\n\n\t\tsdfTex.dispose();\n\n\t}\n\n\tsdfTex = new THREE.Storage3DTexture( dim, dim, dim );\n\tsdfTex.format = THREE.RedFormat;\n\tsdfTex.type = THREE.FloatType;\n\tsdfTex.generateMipmaps = false;\n\tsdfTex.needsUpdate = true;\n\tsdfTex.wrapR = THREE.ClampToEdgeWrapping;\n\tsdfTex.wrapS = THREE.ClampToEdgeWrapping;\n\tsdfTex.wrapT = THREE.ClampToEdgeWrapping;\n\n\t// Rebind compute and material nodes to the new texture\n\tif ( computeKernel ) {\n\n\t\tcomputeKernel.computeNode.parameters.output.value = sdfTex;\n\n\t}\n\n\tif ( layerPass ) {\n\n\t\tconst mat = layerPass.material;\n\t\tmat.fragmentNode.parameters.sdf.value = sdfTex;\n\t\tmat.fragmentNode.parameters.sdf_sampler.node.value = sdfTex;\n\n\t}\n\n\tif ( raymarchPass ) {\n\n\t\tconst mat = raymarchPass.material;\n\t\tmat.fragmentNode.parameters.sdf.value = sdfTex;\n\t\tmat.fragmentNode.parameters.sdf_sampler.node.value = sdfTex;\n\n\t}\n\n\tconst startTime = window.performance.now();\n\n\tcomputeKernel.computeNode.parameters.matrix.value.copy( matrix );\n\tcomputeKernel.computeNode.parameters.dim.value = dim;\n\n\tconst dispatchSize = [\n\t\tMath.ceil( dim / WORKGROUP_SIZE[ 0 ] ),\n\t\tMath.ceil( dim / WORKGROUP_SIZE[ 1 ] ),\n\t\tMath.ceil( dim / WORKGROUP_SIZE[ 2 ] ),\n\t];\n\trenderer.compute( computeKernel, dispatchSize );\n\tif ( renderer.backend.device !== null ) {\n\n\t\trenderer.backend.device.queue.onSubmittedWorkDone().then( () => {\n\n\t\t\t// update the timing display\n\t\t\tconst endTime = window.performance.now();\n\t\t\tconst delta = endTime - startTime;\n\t\t\toutputContainer.innerText = `${delta.toFixed( 2 )}ms`;\n\n\t\t} );\n\n\t}\n\n\trebuildGUI();\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tif ( ! sdfTex ) {\n\n\t\t// render nothing\n\t\treturn;\n\n\t} else if ( params.mode === 'geometry' ) {\n\n\t\t// render the rasterized geometry\n\t\trenderer.render( scene, camera );\n\n\t} else if ( params.mode === 'layer' || params.mode === 'grid layers' ) {\n\n\t\t// // render a layer of the 3d texture\n\t\t// let tex;\n\t\tconst material = layerPass.material;\n\n\t\tmaterial.fragmentNode.parameters.layer.value = params.layer;\n\t\tmaterial.fragmentNode.parameters.grid_mode.value = ( params.mode === 'grid layers' );\n\n\t\tlayerPass.render( renderer );\n\n\t} else if ( params.mode === 'raymarching' ) {\n\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tconst material = raymarchPass.material;\n\n\t\tmaterial.fragmentNode.parameters.surface.value = params.surface;\n\t\tmaterial.fragmentNode.parameters.normalStep.value.set( 1, 1, 1 ).divideScalar( params.resolution );\n\t\tmaterial.fragmentNode.parameters.projectionInverse.value.copy( camera.projectionMatrixInverse );\n\n\t\tconst sdfInv = new THREE.Matrix4()\n\t\t\t.copy( mesh.matrixWorld ).invert()\n\t\t\t.premultiply( inverseBoundsMatrix )\n\t\t\t.multiply( camera.matrixWorld );\n\n\t\tmaterial.fragmentNode.parameters.sdfTransformInverse.value.copy( sdfInv );\n\t\tsdfInv.invert();\n\t\tmaterial.fragmentNode.parameters.sdfTransform.value.copy( sdfInv );\n\n\t\traymarchPass.render( renderer );\n\n\t}\n\n}\n\nfunction getErrorMessage() {\n\n\tconst message = 'Your browser does not support <a href=\"https://gpuweb.github.io/gpuweb/\" style=\"color:blue\">WebGPU</a> yet';\n\n\tconst element = document.createElement( 'div' );\n\telement.id = 'webgpumessage';\n\telement.style.fontFamily = 'monospace';\n\telement.style.fontSize = '13px';\n\telement.style.fontWeight = 'normal';\n\telement.style.textAlign = 'center';\n\telement.style.background = '#fff';\n\telement.style.color = '#000';\n\telement.style.padding = '1.5em';\n\telement.style.maxWidth = '400px';\n\telement.style.margin = '5em auto 0';\n\n\telement.innerHTML = message;\n\n\treturn element;\n\n}\n"],"names":["closestPointToPointResultStruct","wgsl","closestPointToTriangleResultStruct","closestPointToTriangle","wgslFn","distanceToTriangles","distanceSqToBounds","distanceSqToBVHNodeBoundsPoint","bvhNodeStruct","closestPointToPoint","RayMarchSDFNodeMaterial","NodeMaterial","sdfTexture","raymarchFragmentParams","uniform","Vector3","Matrix4","varying","uv","sampler","texture3D","rayBoxDistFn","raymarchFragmentShader","vertexShaderParams","positionGeometry","fullScreenQuadVertex","RenderSDFLayerNodeMaterial","distToColor","fragmentShaderParams","sdfLayerMaterialFragmentShader","WORKGROUP_SIZE","params","updateSDF","renderer","camera","scene","gui","stats","boxHelper","outputContainer","bvh","geometry","sdfTex","mesh","layerPass","raymarchPass","bvhGenerationWorker","computeKernel","inverseBoundsMatrix","THREE.Matrix4","init","render","getErrorMessage","THREE.WebGPURenderer","THREE.Scene","light","THREE.DirectionalLight","THREE.AmbientLight","THREE.PerspectiveCamera","THREE.Box3Helper","THREE.Box3","OrbitControls","Stats","GenerateMeshBVHWorker","gltf","GLTFLoader","MeshoptDecoder","staticGen","StaticGeometryGenerator","THREE.Mesh","THREE.MeshStandardMaterial","geom_index","THREE.StorageBufferAttribute","geom_position","bvhNodes","computeShaderParams","storage","globalId","storageTexture","rebuildGUI","FullScreenQuad","GUI","generationFolder","displayFolder","dim","matrix","center","THREE.Vector3","quat","THREE.Quaternion","scale","THREE.Storage3DTexture","THREE.RedFormat","THREE.FloatType","THREE.ClampToEdgeWrapping","mat","startTime","dispatchSize","delta","material","sdfInv","message","element"],"mappings":"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"}