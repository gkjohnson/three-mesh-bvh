{"version":3,"file":"ObjectBVH-DzrY0qF4.js","sources":["../../src/bvh/ObjectBVH.js"],"sourcesContent":["import { Box3, BufferGeometry, Matrix4, Mesh, Vector3, Ray, Sphere } from 'three';\nimport { BVH, INTERSECTED, NOT_INTERSECTED } from 'three-mesh-bvh';\n\nconst _geometry = /* @__PURE__ */ new BufferGeometry();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _inverseMatrix = /* @__PURE__ */ new Matrix4();\nconst _box = /* @__PURE__ */ new Box3();\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _mesh = /* @__PURE__ */ new Mesh();\nconst _geometryRange = {};\n\n// TODO: account for a \"custom\" object? Not necessary here? Create a more abstract foundation for this case?\nexport function objectAcceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.boundsTree ) {\n\n\t\tthis.boundsTree.raycast( raycaster, intersects );\n\t\treturn false;\n\n\t}\n\n}\n\nexport class ObjectBVH extends BVH {\n\n\tconstructor( root, options = {} ) {\n\n\t\toptions = {\n\t\t\tprecise: false,\n\t\t\tincludeInstances: true,\n\t\t\tmatrixWorld: Array.isArray( root ) ? new Matrix4() : root.matrixWorld,\n\t\t\tmaxLeafSize: 1,\n\t\t\t...options,\n\t\t};\n\n\t\tsuper();\n\n\t\t// collect all the leaf node objects in the geometries\n\t\tconst objectSet = new Set();\n\t\tcollectObjects( root, objectSet );\n\n\t\t// calculate the number of bits required for the primary id, leaving the remainder\n\t\t// for the instanceId count\n\t\tconst objects = Array.from( objectSet );\n\t\tconst idBits = Math.ceil( Math.log2( objects.length ) );\n\t\tconst idMask = constructIdMask( idBits );\n\n\t\tthis.objects = objects;\n\t\tthis.idBits = idBits;\n\t\tthis.idMask = idMask;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = 1;\n\n\t\t// settings\n\t\tthis.precise = options.precise;\n\t\tthis.includeInstances = options.includeInstances;\n\t\tthis.matrixWorld = options.matrixWorld;\n\n\t\tthis.init( options );\n\n\t}\n\n\tinit( options ) {\n\n\t\tconst { objects, idBits } = this;\n\t\tthis.primitiveBuffer = new Uint32Array( this._countPrimitives( objects ) );\n\t\tthis._fillPrimitiveBuffer( objects, idBits, this.primitiveBuffer );\n\n\t\tsuper.init( options );\n\n\t}\n\n\twritePrimitiveBounds( i, targetBuffer, writeOffset ) {\n\n\t\t// TODO: it would be best to cache this matrix inversion\n\t\tconst { primitiveBuffer } = this;\n\t\t_inverseMatrix.copy( this.matrixWorld ).invert();\n\n\t\tthis._getPrimitiveBoundingBox( primitiveBuffer[ i ], _inverseMatrix, _box );\n\t\tconst { min, max } = _box;\n\n\t\ttargetBuffer[ writeOffset + 0 ] = min.x;\n\t\ttargetBuffer[ writeOffset + 1 ] = min.y;\n\t\ttargetBuffer[ writeOffset + 2 ] = min.z;\n\t\ttargetBuffer[ writeOffset + 3 ] = max.x;\n\t\ttargetBuffer[ writeOffset + 4 ] = max.y;\n\t\ttargetBuffer[ writeOffset + 5 ] = max.z;\n\n\t}\n\n\tgetRootRanges() {\n\n\t\treturn [ { offset: 0, count: this.primitiveBuffer.length } ];\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\treturn super.shapecast( {\n\t\t\t...callbacks,\n\n\t\t\tintersectsPrimitive: callbacks.intersectsObject,\n\t\t\tscratchPrimitive: null,\n\t\t\titerate: iterateOverObjects,\n\t\t} );\n\n\t}\n\n\t// TODO: this is out of sync with the MeshBVH raycast signature.\n\traycast( raycaster, intersects = [] ) {\n\n\t\tconst { matrixWorld, includeInstances } = this;\n\t\tconst { firstHitOnly } = raycaster;\n\t\tconst localIntersects = [];\n\n\t\t// transform the ray into the local bvh frame\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestHit = null;\n\n\t\tthis.shapecast( {\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn box.distanceToPoint( _ray.origin );\n\n\t\t\t},\n\t\t\tintersectsBounds: box => {\n\n\t\t\t\tif ( firstHitOnly ) {\n\n\t\t\t\t\tif ( ! _ray.intersectBox( box, _vec ) ) {\n\n\t\t\t\t\t\treturn NOT_INTERSECTED;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// early out if the box is further than the closest raycast\n\t\t\t\t\t_vec.applyMatrix4( matrixWorld );\n\t\t\t\t\treturn raycaster.ray.origin.distanceTo( _vec ) < closestDistance ? INTERSECTED : NOT_INTERSECTED;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn _ray.intersectsBox( box ) ? INTERSECTED : NOT_INTERSECTED;\n\n\t\t\t\t}\n\n\t\t\t},\n\t\t\tintersectsObject( object, instanceId ) {\n\n\t\t\t\t// skip non visible objects\n\t\t\t\tif ( ! object.visible ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.isInstancedMesh && includeInstances ) {\n\n\t\t\t\t\t// raycast the instance\n\t\t\t\t\t_mesh.geometry = object.geometry;\n\t\t\t\t\t_mesh.material = object.material;\n\n\t\t\t\t\tobject.getMatrixAt( instanceId, _mesh.matrixWorld );\n\t\t\t\t\t_mesh.matrixWorld.premultiply( object.matrixWorld );\n\t\t\t\t\t_mesh.raycast( raycaster, localIntersects );\n\n\t\t\t\t\tlocalIntersects.forEach( hit => {\n\n\t\t\t\t\t\thit.object = object;\n\t\t\t\t\t\thit.instanceId = instanceId;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t_mesh.material = null;\n\n\t\t\t\t} else if ( object.isBatchedMesh && includeInstances ) {\n\n\t\t\t\t\tif ( ! object.getVisibleAt( instanceId ) ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// extract the geometry & material\n\t\t\t\t\tconst geometryId = object.getGeometryIdAt( instanceId );\n\t\t\t\t\tconst geometryRange = object.getGeometryRangeAt( geometryId, _geometryRange );\n\n\t\t\t\t\t_geometry.index = object.geometry.index;\n\t\t\t\t\t_geometry.attributes.position = object.geometry.attributes.position;\n\t\t\t\t\t_geometry.setDrawRange( geometryRange.start, geometryRange.count );\n\n\t\t\t\t\t_mesh.geometry = _geometry;\n\t\t\t\t\t_mesh.material = object.material;\n\n\t\t\t\t\t// perform a raycast against the proxy mesh\n\t\t\t\t\tobject.getMatrixAt( instanceId, _mesh.matrixWorld );\n\t\t\t\t\t_mesh.matrixWorld.premultiply( object.matrixWorld );\n\t\t\t\t\t_mesh.raycast( raycaster, localIntersects );\n\n\t\t\t\t\t// fix up the fields\n\t\t\t\t\tlocalIntersects.forEach( hit => {\n\n\t\t\t\t\t\thit.object = object;\n\t\t\t\t\t\thit.batchId = instanceId;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t_mesh.material = null;\n\t\t\t\t\t_geometry.index = null;\n\t\t\t\t\t_geometry.attributes.position = null;\n\t\t\t\t\t_geometry.setDrawRange( 0, Infinity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.raycast( raycaster, localIntersects );\n\n\t\t\t\t}\n\n\t\t\t\t// find the closest hit to track\n\t\t\t\tif ( firstHitOnly ) {\n\n\t\t\t\t\tlocalIntersects.forEach( hit => {\n\n\t\t\t\t\t\tif ( hit.distance < closestDistance ) {\n\n\t\t\t\t\t\t\tclosestDistance = hit.distance;\n\t\t\t\t\t\t\tclosestHit = hit;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersects.push( ...localIntersects );\n\n\t\t\t\t}\n\n\t\t\t},\n\t\t} );\n\n\t\t// save the closest hit only if firstHitOnly = true\n\t\tif ( firstHitOnly && closestHit ) {\n\n\t\t\tintersects.push( closestHit );\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\t// get the bounding box of a primitive node accounting for the bvh options\n\t_getPrimitiveBoundingBox( compositeId, inverseMatrixWorld, target ) {\n\n\t\tconst { objects, idMask, idBits, precise, includeInstances } = this;\n\t\tconst id = getObjectId( compositeId, idMask );\n\t\tconst instanceId = getInstanceId( compositeId, idBits, idMask );\n\t\tconst object = objects[ id ];\n\n\t\tif ( ! includeInstances && ( object.isInstancedMesh || object.isBatchedMesh ) ) {\n\n\t\t\t// if we're not using instances then just account for the overall bounds of the BatchedMesh and InstancedMesh\n\t\t\tif ( ! object.boundingBox ) {\n\n\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( ! object.boundingSphere ) {\n\n\t\t\t\tobject.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\t_matrix\n\t\t\t\t.copy( object.matrixWorld )\n\t\t\t\t.premultiply( inverseMatrixWorld );\n\n\t\t\t_sphere\n\t\t\t\t.copy( object.boundingSphere )\n\t\t\t\t.applyMatrix4( _matrix );\n\n\t\t\ttarget\n\t\t\t\t.copy( object.boundingBox )\n\t\t\t\t.applyMatrix4( _matrix );\n\n\t\t\tshrinkToSphere( target, _sphere );\n\n\t\t} else if ( precise ) {\n\n\t\t\t// calculate precise bounds if necessary by calculating the bounds of all vertices\n\t\t\t// in the bvh frame\n\t\t\tif ( object.isInstancedMesh ) {\n\n\t\t\t\tobject\n\t\t\t\t\t.getMatrixAt( instanceId, _matrix );\n\n\t\t\t\t_matrix\n\t\t\t\t\t.premultiply( object.matrixWorld )\n\t\t\t\t\t.premultiply( inverseMatrixWorld );\n\n\t\t\t\tgetPreciseBounds( object.geometry, _matrix, target );\n\n\t\t\t} else if ( object.isBatchedMesh ) {\n\n\t\t\t\tconst geometryId = object.getGeometryIdAt( instanceId );\n\t\t\t\tconst geometryRange = object.getGeometryRangeAt( geometryId, _geometryRange );\n\n\t\t\t\t_geometry.index = object.geometry.index;\n\t\t\t\t_geometry.attributes.position = object.geometry.attributes.position;\n\t\t\t\t_geometry.setDrawRange( geometryRange.start, geometryRange.count );\n\n\t\t\t\tobject\n\t\t\t\t\t.getMatrixAt( instanceId, _matrix );\n\n\t\t\t\t_matrix\n\t\t\t\t\t.premultiply( object.matrixWorld )\n\t\t\t\t\t.premultiply( inverseMatrixWorld );\n\n\t\t\t\tgetPreciseBounds( _geometry, _matrix, target );\n\n\t\t\t} else {\n\n\t\t\t\t_matrix\n\t\t\t\t\t.copy( object.matrixWorld )\n\t\t\t\t\t.premultiply( inverseMatrixWorld );\n\n\t\t\t\ttarget.setFromObject( object, true ).applyMatrix4( inverseMatrixWorld );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// otherwise use the fast path of extracting the cached, AABB bounds and transforming them\n\t\t\t// into the local BVH frame\n\t\t\tif ( object.isInstancedMesh ) {\n\n\t\t\t\tif ( ! object.geometry.boundingBox ) {\n\n\t\t\t\t\tobject.geometry.computeBoundingBox();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! object.geometry.boundingSphere ) {\n\n\t\t\t\t\tobject.geometry.computeBoundingSphere();\n\n\t\t\t\t}\n\n\t\t\t\tobject\n\t\t\t\t\t.getMatrixAt( instanceId, _matrix );\n\n\t\t\t\t_matrix\n\t\t\t\t\t.premultiply( object.matrixWorld )\n\t\t\t\t\t.premultiply( inverseMatrixWorld );\n\n\t\t\t\t_sphere\n\t\t\t\t\t.copy( object.geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( _matrix );\n\n\t\t\t\ttarget\n\t\t\t\t\t.copy( object.geometry.boundingBox )\n\t\t\t\t\t.applyMatrix4( _matrix );\n\n\t\t\t\tshrinkToSphere( target, _sphere );\n\n\t\t\t} else if ( object.isBatchedMesh ) {\n\n\t\t\t\tconst geometryId = object.getGeometryIdAt( instanceId );\n\n\t\t\t\tobject\n\t\t\t\t\t.getMatrixAt( instanceId, _matrix );\n\n\t\t\t\t_matrix\n\t\t\t\t\t.premultiply( object.matrixWorld )\n\t\t\t\t\t.premultiply( inverseMatrixWorld );\n\n\t\t\t\tobject\n\t\t\t\t\t.getBoundingSphereAt( geometryId, _sphere )\n\t\t\t\t\t.applyMatrix4( _matrix );\n\n\t\t\t\tobject\n\t\t\t\t\t.getBoundingBoxAt( geometryId, target )\n\t\t\t\t\t.applyMatrix4( _matrix );\n\n\t\t\t\tshrinkToSphere( target, _sphere );\n\n\t\t\t} else {\n\n\t\t\t\ttarget\n\t\t\t\t\t.setFromObject( object, false )\n\t\t\t\t\t.applyMatrix4( inverseMatrixWorld );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// counts the total number of primitives required by the objects in given array of objects\n\t_countPrimitives( objects ) {\n\n\t\tconst { includeInstances } = this;\n\t\tlet total = 0;\n\t\tobjects.forEach( object => {\n\n\t\t\tif ( object.isInstancedMesh && includeInstances ) {\n\n\t\t\t\ttotal += object.count;\n\n\t\t\t} else if ( object.isBatchedMesh && includeInstances ) {\n\n\t\t\t\ttotal += object.instanceCount;\n\n\t\t\t} else {\n\n\t\t\t\ttotal ++;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn total;\n\n\t}\n\n\t_fillPrimitiveBuffer( objects, idBits, target ) {\n\n\t\tconst { includeInstances } = this;\n\t\tlet index = 0;\n\t\tobjects.forEach( ( object, i ) => {\n\n\t\t\tif ( object.isInstancedMesh && includeInstances ) {\n\n\t\t\t\tconst count = object.count;\n\t\t\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\t\t\ttarget[ index ] = ( c << idBits ) | i;\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isBatchedMesh && includeInstances ) {\n\n\t\t\t\tconst { instanceCount, maxInstanceCount } = object;\n\t\t\t\tlet instance = 0;\n\t\t\t\tlet iter = 0;\n\t\t\t\t// TODO: use a better check here, like \"maxInstanceCount\"\n\t\t\t\twhile ( instance < instanceCount && iter < maxInstanceCount ) {\n\n\t\t\t\t\titer ++;\n\n\t\t\t\t\t// TODO: it would be better to have a consistent way of querying whether an\n\t\t\t\t\t// instance were active\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tobject.getVisibleAt( instance );\n\n\t\t\t\t\t\ttarget[ index ] = ( instance << idBits ) | i;\n\t\t\t\t\t\tinstance ++;\n\t\t\t\t\t\tindex ++;\n\n\t\t\t\t\t} catch {\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttarget[ index ] = i;\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\n// id functions\n// construct a mask with the given number of bits set to 1\nfunction constructIdMask( idBits ) {\n\n\tlet mask = 0;\n\tfor ( let i = 0; i < idBits; i ++ ) {\n\n\t\tmask = mask << 1 | 1;\n\n\t}\n\n\treturn mask;\n\n}\n\n// extract the primary object id given the provided mask\nfunction getObjectId( id, idMask ) {\n\n\treturn id & idMask;\n\n}\n\n// extract the instance id given the mask and number of bits to shift\nfunction getInstanceId( id, idBits, idMask ) {\n\n\treturn ( id & ( ~ idMask ) ) >> idBits;\n\n}\n\n// traverse the full scene and collect all leaves\nfunction collectObjects( root, objectSet = new Set() ) {\n\n\tif ( Array.isArray( root ) ) {\n\n\t\troot.forEach( object => collectObjects( object, objectSet ) );\n\n\t} else {\n\n\t\troot.traverse( child => {\n\n\t\t\tif ( child.isMesh || child.isLine || child.isPoints ) {\n\n\t\t\t\tobjectSet.add( child );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\n// calculate precise box bounds of the given geometry in the given frame\nfunction getPreciseBounds( geometry, matrix, target ) {\n\n\ttarget.makeEmpty();\n\n\tconst drawRange = geometry.drawRange;\n\tconst indexAttr = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst start = drawRange.start;\n\tconst vertCount = indexAttr ? indexAttr.count : posAttr.count;\n\tconst count = Math.min( vertCount - start, drawRange.count );\n\tfor ( let i = start, l = start + count; i < l; i ++ ) {\n\n\t\tlet vi = i;\n\t\tif ( indexAttr ) {\n\n\t\t\tvi = indexAttr.getX( vi );\n\n\t\t}\n\n\t\t_vec.fromBufferAttribute( posAttr, vi ).applyMatrix4( matrix );\n\t\ttarget.expandByPoint( _vec );\n\n\t}\n\n\treturn target;\n\n}\n\n// iterator helper for raycasting\nfunction iterateOverObjects( offset, count, bvh, callback, contained, depth, /* scratch */ ) {\n\n\tconst { primitiveBuffer, objects, idMask, idBits } = bvh;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tconst compositeId = primitiveBuffer[ i ];\n\t\tconst id = getObjectId( compositeId, idMask );\n\t\tconst instanceId = getInstanceId( compositeId, idBits, idMask );\n\t\tconst object = objects[ id ];\n\t\tif ( callback( object, instanceId, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nfunction shrinkToSphere( box, sphere ) {\n\n\t_vec.copy( sphere.center ).addScalar( - sphere.radius );\n\tbox.min.max( _vec );\n\n\t_vec.copy( sphere.center ).addScalar( sphere.radius );\n\tbox.max.min( _vec );\n\n}\n"],"names":["_geometry","BufferGeometry","_matrix","Matrix4","_inverseMatrix","_box","Box3","_sphere","Sphere","_vec","Vector3","_ray","Ray","_mesh","Mesh","_geometryRange","objectAcceleratedRaycast","raycaster","intersects","ObjectBVH","BVH","root","options","objectSet","collectObjects","objects","idBits","idMask","constructIdMask","targetBuffer","writeOffset","primitiveBuffer","min","max","callbacks","iterateOverObjects","matrixWorld","includeInstances","firstHitOnly","localIntersects","closestDistance","closestHit","box","INTERSECTED","NOT_INTERSECTED","object","instanceId","hit","geometryId","geometryRange","compositeId","inverseMatrixWorld","target","precise","id","getObjectId","getInstanceId","shrinkToSphere","getPreciseBounds","total","index","i","count","c","instanceCount","maxInstanceCount","instance","iter","mask","child","geometry","matrix","drawRange","indexAttr","posAttr","start","vertCount","l","vi","offset","bvh","callback","contained","depth","sphere"],"mappings":"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"}