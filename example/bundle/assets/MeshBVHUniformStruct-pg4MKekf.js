import{as as S,F as B,$ as R,at as F,au as U,av as M,aw as G,ax as b,ay as V,a0 as E,az as z,aA as v,aB as D,aC as k,R as L,B as O}from"./ExtendedTriangle-DttJMGjs.js";import{g as P,b as Y,B as x,d as H,f as q,O as X,R as j,h as W,j as Z}from"./MeshBVH-DAC57waP.js";function $(c){switch(c){case 1:return"R";case 2:return"RG";case 3:return"RGBA";case 4:return"RGBA"}throw new Error}function J(c){switch(c){case 1:return L;case 2:return k;case 3:return E;case 4:return E}}function T(c){switch(c){case 1:return D;case 2:return v;case 3:return z;case 4:return z}}class C extends R{constructor(){super(),this.minFilter=F,this.magFilter=F,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(e){const t=this.overrideItemSize,d=e.itemSize,r=e.count;if(t!==null){if(d*r%t!==0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");e.itemSize=t,e.count=r*d/t}const n=e.itemSize,y=e.count,A=e.normalized,l=e.array.constructor,i=l.BYTES_PER_ELEMENT;let u=this._forcedType,m=n;if(u===null)switch(l){case Float32Array:u=B;break;case Uint8Array:case Uint16Array:case Uint32Array:u=S;break;case Int8Array:case Int16Array:case Int32Array:u=U;break}let s,a,h,f,p=$(n);switch(u){case B:h=1,a=J(n),A&&i===1?(f=l,p+="8",l===Uint8Array?s=M:(s=b,p+="_SNORM")):(f=Float32Array,p+="32F",s=B);break;case U:p+=i*8+"I",h=A?Math.pow(2,l.BYTES_PER_ELEMENT*8-1):1,a=T(n),i===1?(f=Int8Array,s=b):i===2?(f=Int16Array,s=V):(f=Int32Array,s=U);break;case S:p+=i*8+"UI",h=A?Math.pow(2,l.BYTES_PER_ELEMENT*8-1):1,a=T(n),i===1?(f=Uint8Array,s=M):i===2?(f=Uint16Array,s=G):(f=Uint32Array,s=S);break}m===3&&(a===E||a===z)&&(m=4);const o=Math.ceil(Math.sqrt(y))||1,w=m*o*o,g=new f(w),N=e.normalized;e.normalized=!1;for(let I=0;I<y;I++){const _=m*I;g[_]=e.getX(I)/h,n>=2&&(g[_+1]=e.getY(I)/h),n>=3&&(g[_+2]=e.getZ(I)/h,m===4&&(g[_+3]=1)),n>=4&&(g[_+3]=e.getW(I)/h)}e.normalized=N,this.internalFormat=p,this.format=a,this.type=s,this.image.width=o,this.image.height=o,this.image.data=g,this.needsUpdate=!0,this.dispose(),e.itemSize=d,e.count=r}}class K extends C{constructor(){super(),this._forcedType=S}}class Q extends C{constructor(){super(),this._forcedType=B}}class ne{constructor(){this.index=new K,this.position=new Q,this.bvhBounds=new R,this.bvhContents=new R,this._cachedIndexAttr=null,this.index.overrideItemSize=3}updateFrom(e){const{geometry:t}=e;if(te(e,this.bvhBounds,this.bvhContents),this.position.updateFrom(t.attributes.position),e.indirect){const d=e._indirectBuffer;if(this._cachedIndexAttr===null||this._cachedIndexAttr.count!==d.length)if(t.index)this._cachedIndexAttr=t.index.clone();else{const r=P(Y(t));this._cachedIndexAttr=new O(r,1,!1)}ee(t,d,this._cachedIndexAttr),this.index.updateFrom(this._cachedIndexAttr)}else this.index.updateFrom(t.index)}dispose(){const{index:e,position:t,bvhBounds:d,bvhContents:r}=this;e&&e.dispose(),t&&t.dispose(),d&&d.dispose(),r&&r.dispose()}}function ee(c,e,t){const d=t.array,r=c.index?c.index.array:null;for(let n=0,y=e.length;n<y;n++){const A=3*n,l=3*e[n];for(let i=0;i<3;i++)d[A+i]=r?r[l+i]:l+i}}function te(c,e,t){const d=c._roots;if(d.length!==1)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const r=d[0],n=new Uint16Array(r),y=new Uint32Array(r),A=new Float32Array(r),l=r.byteLength/x,i=2*Math.ceil(Math.sqrt(l/2)),u=new Float32Array(4*i*i),m=Math.ceil(Math.sqrt(l)),s=new Uint32Array(2*m*m);for(let a=0;a<l;a++){const h=a*x/4,f=h*2,p=Z(h);for(let o=0;o<3;o++)u[8*a+0+o]=A[p+0+o],u[8*a+4+o]=A[p+3+o];if(H(f,n)){const o=q(f,n),w=X(h,y),g=4294901760|o;s[a*2+0]=g,s[a*2+1]=w}else{const o=4*j(h,y)/x,w=W(h,y);s[a*2+0]=w,s[a*2+1]=o}}e.image.data=u,e.image.width=i,e.image.height=i,e.format=E,e.type=B,e.internalFormat="RGBA32F",e.minFilter=F,e.magFilter=F,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),t.image.data=s,t.image.width=m,t.image.height=m,t.format=v,t.type=S,t.internalFormat="RG32UI",t.minFilter=F,t.magFilter=F,t.generateMipmaps=!1,t.needsUpdate=!0,t.dispose()}export{Q as F,ne as M};
