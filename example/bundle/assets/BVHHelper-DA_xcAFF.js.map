{"version":3,"file":"BVHHelper-DA_xcAFF.js","sources":["../../../src/objects/BVHHelper.js"],"sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry, Mesh, Matrix4, Vector3 } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst matrix = /* @__PURE__ */ new Matrix4();\nconst vec = /* @__PURE__ */ new Vector3();\n\nclass BVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tgetVertexPosition( ...args ) {\n\n\t\t// implement this function so it works with Box3.setFromObject\n\t\treturn Mesh.prototype.getVertexPosition.call( this, ...args );\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'BVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst boundsTree = this.bvh;\n\t\tthis.geometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\tthis.geometry = this.getGeometry( boundsTree );\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n\tgetGeometry( boundsTree ) {\n\n\t\tconst group = this._group;\n\n\t\t// fill in the position buffer with the bounds corners\n\t\tlet positionArray = null;\n\t\tif ( group !== - 1 ) {\n\n\t\t\tpositionArray = this.getBVHBoundPositions( boundsTree, group );\n\n\t\t} else {\n\n\t\t\tconst positionArrays = boundsTree._roots.map( ( r, i ) => this.getBVHBoundPositions( boundsTree, i ) );\n\t\t\tconst total = positionArrays.reduce( ( v, arr ) => v + arr.length, 0 );\n\t\t\tpositionArray = new Float32Array( total );\n\n\t\t\tlet offset = 0;\n\t\t\tpositionArrays.forEach( arr => {\n\n\t\t\t\tpositionArray.set( arr, offset );\n\t\t\t\toffset += arr.length;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst indexArray = this.getBVHBoundIndices( positionArray );\n\n\t\t// update the geometry\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positionArray, 3, false ) );\n\t\treturn geometry;\n\n\t}\n\n\tgetBVHBoundIndices( positionArray ) {\n\n\t\tconst boundsCount = positionArray.length / ( 8 * 3 );\n\t\tlet indexArray;\n\t\tlet indices;\n\t\tif ( this.displayEdges ) {\n\n\t\t\t// fill in the index buffer to point to the corner points\n\t\t\tindices = new Uint8Array( [\n\t\t\t\t// x axis\n\t\t\t\t0, 4,\n\t\t\t\t1, 5,\n\t\t\t\t2, 6,\n\t\t\t\t3, 7,\n\n\t\t\t\t// y axis\n\t\t\t\t0, 2,\n\t\t\t\t1, 3,\n\t\t\t\t4, 6,\n\t\t\t\t5, 7,\n\n\t\t\t\t// z axis\n\t\t\t\t0, 1,\n\t\t\t\t2, 3,\n\t\t\t\t4, 5,\n\t\t\t\t6, 7,\n\t\t\t] );\n\n\t\t} else {\n\n\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t// X-, X+\n\t\t\t\t0, 1, 2,\n\t\t\t\t2, 1, 3,\n\n\t\t\t\t4, 6, 5,\n\t\t\t\t6, 7, 5,\n\n\t\t\t\t// Y-, Y+\n\t\t\t\t1, 4, 5,\n\t\t\t\t0, 4, 1,\n\n\t\t\t\t2, 3, 6,\n\t\t\t\t3, 7, 6,\n\n\t\t\t\t// Z-, Z+\n\t\t\t\t0, 2, 4,\n\t\t\t\t2, 6, 4,\n\n\t\t\t\t1, 5, 3,\n\t\t\t\t3, 5, 7,\n\n\t\t\t] );\n\n\t\t}\n\n\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t} else {\n\n\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t}\n\n\t\tconst indexLength = indices.length;\n\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\tconst posOffset = i * 8;\n\t\t\tconst indexOffset = i * indexLength;\n\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn indexArray;\n\n\t}\n\n\tgetBVHBoundPositions( bvh, group = 0, matrix = null ) {\n\n\t\t// count the number of bounds required\n\t\tconst targetDepth = this.depth - 1;\n\t\tconst displayParents = this.displayParents;\n\t\tlet boundsCount = 0;\n\t\tbvh.traverse( ( depth, isLeaf ) => {\n\n\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\tboundsCount ++;\n\t\t\t\treturn true;\n\n\t\t\t} else if ( displayParents ) {\n\n\t\t\t\tboundsCount ++;\n\n\t\t\t}\n\n\t\t}, group );\n\n\t\t// fill in the position buffer with the bounds corners\n\t\tlet posIndex = 0;\n\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\tbvh.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\tvec.set( xVal, yVal, zVal );\n\t\t\t\t\t\t\tif ( matrix ) {\n\n\t\t\t\t\t\t\t\tvec.applyMatrix4( matrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvec.toArray( positionArray, posIndex );\n\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn terminate;\n\n\t\t\t}\n\n\t\t}, group );\n\n\t\treturn positionArray;\n\n\t}\n\n}\n\nexport class BVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tget objectIndex() {\n\n\t\tconsole.warn( 'BVHHelper: \"objectIndex\" has been renamed \"instanceId\".' );\n\t\treturn this.instanceId;\n\n\t}\n\n\tset objectIndex( v ) {\n\n\t\tconsole.warn( 'BVHHelper: \"objectIndex\" has been renamed \"instanceId\".' );\n\t\tthis.instanceId = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'BVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis.instanceId = 0;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst instanceId = this.instanceId;\n\t\tlet bvh = this.bvh || mesh.boundsTree || mesh.geometry && mesh.geometry.boundsTree || null;\n\t\tif ( mesh && mesh.isBatchedMesh && mesh.boundsTrees && ! bvh && instanceId >= 0 ) {\n\n\t\t\t// get the bvh from a batchedMesh if not provided\n\t\t\t// TODO: we should have an official way to get the geometry index cleanly\n\t\t\tconst drawInfo = mesh._drawInfo[ instanceId ];\n\t\t\tif ( drawInfo ) {\n\n\t\t\t\tbvh = mesh.boundsTrees[ drawInfo.geometryIndex ] || bvh;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new BVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\t\tconst instanceId = this.instanceId;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// handle batched and instanced mesh bvhs\n\t\t\tif ( ( mesh.isInstancedMesh || mesh.isBatchedMesh ) && instanceId >= 0 ) {\n\n\t\t\t\tmesh.getMatrixAt( instanceId, matrix );\n\t\t\t\tthis.matrix.multiply( matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new BVHHelper().copy( this );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHHelper extends BVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tconsole.warn( 'MeshBVHHelper: Class has been deprecated. Use BVHHelper instead.' );\n\t\tsuper( ...args );\n\n\t}\n\n}\n"],"names":["boundingBox","Box3","matrix","Matrix4","vec","Vector3","BVHRootHelper","Object3D","args","Mesh","bvh","material","depth","group","BufferGeometry","boundsTree","positionArray","positionArrays","r","i","total","v","arr","offset","indexArray","geometry","BufferAttribute","boundsCount","indices","indexLength","posOffset","indexOffset","j","targetDepth","displayParents","isLeaf","posIndex","boundingData","terminate","arrayToBox","min","max","x","xVal","y","yVal","z","zVal","BVHHelper","Group","mesh","MeshBVH","edgeMaterial","LineBasicMaterial","meshMaterial","MeshBasicMaterial","instanceId","drawInfo","totalRoots","root","displayEdges","parent","source","children","l"],"mappings":"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"}