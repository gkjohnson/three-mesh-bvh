{"version":3,"file":"selection-DV96gD-D.js","sources":["../../src/Selection.js","../../utils/math/getConvexHull.js","../../utils/math/lineCrossesLine.js","../../utils/math/pointRayCrossesSegments.js","../../src/computeSelectedTriangles.js","../../selection.js"],"sourcesContent":["import * as THREE from 'three';\n\n/** Abstract class representing a selection using a pointer. */\nclass Selection {\n\n\tconstructor() {\n\n\t\tthis.dragging = false;\n\n\t}\n\n\thandlePointerDown() {\n\n\t\tthis.dragging = true;\n\n\t}\n\thandlePointerUp() {\n\n\t\tthis.dragging = false;\n\n\t}\n\thandlePointerMove() {}\n\n\tget points() {\n\n\t\treturn [];\n\n\t}\n\n\t/** Convert absolute screen coordinates `x` and `y` to relative coordinates in range [-1; 1]. */\n\tstatic normalizePoint( element, x, y ) {\n\n\t\tconst clientRect = element.getBoundingClientRect();\n\t\tconst correctedX = ( x - clientRect.left ) / clientRect.width;\n\t\tconst correctedY = ( y - clientRect.top ) / clientRect.height;\n\n\t\treturn [ correctedX * 2 - 1, 1 - correctedY * 2 ];\n\n\t}\n\n}\n\nconst tempVec0 = new THREE.Vector2();\nconst tempVec1 = new THREE.Vector2();\nconst tempVec2 = new THREE.Vector2();\n/** Selection that adds points on drag and connects the start and end points with a straight line. */\nexport class LassoSelection extends Selection {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.lassoPoints = [];\n\t\tthis.prevX = - Infinity;\n\t\tthis.prevY = - Infinity;\n\n\t}\n\n\thandlePointerDown( e ) {\n\n\t\tsuper.handlePointerDown();\n\t\tthis.prevX = e.clientX;\n\t\tthis.prevY = e.clientY;\n\t\tthis.lassoPoints = [];\n\n\t}\n\n\thandlePointerMove( e ) {\n\n\t\tconst ex = e.clientX;\n\t\tconst ey = e.clientY;\n\t\tconst [ nx, ny ] = Selection.normalizePoint( e.currentTarget, ex, ey );\n\n\t\t// If the mouse hasn't moved a lot since the last point\n\t\tif ( Math.abs( ex - this.prevX ) >= 3 || Math.abs( ey - this.prevY ) >= 3 ) {\n\n\t\t\t// Check if the mouse moved in roughly the same direction as the previous point\n\t\t\t// and replace it if so.\n\t\t\tconst i = this.lassoPoints.length / 3 - 1;\n\t\t\tconst i3 = i * 3;\n\t\t\tlet doReplace = false;\n\t\t\tif ( this.lassoPoints.length > 3 ) {\n\n\t\t\t\t// prev segment direction\n\t\t\t\ttempVec0.set( this.lassoPoints[ i3 - 3 ], this.lassoPoints[ i3 - 3 + 1 ] );\n\t\t\t\ttempVec1.set( this.lassoPoints[ i3 ], this.lassoPoints[ i3 + 1 ] );\n\t\t\t\ttempVec1.sub( tempVec0 ).normalize();\n\n\t\t\t\t// this segment direction\n\t\t\t\ttempVec0.set( this.lassoPoints[ i3 ], this.lassoPoints[ i3 + 1 ] );\n\t\t\t\ttempVec2.set( nx, ny );\n\t\t\t\ttempVec2.sub( tempVec0 ).normalize();\n\n\t\t\t\tconst dot = tempVec1.dot( tempVec2 );\n\t\t\t\tdoReplace = dot > 0.99;\n\n\t\t\t}\n\n\t\t\tif ( doReplace ) {\n\n\t\t\t\tthis.lassoPoints[ i3 ] = nx;\n\t\t\t\tthis.lassoPoints[ i3 + 1 ] = ny;\n\n\t\t\t} else {\n\n\t\t\t\tthis.lassoPoints.push( nx, ny, 0 );\n\n\t\t\t}\n\n\t\t\tthis.prevX = ex;\n\t\t\tthis.prevY = ey;\n\n\t\t\treturn { changed: true };\n\n\t\t}\n\n\t\treturn { changed: false };\n\n\t}\n\n\tget points() {\n\n\t\treturn this.lassoPoints;\n\n\t}\n\n}\n\nexport class BoxSelection extends Selection {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.startX = 0;\n\t\tthis.startY = 0;\n\t\tthis.currentX = 0;\n\t\tthis.currentY = 0;\n\n\t}\n\n\thandlePointerDown( e ) {\n\n\t\tsuper.handlePointerDown();\n\t\tthis.prevX = e.clientX;\n\t\tthis.prevY = e.clientY;\n\t\tconst [ nx, ny ] = Selection.normalizePoint( e.currentTarget, e.clientX, e.clientY );\n\t\tthis.startX = nx;\n\t\tthis.startY = ny;\n\t\tthis.lassoPoints = [];\n\n\t}\n\n\thandlePointerMove( e ) {\n\n\t\tconst ex = e.clientX;\n\t\tconst ey = e.clientY;\n\n\t\tconst [ nx, ny ] = Selection.normalizePoint( e.currentTarget, e.clientX, e.clientY );\n\t\tthis.currentX = nx;\n\t\tthis.currentY = ny;\n\n\t\tif ( ex === this.prevX && ey === this.prevY ) {\n\n\t\t\treturn { changed: false };\n\n\t\t}\n\n\t\tthis.prevX = ex;\n\t\tthis.prevY = ey;\n\n\t\treturn { changed: true };\n\n\t}\n\n\tget points() {\n\n\t\treturn [\n\t\t\t[ this.startX, this.startY, 0 ],\n\t\t\t[ this.currentX, this.startY, 0 ],\n\t\t\t[ this.currentX, this.currentY, 0 ],\n\t\t\t[ this.startX, this.currentY, 0 ],\n\t\t].flat();\n\n\t}\n\n}\n","/**\n * Compute a convex hull of the given points.\n *\n * Source: https://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/\n * @param {Array<THREE.Vector3>} points\n * @returns {Array<THREE.Vector3>}\n */\nexport function getConvexHull( points ) {\n\n\tfunction orientation( p, q, r ) {\n\n\t\tconst val = ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n\t\tif ( val == 0 ) {\n\n\t\t\treturn 0; // colinear\n\n\t\t}\n\n\t\t// clockwise or counterclockwise\n\t\treturn val > 0 ? 1 : 2;\n\n\t}\n\n\tfunction distSq( p1, p2 ) {\n\n\t\treturn ( p1.x - p2.x ) * ( p1.x - p2.x ) + ( p1.y - p2.y ) * ( p1.y - p2.y );\n\n\t}\n\n\tfunction compare( p1, p2 ) {\n\n\t\t// Find orientation\n\t\tconst o = orientation( p0, p1, p2 );\n\t\tif ( o == 0 ) return distSq( p0, p2 ) >= distSq( p0, p1 ) ? - 1 : 1;\n\n\t\treturn o == 2 ? - 1 : 1;\n\n\t}\n\n\t// find the lowest point in 2d\n\tlet lowestY = Infinity;\n\tlet lowestIndex = - 1;\n\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\tconst p = points[ i ];\n\t\tif ( p.y < lowestY ) {\n\n\t\t\tlowestIndex = i;\n\t\t\tlowestY = p.y;\n\n\t\t}\n\n\t}\n\n\t// sort the points\n\tconst p0 = points[ lowestIndex ];\n\tpoints[ lowestIndex ] = points[ 0 ];\n\tpoints[ 0 ] = p0;\n\n\tpoints = points.sort( compare );\n\n\t// filter the points\n\tlet m = 1;\n\tconst n = points.length;\n\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\twhile ( i < n - 1 && orientation( p0, points[ i ], points[ i + 1 ] ) == 0 ) {\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\tpoints[ m ] = points[ i ];\n\t\tm ++;\n\n\t}\n\n\t// early out if we don't have enough points for a hull\n\tif ( m < 3 ) return null;\n\n\t// generate the hull\n\tconst hull = [ points[ 0 ], points[ 1 ], points[ 2 ] ];\n\tfor ( let i = 3; i < m; i ++ ) {\n\n\t\twhile (\n\t\t\torientation( hull[ hull.length - 2 ], hull[ hull.length - 1 ], points[ i ] ) !== 2\n\t\t) {\n\n\t\t\thull.pop();\n\n\t\t}\n\n\t\thull.push( points[ i ] );\n\n\t}\n\n\treturn hull;\n\n}\n","/**\n * Check if two line segments intersect.\n *\n * Source: https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\n * @param {THREE.Line3} l1\n * @param {THREE.Line3} l2\n * @returns {boolean}\n */\nexport function lineCrossesLine( l1, l2 ) {\n\n\tfunction ccw( A, B, C ) {\n\n\t\treturn ( C.y - A.y ) * ( B.x - A.x ) > ( B.y - A.y ) * ( C.x - A.x );\n\n\t}\n\n\tconst A = l1.start;\n\tconst B = l1.end;\n\n\tconst C = l2.start;\n\tconst D = l2.end;\n\n\treturn ccw( A, C, D ) !== ccw( B, C, D ) && ccw( A, B, C ) !== ccw( A, B, D );\n\n}\n","/**\n * Check if the given point is inside the given polygon.\n * @param {THREE.Vector3} point\n * @param {Array<THREE.Line3>} polygon\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm\n */\nexport function isPointInsidePolygon( point, polygon ) {\n\n\treturn pointRayCrossesSegments( point, polygon ) % 2 === 1;\n\n}\n\n/**\n * Count how many times a ray cast from the given point crosses the segments.\n * @param {THREE.Vector3} point\n * @param {Array<THREE.Line3>} segments\n * @returns {number}\n */\nfunction pointRayCrossesSegments( point, segments ) {\n\n\tlet crossings = 0;\n\tconst firstSeg = segments[ segments.length - 1 ];\n\tlet prevSegmentGoesDown = firstSeg.start.y > firstSeg.end.y;\n\tfor ( let s = 0, l = segments.length; s < l; s ++ ) {\n\n\t\tconst line = segments[ s ];\n\t\tconst thisSegmentGoesDown = line.start.y > line.end.y;\n\t\tif (\n\t\t\tpointRayCrossesLine( point, line, prevSegmentGoesDown, thisSegmentGoesDown )\n\t\t) {\n\n\t\t\tcrossings ++;\n\n\t\t}\n\n\t\tprevSegmentGoesDown = thisSegmentGoesDown;\n\n\t}\n\n\treturn crossings;\n\n}\n\n/**\n * Check if a ray cast from `point` to the right intersects the line segment.\n *\n * @param {THREE.Vector3} point\n * @param {THREE.Line3} line\n * @param {boolean} prevSegmentGoesDown\n * @param {boolean} thisSegmentGoesDown\n */\nfunction pointRayCrossesLine(\n\tpoint,\n\tline,\n\tprevSegmentGoesDown,\n\tthisSegmentGoesDown\n) {\n\n\tconst { start, end } = line;\n\tconst px = point.x;\n\tconst py = point.y;\n\n\tconst sy = start.y;\n\tconst ey = end.y;\n\n\t// If the line segment is parallel to the horizonal ray, then it can never intersect\n\tif ( sy === ey ) return false;\n\n\t// If the point is above or below both ends of the line segment, then the ray can't intersect the segment\n\tif ( py > sy && py > ey ) return false;\n\tif ( py < sy && py < ey ) return false;\n\n\tconst sx = start.x;\n\tconst ex = end.x;\n\n\t// If the point is to the right of both ends of the line segment, then the ray cast to the right can't intersect the segment\n\tif ( px > sx && px > ex ) return false;\n\tif ( px < sx && px < ex ) {\n\n\t\t// If the ray hits just the \"peak\" formed by two adjacent segments, then it's not considered an intersection\n\t\t// This checks only the peak formed with the previous segment, assuming that this function will also be called for the next segment\n\t\tif ( py === sy && prevSegmentGoesDown !== thisSegmentGoesDown ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// The point is to the left of the line segment and vertically in between the two ends of the segment, so the ray must hit the segment\n\t\treturn true;\n\n\t}\n\n\t// The line segment is a vector (dx; dy)\n\tconst dx = ex - sx;\n\tconst dy = ey - sy;\n\t// Its clockwise perpendicular vector is (dy; -dx)\n\tconst perpx = dy;\n\tconst perpy = - dx;\n\n\t// The vector from the start of the segment to the point is (pdx; pdy)\n\tconst pdx = px - sx;\n\tconst pdy = py - sy;\n\n\t// The dot product is positive if angle from (pdx; pdy) to (perpx; perpy) is between -90 and 90 degrees\n\tconst dot = perpx * pdx + perpy * pdy;\n\n\tif ( Math.sign( dot ) !== Math.sign( perpx ) ) {\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n}\n","import * as THREE from \"three\";\nimport { CONTAINED, INTERSECTED, NOT_INTERSECTED } from \"../..\";\nimport { getConvexHull } from \"../utils/math/getConvexHull.js\";\nimport { lineCrossesLine } from \"../utils/math/lineCrossesLine.js\";\nimport {\n\tisPointInsidePolygon,\n} from \"../utils/math/pointRayCrossesSegments.js\";\n\n/**\n * Compute selected triangles:\n *\n * 1. Construct a list of screen space line segments that represent the shape drawn by the user.\n * 2. For every triangle in the geometry check if any part is within the shape. If it is then consider the triangle selected.\n *\n * @returns Array of triplets representing indices of vertices of selected triangles\n *\n * @see https://github.com/gkjohnson/three-mesh-bvh/issues/166#issuecomment-752194034\n */\nexport function computeSelectedTriangles( mesh, camera, selectionTool, params ) {\n\n\t// TODO: Possible improvements\n\t// - Correctly handle the camera near clip\n\t// - Improve line line intersect performance?\n\n\ttoScreenSpaceMatrix\n\t\t.copy( mesh.matrixWorld )\n\t\t.premultiply( camera.matrixWorldInverse )\n\t\t.premultiply( camera.projectionMatrix );\n\n\tinvWorldMatrix.copy( mesh.matrixWorld ).invert();\n\tcamLocalPosition\n\t\t.set( 0, 0, 0 )\n\t\t.applyMatrix4( camera.matrixWorld )\n\t\t.applyMatrix4( invWorldMatrix );\n\n\tconst lassoSegments = connectPointsWithLines(\n\t\tconvertTripletsToPoints( selectionTool.points )\n\t);\n\n\t/**\n\t * Per-depth cache of lasso segments that were filtered to be to the right of a box for that depth.\n\t * @type {Array<Array<THREE.Line3>>}\n\t */\n\tconst perBoundsSegmentCache = [];\n\n\t/**\n\t * Array of triplets representing indices of vertices of selected triangles.\n\t * @type {Array<number>}\n\t */\n\tconst indices = [];\n\n\t// find all the triangles in the mesh that intersect the lasso\n\tmesh.geometry.boundsTree.shapecast( {\n\t\tintersectsBounds: ( box, isLeaf, score, depth ) => {\n\n\t\t\t// check if the bounds are intersected or contained by the lasso region to narrow down on the triangles\n\n\t\t\tif ( ! params.useBoundsTree ) {\n\n\t\t\t\treturn INTERSECTED;\n\n\t\t\t}\n\n\t\t\tconst projectedBoxPoints = extractBoxVertices( box, boxPoints ).map( ( v ) =>\n\t\t\t\tv.applyMatrix4( toScreenSpaceMatrix )\n\t\t\t);\n\n\t\t\tlet minY = Infinity;\n\t\t\tlet maxY = - Infinity;\n\t\t\tlet minX = Infinity;\n\t\t\tfor ( const point of projectedBoxPoints ) {\n\n\t\t\t\tif ( point.y < minY ) minY = point.y;\n\t\t\t\tif ( point.y > maxY ) maxY = point.y;\n\t\t\t\tif ( point.x < minX ) minX = point.x;\n\n\t\t\t}\n\n\t\t\t// filter the lasso segments to remove the ones completely to the left, above, or below the bounding box.\n\t\t\t// we don't need the ones on the left because the point-in-polygon ray casting algorithm casts rays to the right.\n\t\t\t// cache the filtered segments in the above array for subsequent child checks to use.\n\t\t\tconst parentSegments = perBoundsSegmentCache[ depth - 1 ] || lassoSegments;\n\t\t\tconst segmentsToCheck = parentSegments.filter( ( segment ) =>\n\t\t\t\tisSegmentToTheRight( segment, minX, minY, maxY )\n\t\t\t);\n\t\t\tperBoundsSegmentCache[ depth ] = segmentsToCheck;\n\n\t\t\tif ( segmentsToCheck.length === 0 ) {\n\n\t\t\t\treturn NOT_INTERSECTED;\n\n\t\t\t}\n\n\t\t\tconst hull = getConvexHull( projectedBoxPoints );\n\t\t\tconst hullSegments = connectPointsWithLines( hull, boxLines );\n\n\t\t\t// If any lasso point is inside the hull (arbitrarily checking the first) then the bounds are intersected by the lasso.\n\t\t\tif ( isPointInsidePolygon( segmentsToCheck[ 0 ].start, hullSegments ) ) {\n\n\t\t\t\treturn INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// if any hull segment is intersected by any lasso segment then the bounds are intersected by the lasso\n\t\t\tfor ( const hullSegment of hullSegments ) {\n\n\t\t\t\tfor ( const selectionSegment of segmentsToCheck ) {\n\n\t\t\t\t\tif ( lineCrossesLine( hullSegment, selectionSegment ) ) {\n\n\t\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// No lasso segments intersected the bounds, and at least the first point is definitely outside the hull,\n\t\t\t// so either the entire hull is inside the lasso, or the lasso is somewhere different and does not touch the hull.\n\t\t\treturn isPointInsidePolygon( hull[ 0 ], segmentsToCheck ) ? CONTAINED : NOT_INTERSECTED;\n\n\t\t},\n\n\t\tintersectsTriangle: ( tri, index, contained, depth ) => {\n\n\t\t\t// if the box containing this triangle was intersected or contained, check if the triangle itself should be selected\n\n\t\t\tconst i3 = index * 3;\n\t\t\tconst a = i3 + 0;\n\t\t\tconst b = i3 + 1;\n\t\t\tconst c = i3 + 2;\n\n\t\t\t// check all the segments if using no bounds tree\n\t\t\tconst segmentsToCheck = params.useBoundsTree\n\t\t\t\t? perBoundsSegmentCache[ depth ]\n\t\t\t\t: lassoSegments;\n\t\t\tif (\n\t\t\t\tparams.selectionMode === \"centroid\" ||\n\t\t\t\tparams.selectionMode === \"centroid-visible\"\n\t\t\t) {\n\n\t\t\t\t// get the center of the triangle\n\t\t\t\tcentroid\n\t\t\t\t\t.copy( tri.a )\n\t\t\t\t\t.add( tri.b )\n\t\t\t\t\t.add( tri.c )\n\t\t\t\t\t.multiplyScalar( 1 / 3 );\n\t\t\t\tscreenCentroid.copy( centroid ).applyMatrix4( toScreenSpaceMatrix );\n\n\t\t\t\tif (\n\t\t\t\t\tcontained ||\n\t\t\t\t\tisPointInsidePolygon( screenCentroid, segmentsToCheck )\n\t\t\t\t) {\n\n\t\t\t\t\t// if we're only selecting visible faces then perform a ray check to ensure the centroid\n\t\t\t\t\t// is visible.\n\t\t\t\t\tif ( params.selectionMode === \"centroid-visible\" ) {\n\n\t\t\t\t\t\ttri.getNormal( faceNormal );\n\t\t\t\t\t\ttempRay.origin.copy( centroid ).addScaledVector( faceNormal, 1e-6 );\n\t\t\t\t\t\ttempRay.direction.subVectors( camLocalPosition, centroid );\n\n\t\t\t\t\t\tconst res = mesh.geometry.boundsTree.raycastFirst(\n\t\t\t\t\t\t\ttempRay,\n\t\t\t\t\t\t\tTHREE.DoubleSide\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif ( res ) {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\treturn params.selectWholeModel;\n\n\t\t\t\t}\n\n\t\t\t} else if ( params.selectionMode === \"intersection\" ) {\n\n\t\t\t\t// if the parent bounds were marked as contained then we contain all the triangles within\n\t\t\t\tif ( contained ) {\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\treturn params.selectWholeModel;\n\n\t\t\t\t}\n\n\t\t\t\t// check if any of the projected vertices are inside the selection and if so then the triangle is selected\n\t\t\t\tconst projectedTriangle = [ tri.a, tri.b, tri.c ].map( ( v ) =>\n\t\t\t\t\tv.applyMatrix4( toScreenSpaceMatrix )\n\t\t\t\t);\n\t\t\t\tfor ( const point of projectedTriangle ) {\n\n\t\t\t\t\tif ( isPointInsidePolygon( point, segmentsToCheck ) ) {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\treturn params.selectWholeModel;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// check for the case where a selection intersects a triangle but does not contain any\n\t\t\t\t// of the vertices\n\t\t\t\tconst triangleSegments = connectPointsWithLines(\n\t\t\t\t\tprojectedTriangle,\n\t\t\t\t\tboxLines\n\t\t\t\t);\n\t\t\t\tfor ( const segment of triangleSegments ) {\n\n\t\t\t\t\tfor ( const selectionSegment of segmentsToCheck ) {\n\n\t\t\t\t\t\tif ( lineCrossesLine( segment, selectionSegment ) ) {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\treturn params.selectWholeModel;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\t} );\n\n\treturn indices;\n\n}\n\nconst invWorldMatrix = new THREE.Matrix4();\nconst camLocalPosition = new THREE.Vector3();\nconst tempRay = new THREE.Ray();\nconst centroid = new THREE.Vector3();\nconst screenCentroid = new THREE.Vector3();\nconst faceNormal = new THREE.Vector3();\nconst toScreenSpaceMatrix = new THREE.Matrix4();\nconst boxPoints = new Array( 8 ).fill().map( () => new THREE.Vector3() );\nconst boxLines = new Array( 12 ).fill().map( () => new THREE.Line3() );\n\n/**\n * Produce a list of 3D points representing vertices of the box.\n *\n * @param {THREE.Box3} box\n * @param {Array<THREE.Vector3>} target Array of 8 vectors to write to\n * @returns {Array<THREE.Vector3>}\n */\nfunction extractBoxVertices( box, target ) {\n\n\tconst { min, max } = box;\n\tlet index = 0;\n\n\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\tconst v = target[ index ];\n\t\t\t\tv.x = x === 0 ? min.x : max.x;\n\t\t\t\tv.y = y === 0 ? min.y : max.y;\n\t\t\t\tv.z = z === 0 ? min.z : max.z;\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn target;\n\n}\n\n/**\n * Determine if a line segment is to the right of a box.\n *\n * @param {THREE.Line3} segment\n * @param {number} minX The leftmost X coordinate of the box\n * @param {number} minY The bottommost Y coordinate of the box\n * @param {number} maxY The topmost Y coordinate of the box\n * @returns {boolean}\n */\nfunction isSegmentToTheRight( segment, minX, minY, maxY ) {\n\n\tconst sx = segment.start.x;\n\tconst sy = segment.start.y;\n\tconst ex = segment.end.x;\n\tconst ey = segment.end.y;\n\n\tif ( sx < minX && ex < minX ) return false;\n\tif ( sy > maxY && ey > maxY ) return false;\n\tif ( sy < minY && ey < minY ) return false;\n\n\treturn true;\n\n}\n\n/**\n * Given a list of points representing a polygon, produce a list of line segments of that polygon.\n *\n * @param {Array<THREE.Vector3>} points\n * @param {Array<THREE.Line3> | null} target Array of the same length as `points` of lines to write to\n * @returns {Array<THREE.Line3>}\n */\nfunction connectPointsWithLines( points, target = null ) {\n\n\tif ( target === null ) {\n\n\t\ttarget = new Array( points.length ).fill( null ).map( () => new THREE.Line3() );\n\n\t}\n\n\treturn points.map( ( p, i ) => {\n\n\t\tconst nextP = points[ ( i + 1 ) % points.length ];\n\t\tconst line = target[ i ];\n\t\tline.start.copy( p );\n\t\tline.end.copy( nextP );\n\t\treturn line;\n\n\t} );\n\n}\n\n/**\n * Convert a list of triplets representing coordinates into a list of 3D points.\n * @param {Array<number>} array Array of points in the form [x0, y0, z0, x1, y1, z1, â€¦]\n * @returns {Array<THREE.Vector3>}\n */\nfunction convertTripletsToPoints( array ) {\n\n\tconst points = [];\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tpoints.push( new THREE.Vector3( array[ i ], array[ i + 1 ], array[ i + 2 ] ) );\n\n\t}\n\n\treturn points;\n\n}\n","import * as THREE from 'three';\nimport Stats from 'stats.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { BVHHelper, MeshBVH } from 'three-mesh-bvh';\nimport { LassoSelection, BoxSelection } from './src/Selection.js';\nimport { computeSelectedTriangles } from './src/computeSelectedTriangles.js';\n\nconst params = {\n\ttoolMode: 'lasso',\n\tselectionMode: 'intersection',\n\tliveUpdate: false,\n\tselectWholeModel: false,\n\twireframe: false,\n\tuseBoundsTree: true,\n\tdisplayBVH: false,\n\tdisplayDepth: 10,\n\trotate: true,\n};\n\nlet renderer, camera, scene, stats, controls, selectionShape, mesh, bvhHelper;\nlet highlightMesh, highlightWireframeMesh, outputContainer, group;\nlet selectionShapeNeedsUpdate = false;\nlet selectionNeedsUpdate = false;\nlet tool = new LassoSelection();\n\ninit();\n\nfunction init() {\n\n\tconst bgColor = 0x263238;\n\n\toutputContainer = document.getElementById( 'output' );\n\n\t// Renderer\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.setAnimationLoop( render );\n\trenderer.shadowMap.enabled = true;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// Scene\n\tscene = new THREE.Scene();\n\n\t// Lights\n\tconst light = new THREE.DirectionalLight( 0xffffff, 3 );\n\tlight.castShadow = true;\n\tlight.shadow.mapSize.set( 2048, 2048 );\n\tlight.position.set( 10, 10, 10 );\n\n\tscene.add(\n\t\tlight,\n\t\tnew THREE.AmbientLight( 0xb0bec5, 2.5 )\n\t);\n\n\t// Camera\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );\n\tcamera.position.set( 2, 4, 6 );\n\tscene.add( camera );\n\n\t// Selection shape\n\tselectionShape = new THREE.Line();\n\tselectionShape.material.color.set( 0xff9800 );\n\tselectionShape.renderOrder = 1;\n\tselectionShape.position.z = - 0.2;\n\tselectionShape.depthTest = false;\n\tselectionShape.scale.setScalar( 1 );\n\tcamera.add( selectionShape );\n\n\t// Group for rotation\n\tgroup = new THREE.Group();\n\tscene.add( group );\n\n\t// Base mesh\n\tmesh = new THREE.Mesh(\n\t\tnew THREE.TorusKnotGeometry( 1.5, 0.5, 500, 60 ).toNonIndexed(),\n\t\tnew THREE.MeshStandardMaterial( {\n\t\t\tpolygonOffset: true,\n\t\t\tpolygonOffsetFactor: 1,\n\t\t} )\n\t);\n\tmesh.geometry.boundsTree = new MeshBVH( mesh.geometry );\n\tmesh.geometry.setAttribute( 'color', new THREE.Uint8BufferAttribute(\n\t\tnew Array( mesh.geometry.index.count * 3 ).fill( 255 ), 3, true\n\t) );\n\tmesh.castShadow = mesh.receiveShadow = true;\n\tgroup.add( mesh );\n\n\tbvhHelper = new BVHHelper( mesh, 10 );\n\tgroup.add( bvhHelper );\n\n\t// Selection highlight meshes\n\thighlightMesh = new THREE.Mesh();\n\thighlightMesh.geometry = mesh.geometry.clone();\n\thighlightMesh.geometry.drawRange.count = 0;\n\thighlightMesh.material = new THREE.MeshBasicMaterial( {\n\t\topacity: 0.05,\n\t\ttransparent: true,\n\t\tdepthWrite: false,\n\t\tcolor: 0xff9800,\n\t} );\n\thighlightMesh.renderOrder = 1;\n\tgroup.add( highlightMesh );\n\n\thighlightWireframeMesh = new THREE.Mesh();\n\thighlightWireframeMesh.geometry = highlightMesh.geometry;\n\thighlightWireframeMesh.material = new THREE.MeshBasicMaterial( {\n\t\topacity: 0.25,\n\t\ttransparent: true,\n\t\twireframe: true,\n\t\tdepthWrite: false,\n\t\tcolor: 0xff9800,\n\t} );\n\thighlightWireframeMesh.renderOrder = 2;\n\tgroup.add( highlightWireframeMesh );\n\n\t// Floor\n\tconst gridHelper = new THREE.GridHelper( 10, 10, 0xffffff, 0xffffff );\n\tgridHelper.material.opacity = 0.2;\n\tgridHelper.material.transparent = true;\n\tgridHelper.position.y = - 2.75;\n\tscene.add( gridHelper );\n\n\tconst shadowPlane = new THREE.Mesh(\n\t\tnew THREE.PlaneGeometry(),\n\t\tnew THREE.ShadowMaterial( { color: 0, opacity: 0.2, depthWrite: false } )\n\t);\n\tshadowPlane.position.y = - 2.74;\n\tshadowPlane.rotation.x = - Math.PI / 2;\n\tshadowPlane.scale.setScalar( 20 );\n\tshadowPlane.renderOrder = 2;\n\tshadowPlane.receiveShadow = true;\n\tscene.add( shadowPlane );\n\n\t// Stats\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// Controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.minDistance = 3;\n\tcontrols.touches.ONE = THREE.TOUCH.PAN;\n\tcontrols.mouseButtons.LEFT = THREE.MOUSE.PAN;\n\tcontrols.touches.TWO = THREE.TOUCH.ROTATE;\n\tcontrols.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;\n\tcontrols.enablePan = false;\n\n\t// GUI\n\tconst gui = new GUI();\n\tconst selectionFolder = gui.addFolder( 'Selection' );\n\tselectionFolder.add( params, 'toolMode', [ 'lasso', 'box' ] ).onChange( v => {\n\n\t\ttool = v === 'box' ? new BoxSelection() : new LassoSelection();\n\n\t} );\n\tselectionFolder.add( params, 'selectionMode', [ 'centroid', 'centroid-visible', 'intersection' ] );\n\tselectionFolder.add( params, 'selectWholeModel' );\n\tselectionFolder.add( params, 'liveUpdate' );\n\tselectionFolder.add( params, 'useBoundsTree' );\n\tselectionFolder.open();\n\n\tconst displayFolder = gui.addFolder( 'Display' );\n\tdisplayFolder.add( params, 'wireframe' );\n\tdisplayFolder.add( params, 'rotate' );\n\tdisplayFolder.add( params, 'displayBVH' );\n\tdisplayFolder.add( params, 'displayDepth', 1, 30, 1 ).onChange( v => {\n\n\t\tbvhHelper.depth = v;\n\t\tbvhHelper.update();\n\n\t} );\n\tdisplayFolder.open();\n\tgui.open();\n\n\t// Event listeners\n\trenderer.domElement.addEventListener( 'pointerdown', e => {\n\n\t\ttool.handlePointerDown( e );\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerup', () => {\n\n\t\ttool.handlePointerUp();\n\t\tselectionShape.visible = false;\n\t\tif ( tool.points.length ) selectionNeedsUpdate = true;\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointermove', e => {\n\n\t\t// If the left mouse button is not pressed\n\t\tif ( ( 1 & e.buttons ) === 0 ) return;\n\n\t\tconst { changed } = tool.handlePointerMove( e );\n\n\t\tif ( changed ) {\n\n\t\t\tselectionShapeNeedsUpdate = true;\n\t\t\tselectionShape.visible = true;\n\t\t\tif ( params.liveUpdate ) selectionNeedsUpdate = true;\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'resize', () => {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t} );\n\n}\n\nfunction render() {\n\n\tstats.update();\n\n\tmesh.material.wireframe = params.wireframe;\n\tbvhHelper.visible = params.displayBVH;\n\n\tconst selectionPoints = tool.points;\n\n\t// Update the selection lasso lines\n\tif ( selectionShapeNeedsUpdate ) {\n\n\t\tselectionShape.geometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew THREE.Float32BufferAttribute(\n\t\t\t\tselectionPoints.concat( selectionPoints.slice( 0, 3 ) ),\n\t\t\t\t3,\n\t\t\t\tfalse\n\t\t\t)\n\t\t);\n\n\t\tselectionShape.frustumCulled = false;\n\t\tselectionShapeNeedsUpdate = false;\n\n\t}\n\n\tif ( selectionNeedsUpdate ) {\n\n\t\tselectionNeedsUpdate = false;\n\n\t\tif ( selectionPoints.length > 0 ) updateSelection();\n\n\t}\n\n\tconst yScale = Math.tan( THREE.MathUtils.DEG2RAD * camera.fov / 2 ) * selectionShape.position.z;\n\tselectionShape.scale.set( - yScale * camera.aspect, - yScale, 1 );\n\n\trenderer.render( scene, camera );\n\n\tif ( params.rotate ) {\n\n\t\tgroup.rotation.y += 0.01;\n\t\tif ( params.liveUpdate && tool.dragging ) selectionNeedsUpdate = true;\n\n\t}\n\n}\n\nfunction updateSelection() {\n\n\tconst startTime = window.performance.now();\n\tconst indices = computeSelectedTriangles( mesh, camera, tool, params );\n\n\tconst traverseTime = window.performance.now() - startTime;\n\toutputContainer.innerText = `${ traverseTime.toFixed( 3 ) }ms`;\n\n\tconst indexAttr = mesh.geometry.index;\n\tconst newIndexAttr = highlightMesh.geometry.index;\n\n\tif ( indices.length && params.selectWholeModel ) {\n\n\t\t// Select the whole model\n\t\tfor ( let i = 0, l = indexAttr.count; i < l; i ++ ) {\n\n\t\t\tconst i2 = indexAttr.getX( i );\n\t\t\tnewIndexAttr.setX( i, i2 );\n\n\t\t}\n\n\t\thighlightMesh.geometry.drawRange.count = Infinity;\n\t\tnewIndexAttr.needsUpdate = true;\n\n\t} else {\n\n\t\t// Update highlight mesh with selected triangles\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tconst i2 = indexAttr.getX( indices[ i ] );\n\t\t\tnewIndexAttr.setX( i, i2 );\n\n\t\t}\n\n\t\thighlightMesh.geometry.drawRange.count = indices.length;\n\t\tnewIndexAttr.needsUpdate = true;\n\n\t}\n\n}\n"],"names":["Selection","element","x","y","clientRect","correctedX","correctedY","tempVec0","THREE.Vector2","tempVec1","tempVec2","LassoSelection","ex","ey","nx","ny","i3","doReplace","BoxSelection","getConvexHull","points","orientation","p","q","r","val","distSq","p1","p2","compare","o","p0","lowestY","lowestIndex","i","l","m","n","hull","lineCrossesLine","l1","l2","ccw","A","B","C","D","isPointInsidePolygon","point","polygon","pointRayCrossesSegments","segments","crossings","firstSeg","prevSegmentGoesDown","s","line","thisSegmentGoesDown","pointRayCrossesLine","start","end","px","py","sy","sx","dx","perpx","perpy","pdx","pdy","dot","computeSelectedTriangles","mesh","camera","selectionTool","params","toScreenSpaceMatrix","invWorldMatrix","camLocalPosition","lassoSegments","connectPointsWithLines","convertTripletsToPoints","perBoundsSegmentCache","indices","box","isLeaf","score","depth","INTERSECTED","projectedBoxPoints","extractBoxVertices","boxPoints","v","minY","maxY","minX","segmentsToCheck","segment","isSegmentToTheRight","NOT_INTERSECTED","hullSegments","boxLines","hullSegment","selectionSegment","CONTAINED","tri","index","contained","a","b","c","centroid","screenCentroid","faceNormal","tempRay","THREE.DoubleSide","projectedTriangle","triangleSegments","THREE.Matrix4","THREE.Vector3","THREE.Ray","THREE.Line3","target","min","max","z","nextP","array","renderer","scene","stats","controls","selectionShape","bvhHelper","highlightMesh","highlightWireframeMesh","outputContainer","group","selectionShapeNeedsUpdate","selectionNeedsUpdate","tool","init","THREE.WebGLRenderer","render","THREE.Scene","light","THREE.DirectionalLight","THREE.AmbientLight","THREE.PerspectiveCamera","THREE.Line","THREE.Group","THREE.Mesh","THREE.TorusKnotGeometry","THREE.MeshStandardMaterial","MeshBVH","THREE.Uint8BufferAttribute","BVHHelper","THREE.MeshBasicMaterial","gridHelper","THREE.GridHelper","shadowPlane","THREE.PlaneGeometry","THREE.ShadowMaterial","Stats","OrbitControls","THREE.TOUCH","THREE.MOUSE","gui","GUI","selectionFolder","displayFolder","e","changed","selectionPoints","THREE.Float32BufferAttribute","updateSelection","yScale","THREE.MathUtils","startTime","traverseTime","indexAttr","newIndexAttr","i2"],"mappings":"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"}