{"version":3,"file":"diamond-C4uXC4je.js","sources":["../../../node_modules/three/examples/jsm/loaders/RGBELoader.js","../../diamond.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the RGBE HDR texture format.\n *\n * ```js\n * const loader = new RGBELoader();\n * const envMap = await loader.loadAsync( 'textures/equirectangular/blouberg_sunrise_2_1k.hdr' );\n * envMap.mapping = THREE.EquirectangularReflectionMapping;\n *\n * scene.environment = envMap;\n * ```\n *\n * @augments DataTextureLoader\n * @three_import import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';\n */\nclass RGBELoader extends DataTextureLoader {\n\n\t/**\n\t * Constructs a new RGBE loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * The texture type.\n\t\t *\n\t\t * @type {(HalfFloatType|FloatType)}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t/**\n\t * Parses the given RGBE texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @return {DataTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer ) {\n\n\t\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets the texture type.\n\t *\n\t * @param {(HalfFloatType|FloatType)} value - The texture type to set.\n\t * @return {RGBELoader} A reference to this loader.\n\t */\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","import * as THREE from 'three';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\nimport {\n\tMeshBVH,\n\tMeshBVHUniformStruct,\n\tBVHShaderGLSL,\n\tSAH\n} from 'three-mesh-bvh';\n\nlet scene, camera, renderer, environment, controls, diamond, gui, stats, clock;\n\nconst params = {\n\n\tcolor: '#ffffff',\n\tbounces: 3.0,\n\tior: 2.4,\n\taberrationStrength: 0.01,\n\tfastChroma: false,\n\tanimate: true,\n\n};\n\ninit();\n\nasync function init() {\n\n\t// renderer, scene, camera setup\n\tscene = new THREE.Scene();\n\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\tcamera.position.set( 28, 15, 7 );\n\n\t// NOTE: antialiasing is disabled because the interpolation at face edges results in numeric issues\n\t// causing the raycast to intersect the front faces. An adjusted bvh cast function that affords filtering by\n\t// front / back faces would help this.\n\trenderer = new THREE.WebGLRenderer( { antialias: false } );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.toneMapping = THREE.ACESFilmicToneMapping;\n\trenderer.setAnimationLoop( render );\n\tdocument.body.appendChild( renderer.domElement );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\tclock = new THREE.Clock();\n\n\t// load the environment and model\n\tconst environmentPromise = new RGBELoader()\n\t\t.loadAsync( 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr' );\n\n\tconst gltfPromise = new GLTFLoader().loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/diamond/diamond.glb' );\n\n\tlet gltf;\n\t[ environment, gltf ] = await Promise.all( [ environmentPromise, gltfPromise ] );\n\n\t// initialize the background\n\tenvironment.mapping = THREE.EquirectangularReflectionMapping;\n\tenvironment.generateMipmaps = true;\n\tenvironment.minFilter = THREE.LinearMipmapLinearFilter;\n\tenvironment.magFilter = THREE.LinearFilter;\n\tscene.background = environment;\n\n\t// initialize the diamond material\n\tconst diamondMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: {\n\n\t\t\t// scene / geometry information\n\t\t\tenvMap: { value: environment },\n\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\tprojectionMatrixInv: { value: camera.projectionMatrixInverse },\n\t\t\tviewMatrixInv: { value: camera.matrixWorld },\n\t\t\tresolution: { value: new THREE.Vector2() },\n\n\t\t\t// internal reflection settings\n\t\t\tbounces: { value: 3 },\n\t\t\tior: { value: 2.4 },\n\n\t\t\t// chroma and color settings\n\t\t\tcolor: { value: new THREE.Color( 1, 1, 1 ) },\n\t\t\tfastChroma: { value: false },\n\t\t\taberrationStrength: { value: 0.01 },\n\n\t\t},\n\t\tvertexShader: /*glsl*/ `\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldPosition = ( modelMatrix * vec4( position, 1.0 ) ).xyz;\n\t\t\t\tvNormal = ( viewMatrixInv * vec4( normalMatrix * normal, 0.0 ) ).xyz;\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position , 1.0 );\n\n\t\t\t}\n\t\t`,\n\t\tfragmentShader: /*glsl*/ `\n\t\t\t#define RAY_OFFSET 0.001\n\n\t\t\t#include <common>\n\t\t\tprecision highp isampler2D;\n\t\t\tprecision highp usampler2D;\n\n\t\t\t${ BVHShaderGLSL.common_functions }\n\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\n\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\n\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float bounces;\n\t\t\tuniform BVH bvh;\n\t\t\tuniform float ior;\n\t\t\tuniform vec3 color;\n\t\t\tuniform bool fastChroma;\n\t\t\tuniform mat4 projectionMatrixInv;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tuniform mat4 modelMatrix;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform float aberrationStrength;\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t// performs an iterative bounce lookup modeling internal reflection and returns\n\t\t\t// a final ray direction.\n\t\t\tvec3 totalInternalReflection( vec3 incomingOrigin, vec3 incomingDirection, vec3 normal, float ior, mat4 modelMatrixInverse ) {\n\n\t\t\t\tvec3 rayOrigin = incomingOrigin;\n\t\t\t\tvec3 rayDirection = incomingDirection;\n\n\t\t\t\t// refract the ray direction on the way into the diamond and adjust offset from\n\t\t\t\t// the diamond surface for raytracing\n\t\t\t\trayDirection = refract( rayDirection, normal, 1.0 / ior );\n\t\t\t\trayOrigin = vWorldPosition + rayDirection * RAY_OFFSET;\n\n\t\t\t\t// transform the ray into the local coordinates of the model\n\t\t\t\trayOrigin = ( modelMatrixInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\trayDirection = normalize( ( modelMatrixInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t// perform multiple ray casts\n\t\t\t\tfor( float i = 0.0; i < bounces; i ++ ) {\n\n\t\t\t\t\t// results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// perform the raycast\n\t\t\t\t\t// the diamond is a water tight model so we assume we always hit a surface\n\t\t\t\t\tbvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t// derive the new ray origin from the hit results\n\t\t\t\t\tvec3 hitPos = rayOrigin + rayDirection * dist;\n\n\t\t\t\t\t// if we don't internally reflect then end the ray tracing and sample\n\t\t\t\t\tvec3 refractedDirection = refract( rayDirection, faceNormal, ior );\n\t\t\t\t\tbool totalInternalReflection = length( refract( rayDirection, faceNormal, ior ) ) == 0.0;\n\t\t\t\t\tif ( ! totalInternalReflection ) {\n\n\t\t\t\t\t\trayDirection = refractedDirection;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise reflect off the surface internally for another hit\n\t\t\t\t\trayDirection = reflect( rayDirection, faceNormal );\n\t\t\t\t\trayOrigin = hitPos + rayDirection * RAY_OFFSET;\n\n\t\t\t\t}\n\n\t\t\t\t// return the final ray direction in world space\n\t\t\t\treturn normalize( ( modelMatrix * vec4( rayDirection, 0.0 ) ).xyz );\n\t\t\t}\n\n\t\t\tvec4 envSample( sampler2D envMap, vec3 rayDirection ) {\n\n\t\t\t\tvec2 uvv = equirectUv( rayDirection );\n\t\t\t\treturn texture( envMap, uvv );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tmat4 modelMatrixInverse = inverse( modelMatrix );\n\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution;\n\n\t\t\t\tvec3 normal = vNormal;\n\t\t\t\tvec3 rayOrigin = cameraPosition;\n\t\t\t\tvec3 rayDirection = normalize( vWorldPosition - cameraPosition );\n\n\t\t\t\tif ( aberrationStrength != 0.0 ) {\n\n\t\t\t\t\t// perform chromatic aberration lookups\n\t\t\t\t\tvec3 rayDirectionG = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tvec3 rayDirectionR, rayDirectionB;\n\n\t\t\t\t\tif ( fastChroma ) {\n\n\t\t\t\t\t\t// fast chroma does a quick uv offset on lookup\n\t\t\t\t\t\trayDirectionR = normalize( rayDirectionG + 1.0 * vec3( aberrationStrength / 2.0 ) );\n\t\t\t\t\t\trayDirectionB = normalize( rayDirectionG - 1.0 * vec3( aberrationStrength / 2.0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// compared to a proper ray trace of diffracted rays\n\t\t\t\t\t\tfloat iorR = max( ior * ( 1.0 - aberrationStrength ), 1.0 );\n\t\t\t\t\t\tfloat iorB = max( ior * ( 1.0 + aberrationStrength ), 1.0 );\n\t\t\t\t\t\trayDirectionR = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorR, modelMatrixInverse\n\t\t\t\t\t\t);\n\t\t\t\t\t\trayDirectionB = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorB, modelMatrixInverse\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// get the color lookup\n\t\t\t\t\tfloat r = envSample( envMap, rayDirectionR ).r;\n\t\t\t\t\tfloat g = envSample( envMap, rayDirectionG ).g;\n\t\t\t\t\tfloat b = envSample( envMap, rayDirectionB ).b;\n\t\t\t\t\tgl_FragColor.rgb = vec3( r, g, b ) * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// no chromatic aberration lookups\n\t\t\t\t\trayDirection = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tgl_FragColor.rgb = envSample( envMap, rayDirection ).rgb * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t}\n\t\t`\n\t} );\n\n\t// initialize the diamond geometry and material uniforms\n\tconst diamondGeo = gltf.scene.children[ 0 ].children[ 0 ].children[ 0 ].children[ 0 ].children[ 0 ].geometry;\n\tdiamondGeo.scale( 10, 10, 10 );\n\n\tconst bvh = new MeshBVH( diamondGeo, { strategy: SAH, maxLeafSize: 1 } );\n\tdiamondMaterial.uniforms.bvh.value.updateFrom( bvh );\n\tdiamond = new THREE.Mesh( diamondGeo, diamondMaterial );\n\tscene.add( diamond );\n\n\t// gui setup\n\tgui = new GUI();\n\tgui.add( params, 'animate' );\n\tgui.addColor( params, 'color' ).name( 'Color' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.color.value.set( v );\n\n\t} );\n\tgui.add( params, 'bounces', 1.0, 10.0, 1.0 ).name( 'Bounces' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.bounces.value = v;\n\n\t} );\n\tgui.add( params, 'ior', 1.0, 5.0, 0.01 ).name( 'IOR' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.ior.value = v;\n\n\t} );\n\tgui.add( params, 'fastChroma' ).onChange( v => {\n\n\t\tdiamond.material.uniforms.fastChroma.value = v;\n\n\t} );\n\tgui.add( params, 'aberrationStrength', 0.0, 0.1, 0.0001 ).onChange( v => {\n\n\t\tdiamond.material.uniforms.aberrationStrength.value = v;\n\n\t} );\n\n\tstats = new Stats();\n\tstats.showPanel( 0 );\n\tdocument.body.appendChild( stats.dom );\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\t\tdiamond.material.uniforms.resolution.value.set( window.innerWidth, window.innerHeight );\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\nfunction render() {\n\n\tif ( ! diamond ) {\n\n\t\treturn;\n\n\t}\n\n\tif ( params.animate ) {\n\n\t\tdiamond.rotation.y += clock.getDelta() * 0.25;\n\n\t}\n\n\tstats.update();\n\tcontrols.update();\n\trenderer.render( scene, camera );\n\n}\n"],"names":["RGBELoader","DataTextureLoader","manager","HalfFloatType","buffer","rgbe_error","rgbe_error_code","msg","fgets","lineLimit","consume","p","i","len","chunk","RGBE_ReadHeader","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","header","line","match","RGBE_ReadPixels_RLE","w","h","scanline_width","data_rgba","offset","pos","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","l","off","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","RGBEByteToRGBHalf","DataUtils","byteArray","rgbe_header_info","image_rgba_data","data","type","numElements","FloatType","floatArray","j","halfArray","value","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","LinearSRGBColorSpace","LinearFilter","scene","camera","renderer","environment","controls","diamond","gui","stats","clock","params","init","THREE.Scene","THREE.PerspectiveCamera","THREE.WebGLRenderer","THREE.ACESFilmicToneMapping","render","OrbitControls","THREE.Clock","environmentPromise","gltfPromise","GLTFLoader","gltf","THREE.EquirectangularReflectionMapping","THREE.LinearMipmapLinearFilter","THREE.LinearFilter","diamondMaterial","THREE.ShaderMaterial","MeshBVHUniformStruct","THREE.Vector2","THREE.Color","BVHShaderGLSL.common_functions","BVHShaderGLSL.bvh_struct_definitions","BVHShaderGLSL.bvh_ray_functions","diamondGeo","bvh","MeshBVH","SAH","THREE.Mesh","GUI","v","Stats"],"mappings":"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","x_google_ignoreList":[0]}