{"version":3,"file":"sdfGeneration-CpOM49Ea.js","sources":["../../../src/webgl/glsl/bvh_distance_functions.glsl.js","../../utils/GenerateSDFMaterial.js","../../utils/RenderSDFLayerMaterial.js","../../utils/RayMarchSDFMaterial.js","../../sdfGeneration.js"],"sourcesContent":["// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0 - v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point, float maxDistance,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint pointer = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = maxDistance * maxDistance;\n\tbool found = false;\n\twhile ( pointer > - 1 && pointer < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ pointer ];\n\t\tpointer --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = currNodeIndex + boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tpointer ++;\n\t\t\tstack[ pointer ] = c2;\n\t\t\tpointer ++;\n\t\t\tstack[ pointer ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n","import { ShaderMaterial, Matrix4 } from 'three';\nimport { BVHShaderGLSL, MeshBVHUniformStruct } from '../..';\n\nexport class GenerateSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SHADER_RAYCAST: window.location.hash.includes( 'USE_SHADER_RAYCAST' ) ? 1 : 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tmatrix: { value: new Matrix4() },\n\t\t\t\tzValue: { value: 0 },\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t${ BVHShaderGLSL.common_functions }\n\t\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\n\t\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\n\t\t\t\t${ BVHShaderGLSL.bvh_distance_functions }\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float zValue;\n\t\t\t\tuniform mat4 matrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( vUv, zValue );\n\t\t\t\t\tpoint -= vec3( 0.5 );\n\t\t\t\t\tpoint = ( matrix * vec4( point, 1.0 ) ).xyz;\n\n\t\t\t\t\t// retrieve the distance and other values\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tfloat rayDist;\n\t\t\t\t\tvec3 outPoint;\n\t\t\t\t\tfloat dist = bvhClosestPointToPoint( bvh, point.xyz, 100000.0, faceIndices, faceNormal, barycoord, side, outPoint );\n\n\t\t\t\t\t// This currently causes issues on some devices when rendering to 3d textures and texture arrays\n\t\t\t\t\t#if USE_SHADER_RAYCAST\n\n\t\t\t\t\tside = 1.0;\n\t\t\t\t\tbvhIntersectFirstHit( bvh, point.xyz, vec3( 0.0, 0.0, 1.0 ), faceIndices, faceNormal, barycoord, side, rayDist );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side * dist, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\nexport class RenderSDFLayerMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tDISPLAY_GRID: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tlayer: { value: 0 },\n\t\t\t\tlayers: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform float layer;\n\t\t\t\tuniform float layers;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#if DISPLAY_GRID\n\n\t\t\t\t\tfloat dim = ceil( sqrt( layers ) );\n\t\t\t\t\tvec2 cell = floor( vUv * dim );\n\t\t\t\t\tvec2 frac = vUv * dim - cell;\n\t\t\t\t\tfloat zLayer = ( cell.y * dim + cell.x ) / ( dim * dim );\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( frac, zLayer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( vUv, layer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial, Matrix4, Vector3 } from 'three';\n\nexport class RayMarchSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tMAX_STEPS: 500,\n\t\t\t\tSURFACE_EPSILON: 0.001,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsurface: { value: 0 },\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tnormalStep: { value: new Vector3() },\n\t\t\t\tprojectionInverse: { value: new Matrix4() },\n\t\t\t\tsdfTransformInverse: { value: new Matrix4() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\n\t\t\t\t#include <common>\n\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\tfloat distanceToSurface = texture( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\n\t\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * abs( distanceToSurface );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the surface normal\n\t\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\t\t// compute the surface normal\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t\tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\n\t\t\t\t\t\t\t// compute some basic lighting effects\n\t\t\t\t\t\t\tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t\tfloat lightIntensity =\n\t\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t\t0.1;\n\t\t\t\t\t\t\tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <colorspace_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'stats.js';\nimport { GenerateMeshBVHWorker } from 'three-mesh-bvh/worker';\nimport { StaticGeometryGenerator } from 'three-mesh-bvh';\nimport { GenerateSDFMaterial } from './utils/GenerateSDFMaterial.js';\nimport { RenderSDFLayerMaterial } from './utils/RenderSDFLayerMaterial.js';\nimport { RayMarchSDFMaterial } from './utils/RayMarchSDFMaterial.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\n\nconst params = {\n\n\tgpuGeneration: true,\n\tresolution: 75,\n\tmargin: 0.2,\n\tregenerate: () => updateSDF(),\n\n\tmode: 'raymarching',\n\tlayer: 0,\n\tsurface: 0.1,\n\n};\n\nlet renderer, camera, scene, gui, stats, boxHelper;\nlet outputContainer, bvh, geometry, sdfTex, mesh;\nlet generateSdfPass, layerPass, raymarchPass;\nlet bvhGenerationWorker;\nconst inverseBoundsMatrix = new THREE.Matrix4();\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 0 );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 1, 1, 2 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tboxHelper = new THREE.Box3Helper( new THREE.Box3() );\n\tscene.add( boxHelper );\n\n\tnew OrbitControls( camera, renderer.domElement );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// sdf pass to generate the 3d texture\n\tgenerateSdfPass = new FullScreenQuad( new GenerateSDFMaterial() );\n\n\t// screen pass to render a single layer of the 3d texture\n\tlayerPass = new FullScreenQuad( new RenderSDFLayerMaterial() );\n\n\t// screen pass to render the sdf ray marching\n\traymarchPass = new FullScreenQuad( new RayMarchSDFMaterial() );\n\n\t// load model and generate bvh\n\tbvhGenerationWorker = new GenerateMeshBVHWorker();\n\n\tnew GLTFLoader()\n\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t.loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb' )\n\t\t.then( gltf => {\n\n\t\t\tgltf.scene.updateMatrixWorld( true );\n\n\t\t\tconst staticGen = new StaticGeometryGenerator( gltf.scene );\n\t\t\tstaticGen.attributes = [ 'position', 'normal' ];\n\t\t\tstaticGen.useGroups = false;\n\n\t\t\tgeometry = staticGen.generate().center();\n\n\t\t\treturn bvhGenerationWorker.generate( geometry, { maxLeafSize: 1 } );\n\n\t\t} )\n\t\t.then( result => {\n\n\t\t\tbvh = result;\n\n\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\t\tscene.add( mesh );\n\n\t\t\tupdateSDF();\n\n\t\t} );\n\n\trebuildGUI();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\n// build the gui with parameters based on the selected display mode\nfunction rebuildGUI() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tparams.layer = Math.min( params.resolution, params.layer );\n\n\tgui = new GUI();\n\n\tconst generationFolder = gui.addFolder( 'generation' );\n\tgenerationFolder.add( params, 'gpuGeneration' );\n\tgenerationFolder.add( params, 'resolution', 10, 200, 1 );\n\tgenerationFolder.add( params, 'margin', 0, 1 );\n\tgenerationFolder.add( params, 'regenerate' );\n\n\tconst displayFolder = gui.addFolder( 'display' );\n\tdisplayFolder.add( params, 'mode', [ 'geometry', 'raymarching', 'layer', 'grid layers' ] ).onChange( () => {\n\n\t\trebuildGUI();\n\n\t} );\n\n\tif ( params.mode === 'layer' ) {\n\n\t\tdisplayFolder.add( params, 'layer', 0, params.resolution, 1 );\n\n\t}\n\n\tif ( params.mode === 'raymarching' ) {\n\n\t\tdisplayFolder.add( params, 'surface', - 0.2, 0.5 );\n\n\t}\n\n}\n\n// update the sdf texture based on the selected parameters\nfunction updateSDF() {\n\n\tconst dim = params.resolution;\n\tconst matrix = new THREE.Matrix4();\n\tconst center = new THREE.Vector3();\n\tconst quat = new THREE.Quaternion();\n\tconst scale = new THREE.Vector3();\n\n\t// compute the bounding box of the geometry including the margin which is used to\n\t// define the range of the SDF\n\tgeometry.boundingBox.getCenter( center );\n\tscale.subVectors( geometry.boundingBox.max, geometry.boundingBox.min );\n\tscale.x += 2 * params.margin;\n\tscale.y += 2 * params.margin;\n\tscale.z += 2 * params.margin;\n\tmatrix.compose( center, quat, scale );\n\tinverseBoundsMatrix.copy( matrix ).invert();\n\n\t// update the box helper\n\tboxHelper.box.copy( geometry.boundingBox );\n\tboxHelper.box.min.x -= params.margin;\n\tboxHelper.box.min.y -= params.margin;\n\tboxHelper.box.min.z -= params.margin;\n\tboxHelper.box.max.x += params.margin;\n\tboxHelper.box.max.y += params.margin;\n\tboxHelper.box.max.z += params.margin;\n\n\t// dispose of the existing sdf\n\tif ( sdfTex ) {\n\n\t\tsdfTex.dispose();\n\n\t}\n\n\tconst pxWidth = 1 / dim;\n\tconst halfWidth = 0.5 * pxWidth;\n\n\tconst startTime = window.performance.now();\n\tif ( params.gpuGeneration ) {\n\n\t\t// create a new 3d render target texture\n\t\tconst floatLinearExtSupported = renderer.extensions.get( 'OES_texture_float_linear' );\n\t\tsdfTex = new THREE.WebGL3DRenderTarget( dim, dim, dim );\n\t\tsdfTex.texture.format = THREE.RedFormat;\n\t\tsdfTex.texture.type = floatLinearExtSupported ? THREE.FloatType : THREE.HalfFloatType;\n\t\tsdfTex.texture.minFilter = THREE.LinearFilter;\n\t\tsdfTex.texture.magFilter = THREE.LinearFilter;\n\t\trenderer.initRenderTarget( sdfTex );\n\n\t\t// prep the sdf generation material pass\n\t\tgenerateSdfPass.material.uniforms.bvh.value.updateFrom( bvh );\n\t\tgenerateSdfPass.material.uniforms.matrix.value.copy( matrix );\n\n\t\t// create a 2d render target to render in to\n\t\tconst scratchVec = new THREE.Vector3();\n\t\tconst scratchTarget = new THREE.WebGLRenderTarget( dim, dim );\n\t\tscratchTarget.texture.format = THREE.RedFormat;\n\t\tscratchTarget.texture.type = floatLinearExtSupported ? THREE.FloatType : THREE.HalfFloatType;\n\n\t\t// render into each layer\n\t\tfor ( let i = 0; i < dim; i ++ ) {\n\n\t\t\tgenerateSdfPass.material.uniforms.zValue.value = i * pxWidth + halfWidth;\n\n\t\t\trenderer.setRenderTarget( scratchTarget );\n\t\t\tgenerateSdfPass.render( renderer );\n\n\t\t\t// copy the data into the 3d texture since rendering directly into the target causes significant gpu artifacts\n\t\t\t// See issue #720\n\t\t\tscratchVec.z = i;\n\t\t\trenderer.copyTextureToTexture( scratchTarget.texture, sdfTex.texture, null, scratchVec );\n\n\t\t}\n\n\t\t// initiate read back to get a rough estimate of time taken to generate the sdf\n\t\trenderer.readRenderTargetPixels( scratchTarget, 0, 0, 1, 1, new Float32Array( 4 ) );\n\t\trenderer.setRenderTarget( null );\n\t\tscratchTarget.dispose();\n\n\t} else {\n\n\t\t// create a new 3d data texture\n\t\tsdfTex = new THREE.Data3DTexture( new Float32Array( dim ** 3 ), dim, dim, dim );\n\t\tsdfTex.format = THREE.RedFormat;\n\t\tsdfTex.type = THREE.FloatType;\n\t\tsdfTex.minFilter = THREE.LinearFilter;\n\t\tsdfTex.magFilter = THREE.LinearFilter;\n\t\tsdfTex.needsUpdate = true;\n\n\t\tconst point = new THREE.Vector3();\n\t\tconst ray = new THREE.Ray();\n\t\tconst target = {};\n\n\t\t// iterate over all pixels and check distance\n\t\tfor ( let x = 0; x < dim; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < dim; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z < dim; z ++ ) {\n\n\t\t\t\t\t// adjust by half width of the pixel so we sample the pixel center\n\t\t\t\t\t// and offset by half the box size.\n\t\t\t\t\tpoint.set(\n\t\t\t\t\t\thalfWidth + x * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + y * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + z * pxWidth - 0.5,\n\t\t\t\t\t).applyMatrix4( matrix );\n\n\t\t\t\t\tconst index = x + y * dim + z * dim * dim;\n\t\t\t\t\tconst dist = bvh.closestPointToPoint( point, target ).distance;\n\n\t\t\t\t\t// raycast inside the mesh to determine if the distance should be positive or negative\n\t\t\t\t\tray.origin.copy( point );\n\t\t\t\t\tray.direction.set( 0, 0, 1 );\n\t\t\t\t\tconst hit = bvh.raycastFirst( ray, THREE.DoubleSide );\n\t\t\t\t\tconst isInside = hit && hit.face.normal.dot( ray.direction ) > 0.0;\n\n\t\t\t\t\t// set the distance in the texture data\n\t\t\t\t\tsdfTex.image.data[ index ] = isInside ? - dist : dist;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// update the timing display\n\tconst delta = window.performance.now() - startTime;\n\toutputContainer.innerText = `${ delta.toFixed( 2 ) }ms`;\n\n\trebuildGUI();\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tif ( ! sdfTex ) {\n\n\t\t// render nothing\n\t\treturn;\n\n\t} else if ( params.mode === 'geometry' ) {\n\n\t\t// render the rasterized geometry\n\t\trenderer.render( scene, camera );\n\n\t} else if ( params.mode === 'layer' || params.mode === 'grid layers' ) {\n\n\t\t// render a layer of the 3d texture\n\t\tlet tex;\n\t\tconst material = layerPass.material;\n\t\tif ( sdfTex.isData3DTexture ) {\n\n\t\t\tmaterial.uniforms.layer.value = params.layer / sdfTex.image.width;\n\t\t\tmaterial.uniforms.sdfTex.value = sdfTex;\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\tmaterial.uniforms.layer.value = params.layer / sdfTex.width;\n\t\t\tmaterial.uniforms.sdfTex.value = sdfTex.texture;\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tmaterial.uniforms.layers.value = tex.image.width;\n\n\t\tconst gridMode = params.mode === 'layer' ? 0 : 1;\n\t\tif ( gridMode !== material.defines.DISPLAY_GRID ) {\n\n\t\t\tmaterial.defines.DISPLAY_GRID = gridMode;\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tlayerPass.render( renderer );\n\n\t} else if ( params.mode === 'raymarching' ) {\n\n\t\t// render the ray marched texture\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tlet tex;\n\t\tif ( sdfTex.isData3DTexture ) {\n\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tconst { width, depth, height } = tex.image;\n\t\traymarchPass.material.uniforms.sdfTex.value = tex;\n\t\traymarchPass.material.uniforms.normalStep.value.set( 1 / width, 1 / height, 1 / depth );\n\t\traymarchPass.material.uniforms.surface.value = params.surface;\n\t\traymarchPass.material.uniforms.projectionInverse.value.copy( camera.projectionMatrixInverse );\n\t\traymarchPass.material.uniforms.sdfTransformInverse.value.copy( mesh.matrixWorld ).invert().premultiply( inverseBoundsMatrix ).multiply( camera.matrixWorld );\n\t\traymarchPass.render( renderer );\n\n\t}\n\n}\n"],"names":["bvh_distance_functions","GenerateSDFMaterial","ShaderMaterial","params","Matrix4","MeshBVHUniformStruct","BVHShaderGLSL.common_functions","BVHShaderGLSL.bvh_struct_definitions","BVHShaderGLSL.bvh_ray_functions","BVHShaderGLSL.bvh_distance_functions","RenderSDFLayerMaterial","RayMarchSDFMaterial","Vector3","updateSDF","renderer","camera","scene","gui","stats","boxHelper","outputContainer","bvh","geometry","sdfTex","mesh","generateSdfPass","layerPass","raymarchPass","bvhGenerationWorker","inverseBoundsMatrix","THREE.Matrix4","init","render","THREE.WebGLRenderer","THREE.Scene","light","THREE.DirectionalLight","THREE.AmbientLight","THREE.PerspectiveCamera","THREE.Box3Helper","THREE.Box3","OrbitControls","Stats","FullScreenQuad","GenerateMeshBVHWorker","GLTFLoader","MeshoptDecoder","gltf","staticGen","StaticGeometryGenerator","result","THREE.Mesh","THREE.MeshStandardMaterial","rebuildGUI","GUI","generationFolder","displayFolder","dim","matrix","center","THREE.Vector3","quat","THREE.Quaternion","scale","pxWidth","halfWidth","startTime","floatLinearExtSupported","THREE.WebGL3DRenderTarget","THREE.RedFormat","THREE.FloatType","THREE.HalfFloatType","THREE.LinearFilter","scratchVec","scratchTarget","THREE.WebGLRenderTarget","i","THREE.Data3DTexture","point","ray","THREE.Ray","target","x","y","z","index","dist","hit","THREE.DoubleSide","isInside","delta","tex","material","gridMode","width","depth","height"],"mappings":"01BACO,MAAMA,GAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECEzC,MAAMC,WAA4BC,CAAe,CAEvD,YAAaC,EAAS,CAErB,MAAO,CAEN,QAAS,CAER,mBAAoB,OAAO,SAAS,KAAK,SAAU,oBAAoB,EAAK,EAAI,CAEpF,EAEG,SAAU,CAET,OAAQ,CAAE,MAAO,IAAIC,CAAS,EAC9B,OAAQ,CAAE,MAAO,CAAC,EAClB,IAAK,CAAE,MAAO,IAAIC,EAAsB,CAE5C,EAEG,aAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAaxB,eAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,MAKtBC,EAA8B;AAAA,MAC9BC,EAAoC;AAAA,MACpCC,EAA+B;AAAA,MAC/BC,EAAoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAuC3C,CAAG,EAED,KAAK,UAAWN,CAAM,CAEvB,CAED,CCvFO,MAAMO,WAA+BR,CAAe,CAE1D,YAAaC,EAAS,CAErB,MAAO,CAEN,QAAS,CAER,aAAc,CAElB,EAEG,SAAU,CAET,OAAQ,CAAE,MAAO,IAAI,EACrB,MAAO,CAAE,MAAO,CAAC,EACjB,OAAQ,CAAE,MAAO,CAAC,CAEtB,EAEG,aAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAaxB,eAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkC7B,CAAG,EAED,KAAK,UAAWA,CAAM,CAEvB,CAED,CCzEO,MAAMQ,WAA4BT,CAAe,CAEvD,YAAaC,EAAS,CAErB,MAAO,CAEN,QAAS,CAER,UAAW,IACX,gBAAiB,IAErB,EAEG,SAAU,CAET,QAAS,CAAE,MAAO,CAAC,EACnB,OAAQ,CAAE,MAAO,IAAI,EACrB,WAAY,CAAE,MAAO,IAAIS,CAAS,EAClC,kBAAmB,CAAE,MAAO,IAAIR,CAAS,EACzC,oBAAqB,CAAE,MAAO,IAAIA,CAAS,CAE/C,EAEG,aAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAaxB,eAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAmH7B,CAAG,EAED,KAAK,UAAWD,CAAM,CAEvB,CAED,CClJA,MAAMA,EAAS,CAEd,cAAe,GACf,WAAY,GACZ,OAAQ,GACR,WAAY,IAAMU,EAAS,EAE3B,KAAM,cACN,MAAO,EACP,QAAS,EAEV,EAEA,IAAIC,EAAUC,EAAQC,EAAOC,EAAKC,EAAOC,EACrCC,EAAiBC,EAAKC,EAAUC,EAAQC,EACxCC,EAAiBC,EAAWC,EAC5BC,EACJ,MAAMC,EAAsB,IAAIC,EAEhCC,GAAI,EACJC,EAAM,EAEN,SAASD,IAAO,CAEfX,EAAkB,SAAS,eAAgB,QAAQ,EAGnDN,EAAW,IAAImB,EAAqB,CAAE,UAAW,EAAI,CAAE,EACvDnB,EAAS,cAAe,OAAO,gBAAgB,EAC/CA,EAAS,QAAS,OAAO,WAAY,OAAO,WAAW,EACvDA,EAAS,cAAe,EAAG,CAAC,EAC5B,SAAS,KAAK,YAAaA,EAAS,UAAU,EAG9CE,EAAQ,IAAIkB,EAEZ,MAAMC,EAAQ,IAAIC,EAAwB,SAAU,CAAC,EACrDD,EAAM,SAAS,IAAK,EAAG,EAAG,CAAC,EAC3BnB,EAAM,IAAKmB,CAAK,EAChBnB,EAAM,IAAK,IAAIqB,EAAoB,SAAU,EAAG,CAAE,EAGlDtB,EAAS,IAAIuB,EAAyB,GAAI,OAAO,WAAa,OAAO,YAAa,GAAK,EAAE,EACzFvB,EAAO,SAAS,IAAK,EAAG,EAAG,CAAC,EAC5BA,EAAO,IAAM,IACbA,EAAO,uBAAsB,EAE7BI,EAAY,IAAIoB,EAAkB,IAAIC,CAAY,EAClDxB,EAAM,IAAKG,CAAS,EAEpB,IAAIsB,GAAe1B,EAAQD,EAAS,UAAU,EAG9CI,EAAQ,IAAIwB,GACZ,SAAS,KAAK,YAAaxB,EAAM,GAAG,EAGpCO,EAAkB,IAAIkB,EAAgB,IAAI1C,EAAqB,EAG/DyB,EAAY,IAAIiB,EAAgB,IAAIjC,EAAwB,EAG5DiB,EAAe,IAAIgB,EAAgB,IAAIhC,EAAqB,EAG5DiB,EAAsB,IAAIgB,GAE1B,IAAIC,GAAU,EACZ,kBAAmBC,EAAc,EACjC,UAAW,+FAA+F,EAC1G,KAAMC,GAAQ,CAEdA,EAAK,MAAM,kBAAmB,EAAI,EAElC,MAAMC,EAAY,IAAIC,GAAyBF,EAAK,KAAK,EACzD,OAAAC,EAAU,WAAa,CAAE,WAAY,QAAQ,EAC7CA,EAAU,UAAY,GAEtB1B,EAAW0B,EAAU,SAAQ,EAAG,OAAM,EAE/BpB,EAAoB,SAAUN,EAAU,CAAE,YAAa,CAAC,CAAE,CAElE,CAAC,EACA,KAAM4B,GAAU,CAEhB7B,EAAM6B,EAEN1B,EAAO,IAAI2B,GAAY7B,EAAU,IAAI8B,EAA4B,EACjEpC,EAAM,IAAKQ,CAAI,EAEfX,EAAS,CAEV,CAAC,EAEFwC,EAAU,EAEV,OAAO,iBAAkB,SAAU,UAAY,CAE9CtC,EAAO,OAAS,OAAO,WAAa,OAAO,YAC3CA,EAAO,uBAAsB,EAE7BD,EAAS,QAAS,OAAO,WAAY,OAAO,WAAW,CAExD,EAAG,EAAK,CAET,CAGA,SAASuC,GAAa,CAEhBpC,GAEJA,EAAI,QAAO,EAIZd,EAAO,MAAQ,KAAK,IAAKA,EAAO,WAAYA,EAAO,KAAK,EAExDc,EAAM,IAAIqC,GAEV,MAAMC,EAAmBtC,EAAI,UAAW,YAAY,EACpDsC,EAAiB,IAAKpD,EAAQ,eAAe,EAC7CoD,EAAiB,IAAKpD,EAAQ,aAAc,GAAI,IAAK,CAAC,EACtDoD,EAAiB,IAAKpD,EAAQ,SAAU,EAAG,CAAC,EAC5CoD,EAAiB,IAAKpD,EAAQ,YAAY,EAE1C,MAAMqD,EAAgBvC,EAAI,UAAW,SAAS,EAC9CuC,EAAc,IAAKrD,EAAQ,OAAQ,CAAE,WAAY,cAAe,QAAS,cAAe,EAAG,SAAU,IAAM,CAE1GkD,EAAU,CAEX,CAAC,EAEIlD,EAAO,OAAS,SAEpBqD,EAAc,IAAKrD,EAAQ,QAAS,EAAGA,EAAO,WAAY,CAAC,EAIvDA,EAAO,OAAS,eAEpBqD,EAAc,IAAKrD,EAAQ,UAAW,IAAO,EAAG,CAIlD,CAGA,SAASU,GAAY,CAEpB,MAAM4C,EAAMtD,EAAO,WACbuD,EAAS,IAAI5B,EACb6B,EAAS,IAAIC,EACbC,EAAO,IAAIC,GACXC,EAAQ,IAAIH,EAIlBtC,EAAS,YAAY,UAAWqC,CAAM,EACtCI,EAAM,WAAYzC,EAAS,YAAY,IAAKA,EAAS,YAAY,GAAG,EACpEyC,EAAM,GAAK,EAAI5D,EAAO,OACtB4D,EAAM,GAAK,EAAI5D,EAAO,OACtB4D,EAAM,GAAK,EAAI5D,EAAO,OACtBuD,EAAO,QAASC,EAAQE,EAAME,CAAK,EACnClC,EAAoB,KAAM6B,CAAM,EAAG,OAAM,EAGzCvC,EAAU,IAAI,KAAMG,EAAS,WAAW,EACxCH,EAAU,IAAI,IAAI,GAAKhB,EAAO,OAC9BgB,EAAU,IAAI,IAAI,GAAKhB,EAAO,OAC9BgB,EAAU,IAAI,IAAI,GAAKhB,EAAO,OAC9BgB,EAAU,IAAI,IAAI,GAAKhB,EAAO,OAC9BgB,EAAU,IAAI,IAAI,GAAKhB,EAAO,OAC9BgB,EAAU,IAAI,IAAI,GAAKhB,EAAO,OAGzBoB,GAEJA,EAAO,QAAO,EAIf,MAAMyC,EAAU,EAAIP,EACdQ,EAAY,GAAMD,EAElBE,EAAY,OAAO,YAAY,IAAG,EACxC,GAAK/D,EAAO,cAAgB,CAG3B,MAAMgE,EAA0BrD,EAAS,WAAW,IAAK,0BAA0B,EACnFS,EAAS,IAAI6C,GAA2BX,EAAKA,EAAKA,CAAG,EACrDlC,EAAO,QAAQ,OAAS8C,EACxB9C,EAAO,QAAQ,KAAO4C,EAA0BG,EAAkBC,EAClEhD,EAAO,QAAQ,UAAYiD,EAC3BjD,EAAO,QAAQ,UAAYiD,EAC3B1D,EAAS,iBAAkBS,CAAM,EAGjCE,EAAgB,SAAS,SAAS,IAAI,MAAM,WAAYJ,CAAG,EAC3DI,EAAgB,SAAS,SAAS,OAAO,MAAM,KAAMiC,CAAM,EAG3D,MAAMe,EAAa,IAAIb,EACjBc,EAAgB,IAAIC,GAAyBlB,EAAKA,CAAG,EAC3DiB,EAAc,QAAQ,OAASL,EAC/BK,EAAc,QAAQ,KAAOP,EAA0BG,EAAkBC,EAGzE,QAAUK,EAAI,EAAGA,EAAInB,EAAKmB,IAEzBnD,EAAgB,SAAS,SAAS,OAAO,MAAQmD,EAAIZ,EAAUC,EAE/DnD,EAAS,gBAAiB4D,CAAa,EACvCjD,EAAgB,OAAQX,CAAQ,EAIhC2D,EAAW,EAAIG,EACf9D,EAAS,qBAAsB4D,EAAc,QAASnD,EAAO,QAAS,KAAMkD,CAAU,EAKvF3D,EAAS,uBAAwB4D,EAAe,EAAG,EAAG,EAAG,EAAG,IAAI,aAAc,EAAG,EACjF5D,EAAS,gBAAiB,IAAI,EAC9B4D,EAAc,QAAO,CAEtB,KAAO,CAGNnD,EAAS,IAAIsD,GAAqB,IAAI,aAAcpB,GAAO,GAAKA,EAAKA,EAAKA,CAAG,EAC7ElC,EAAO,OAAS8C,EAChB9C,EAAO,KAAO+C,EACd/C,EAAO,UAAYiD,EACnBjD,EAAO,UAAYiD,EACnBjD,EAAO,YAAc,GAErB,MAAMuD,EAAQ,IAAIlB,EACZmB,EAAM,IAAIC,GACVC,EAAS,CAAA,EAGf,QAAUC,EAAI,EAAGA,EAAIzB,EAAKyB,IAEzB,QAAUC,EAAI,EAAGA,EAAI1B,EAAK0B,IAEzB,QAAUC,EAAI,EAAGA,EAAI3B,EAAK2B,IAAO,CAIhCN,EAAM,IACLb,EAAYiB,EAAIlB,EAAU,GAC1BC,EAAYkB,EAAInB,EAAU,GAC1BC,EAAYmB,EAAIpB,EAAU,EAChC,EAAO,aAAcN,CAAM,EAEtB,MAAM2B,EAAQH,EAAIC,EAAI1B,EAAM2B,EAAI3B,EAAMA,EAChC6B,EAAOjE,EAAI,oBAAqByD,EAAOG,CAAM,EAAG,SAGtDF,EAAI,OAAO,KAAMD,CAAK,EACtBC,EAAI,UAAU,IAAK,EAAG,EAAG,CAAC,EAC1B,MAAMQ,EAAMlE,EAAI,aAAc0D,EAAKS,EAAgB,EAC7CC,EAAWF,GAAOA,EAAI,KAAK,OAAO,IAAKR,EAAI,SAAS,EAAK,EAG/DxD,EAAO,MAAM,KAAM8D,CAAK,EAAKI,EAAW,CAAEH,EAAOA,CAElD,CAMH,CAGA,MAAMI,EAAQ,OAAO,YAAY,IAAG,EAAKxB,EACzC9C,EAAgB,UAAY,GAAIsE,EAAM,QAAS,CAAC,CAAE,KAElDrC,EAAU,CAEX,CAEA,SAASrB,GAAS,CAKjB,GAHAd,EAAM,OAAM,EACZ,sBAAuBc,CAAM,EAEtBT,GAKA,GAAKpB,EAAO,OAAS,WAG3BW,EAAS,OAAQE,EAAOD,CAAM,UAEnBZ,EAAO,OAAS,SAAWA,EAAO,OAAS,cAAgB,CAGtE,IAAIwF,EACJ,MAAMC,EAAWlE,EAAU,SACtBH,EAAO,iBAEXqE,EAAS,SAAS,MAAM,MAAQzF,EAAO,MAAQoB,EAAO,MAAM,MAC5DqE,EAAS,SAAS,OAAO,MAAQrE,EACjCoE,EAAMpE,IAINqE,EAAS,SAAS,MAAM,MAAQzF,EAAO,MAAQoB,EAAO,MACtDqE,EAAS,SAAS,OAAO,MAAQrE,EAAO,QACxCoE,EAAMpE,EAAO,SAIdqE,EAAS,SAAS,OAAO,MAAQD,EAAI,MAAM,MAE3C,MAAME,EAAW1F,EAAO,OAAS,QAAU,EAAI,EAC1C0F,IAAaD,EAAS,QAAQ,eAElCA,EAAS,QAAQ,aAAeC,EAChCD,EAAS,YAAc,IAIxBlE,EAAU,OAAQZ,CAAQ,CAE3B,SAAYX,EAAO,OAAS,cAAgB,CAG3CY,EAAO,kBAAiB,EACxBS,EAAK,kBAAiB,EAEtB,IAAImE,EACCpE,EAAO,gBAEXoE,EAAMpE,EAINoE,EAAMpE,EAAO,QAId,KAAM,CAAE,MAAAuE,EAAO,MAAAC,EAAO,OAAAC,CAAM,EAAKL,EAAI,MACrChE,EAAa,SAAS,SAAS,OAAO,MAAQgE,EAC9ChE,EAAa,SAAS,SAAS,WAAW,MAAM,IAAK,EAAImE,EAAO,EAAIE,EAAQ,EAAID,CAAK,EACrFpE,EAAa,SAAS,SAAS,QAAQ,MAAQxB,EAAO,QACtDwB,EAAa,SAAS,SAAS,kBAAkB,MAAM,KAAMZ,EAAO,uBAAuB,EAC3FY,EAAa,SAAS,SAAS,oBAAoB,MAAM,KAAMH,EAAK,WAAW,EAAG,OAAM,EAAG,YAAaK,CAAmB,EAAG,SAAUd,EAAO,WAAW,EAC1JY,EAAa,OAAQb,CAAQ,CAE9B,MA/DC,OAiEF"}