import{G as _,w as E,f as P,n as W,O as H,M as j,i as F,b as T,B as b}from"./ExtendedTriangle-DttJMGjs.js";import{M as z,l as L}from"./MeshBVH-DAC57waP.js";const w=new T,B=new W;class O extends H{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}getVertexPosition(...t){return j.prototype.getVertexPosition.call(this,...t)}constructor(t,e,i=10,s=0){super(),this.material=e,this.geometry=new F,this.name="MeshBVHRootHelper",this.depth=i,this.displayParents=!1,this.bvh=t,this.displayEdges=!0,this._group=s}raycast(){}update(){const t=this.geometry,e=this.bvh,i=this._group;if(t.dispose(),this.visible=!1,e){const s=this.depth-1,a=this.displayParents;let o=0;e.traverse((n,y)=>{if(n>=s||y)return o++,!0;a&&o++},i);let p=0;const h=new Float32Array(24*o);e.traverse((n,y,u)=>{const d=n>=s||y;if(d||a){L(0,u,w);const{min:g,max:f}=w;for(let m=-1;m<=1;m+=2){const v=m<0?g.x:f.x;for(let x=-1;x<=1;x+=2){const I=x<0?g.y:f.y;for(let M=-1;M<=1;M+=2){const V=M<0?g.z:f.z;h[p+0]=v,h[p+1]=I,h[p+2]=V,p+=3}}}return d}},i);let l,r;this.displayEdges?r=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):r=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),h.length>65535?l=new Uint32Array(r.length*o):l=new Uint16Array(r.length*o);const c=r.length;for(let n=0;n<o;n++){const y=n*8,u=n*c;for(let d=0;d<c;d++)l[u+d]=y+r[d]}t.setIndex(new b(l,1,!1)),t.setAttribute("position",new b(h,3,!1)),this.visible=!0}}}class A extends _{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t=null,e=null,i=10){t instanceof z&&(i=e||10,e=t,t=null),typeof e=="number"&&(i=e,e=null),super(),this.name="MeshBVHHelper",this.depth=i,this.mesh=t,this.bvh=e,this.displayParents=!1,this.displayEdges=!0,this.objectIndex=0,this._roots=[];const s=new E({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),a=new P({color:65416,transparent:!0,opacity:.3,depthWrite:!1});a.color=s.color,this.edgeMaterial=s,this.meshMaterial=a,this.update()}update(){const t=this.mesh;let e=this.bvh||t.geometry.boundsTree||null;if(t&&t.isBatchedMesh&&t.boundsTrees&&!e){const s=t._drawInfo[this.objectIndex];s&&(e=t.boundsTrees[s.geometryIndex]||e)}const i=e?e._roots.length:0;for(;this._roots.length>i;){const s=this._roots.pop();s.geometry.dispose(),this.remove(s)}for(let s=0;s<i;s++){const{depth:a,edgeMaterial:o,meshMaterial:p,displayParents:h,displayEdges:l}=this;if(s>=this._roots.length){const c=new O(e,o,a,s);this.add(c),this._roots.push(c)}const r=this._roots[s];r.bvh=e,r.depth=a,r.displayParents=h,r.displayEdges=l,r.material=l?o:p,r.update()}}updateMatrixWorld(...t){const e=this.mesh,i=this.parent;e!==null&&(e.updateWorldMatrix(!0,!1),i?this.matrix.copy(i.matrixWorld).invert().multiply(e.matrixWorld):this.matrix.copy(e.matrixWorld),(e.isInstancedMesh||e.isBatchedMesh)&&(e.getMatrixAt(this.objectIndex,B),this.matrix.multiply(B)),this.matrix.decompose(this.position,this.quaternion,this.scale)),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh,this.bvh=t.bvh,this.opacity=t.opacity,this.color.copy(t.color)}clone(){return new A(this.mesh,this.bvh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].geometry.dispose()}}export{A as M};
