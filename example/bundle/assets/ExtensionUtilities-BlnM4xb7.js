import{M as f,v as y,b8 as m,ac as b,aM as p,K as M,j as R,b9 as L}from"./ExtendedTriangle-hsPasuNU.js";import{M as g}from"./MeshBVH-DQV6PBDm.js";const _=parseInt(L)>=166,c={Mesh:f.prototype.raycast,Line:b.prototype.raycast,LineSegments:y.prototype.raycast,LineLoop:m.prototype.raycast,Points:p.prototype.raycast,BatchedMesh:R.prototype.raycast},t=new f,u=[];function j(e,s){if(this.isBatchedMesh)S.call(this,e,s);else{const{geometry:o}=this;if(o.boundsTree)o.boundsTree.raycastObject3D(this,e,s);else{let n;if(this instanceof f)n=c.Mesh;else if(this instanceof y)n=c.LineSegments;else if(this instanceof m)n=c.LineLoop;else if(this instanceof b)n=c.Line;else if(this instanceof p)n=c.Points;else throw new Error("BVH: Fallback raycast function not found.");n.call(this,e,s)}}}function S(e,s){if(this.boundsTrees){const o=this.boundsTrees,n=this._drawInfo||this._instanceInfo,r=this._drawRanges||this._geometryInfo,i=this.matrixWorld;t.material=this.material,t.geometry=this.geometry;const T=t.geometry.boundsTree,w=t.geometry.drawRange;t.geometry.boundingSphere===null&&(t.geometry.boundingSphere=new M);for(let a=0,B=n.length;a<B;a++){if(!this.getVisibleAt(a))continue;const l=n[a].geometryIndex;if(t.geometry.boundsTree=o[l],this.getMatrixAt(a,t.matrixWorld).premultiply(i),!t.geometry.boundsTree){this.getBoundingBoxAt(l,t.geometry.boundingBox),this.getBoundingSphereAt(l,t.geometry.boundingSphere);const h=r[l];t.geometry.setDrawRange(h.start,h.count)}t.raycast(e,u);for(let h=0,I=u.length;h<I;h++){const d=u[h];d.object=this,d.batchId=a,s.push(d)}u.length=0}t.geometry.boundsTree=T,t.geometry.drawRange=w,t.material=null,t.geometry=null}else c.BatchedMesh.call(this,e,s)}function E(e={}){const{type:s=g}=e;return this.boundsTree=new s(this,e),this.boundsTree}function D(){this.boundsTree=null}function F(e=-1,s={}){if(!_)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");s={...s,range:null};const o=this._drawRanges||this._geometryInfo,n=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(n).fill(null));const r=this.boundsTrees;for(;r.length<n;)r.push(null);if(e<0){for(let i=0;i<n;i++)s.range=o[i],r[i]=new g(this.geometry,s);return r}else return e<o.length&&(s.range=o[e],r[e]=new g(this.geometry,s)),r[e]||null}function O(e=-1){e<0?this.boundsTrees.fill(null):e<this.boundsTrees.length&&(this.boundsTrees[e]=null)}export{j as a,F as b,E as c,D as d,O as e};
//# sourceMappingURL=ExtensionUtilities-BlnM4xb7.js.map
