{"version":3,"file":"Debug-DgSlAya1.js","sources":["../../../src/debug/Debug.js"],"sourcesContent":["import { Box3 } from 'three';\nimport { PRIMITIVE_INTERSECT_COST, TRAVERSAL_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getElementSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tprimitives: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.primitives.min = Math.min( count, result.primitives.min );\n\t\t\tresult.primitives.max = Math.max( count, result.primitives.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * PRIMITIVE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.primitives.min === Infinity ) {\n\n\t\tresult.primitives.min = 0;\n\t\tresult.primitives.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! Object.hasOwn( curr, key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getElementSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getElementSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst depthStack = [];\n\tconst tempBuffer = new Float32Array( 6 );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// Compute the actual bounds of the primitives in this leaf\n\t\t\tbvh.writePrimitiveRangeBounds( offset, count, tempBuffer, 0 );\n\n\t\t\t// tempBuffer is in min/max format [minx, miny, minz, maxx, maxy, maxz]\n\t\t\t_box2.min.set( tempBuffer[ 0 ], tempBuffer[ 1 ], tempBuffer[ 2 ] );\n\t\t\t_box2.max.set( tempBuffer[ 3 ], tempBuffer[ 4 ], tempBuffer[ 5 ] );\n\n\t\t\t// Check if the stored bounds contain the actual primitive bounds\n\t\t\tconst isContained = _box1.containsBox( _box2 );\n\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain primitives.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, parent.boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n"],"names":["getElementSize","el","isTypedArray","arr","getRootExtremes","bvh","group","result","depth","isLeaf","boundingData","offsetOrSplit","count","l0","l1","l2","surfaceArea","PRIMITIVE_INTERSECT_COST","TRAVERSAL_COST","getBVHExtremes","root","i","estimateMemoryInBytes","obj","traversed","stack","bytes","curr","key","value","isSharedArrayBufferSupported"],"mappings":"wDASA,SAASA,EAAgBC,EAAK,CAE7B,OAAS,OAAOA,EAAE,CAEjB,IAAK,SACJ,MAAO,GACR,IAAK,SACJ,OAAOA,EAAG,OAAS,EACpB,IAAK,UACJ,MAAO,GACR,QACC,MAAO,EAEV,CAEA,CAEA,SAASC,EAAcC,EAAM,CAG5B,MADc,iCACD,KAAMA,EAAI,YAAY,IAAI,CAExC,CAEA,SAASC,EAAiBC,EAAKC,EAAQ,CAEtC,MAAMC,EAAS,CACd,UAAW,EACX,cAAe,EAEf,MAAO,CACN,IAAK,IAAU,IAAK,IACvB,EACE,WAAY,CACX,IAAK,IAAU,IAAK,IACvB,EACE,OAAQ,CAAE,EAAG,EAAG,CAAC,EACjB,iBAAkB,CACpB,EAEC,OAAAF,EAAI,SAAU,CAAEG,EAAOC,EAAQC,EAAcC,EAAeC,IAAW,CAEtE,MAAMC,EAAKH,EAAc,CAAK,EAAKA,EAAc,CAAC,EAC5CI,EAAKJ,EAAc,CAAK,EAAKA,EAAc,CAAC,EAC5CK,EAAKL,EAAc,CAAK,EAAKA,EAAc,CAAC,EAE5CM,EAAc,GAAMH,EAAKC,EAAKA,EAAKC,EAAKA,EAAKF,GAEnDN,EAAO,YACFE,GAEJF,EAAO,gBAEPA,EAAO,MAAM,IAAM,KAAK,IAAKC,EAAOD,EAAO,MAAM,GAAG,EACpDA,EAAO,MAAM,IAAM,KAAK,IAAKC,EAAOD,EAAO,MAAM,GAAG,EAEpDA,EAAO,WAAW,IAAM,KAAK,IAAKK,EAAOL,EAAO,WAAW,GAAG,EAC9DA,EAAO,WAAW,IAAM,KAAK,IAAKK,EAAOL,EAAO,WAAW,GAAG,EAE9DA,EAAO,kBAAoBS,EAAcC,EAA2BL,IAIpEL,EAAO,OAAQI,KAEfJ,EAAO,kBAAoBS,EAAcE,EAI3C,EAAGZ,CAAK,EAGHC,EAAO,WAAW,MAAQ,MAE9BA,EAAO,WAAW,IAAM,EACxBA,EAAO,WAAW,IAAM,GAIpBA,EAAO,MAAM,MAAQ,MAEzBA,EAAO,MAAM,IAAM,EACnBA,EAAO,MAAM,IAAM,GAIbA,CAER,CAEA,SAASY,EAAgBd,EAAM,CAE9B,OAAOA,EAAI,OAAO,IAAK,CAAEe,EAAMC,IAAOjB,EAAiBC,EAAKgB,EAAG,CAEhE,CAEA,SAASC,EAAuBC,EAAM,CAErC,MAAMC,EAAY,IAAI,IAChBC,EAAQ,CAAEF,CAAG,EACnB,IAAIG,EAAQ,EAEZ,KAAQD,EAAM,QAAS,CAEtB,MAAME,EAAOF,EAAM,IAAG,EACtB,GAAK,CAAAD,EAAU,IAAKG,GAMpB,CAAAH,EAAU,IAAKG,CAAI,EAEnB,QAAUC,KAAOD,EAAO,CAEvB,GAAK,CAAE,OAAO,OAAQA,EAAMC,CAAG,EAE9B,SAIDF,GAAS1B,EAAgB4B,CAAG,EAE5B,MAAMC,EAAQF,EAAMC,CAAG,EAClBC,IAAW,OAAOA,GAAU,UAAY,OAAOA,GAAU,YAExD3B,EAAc2B,IAIPC,KAAkCD,aAAiB,mBAInDA,aAAiB,YAN5BH,GAASG,EAAM,WAYfJ,EAAM,KAAMI,CAAK,EAMlBH,GAAS1B,EAAgB6B,CAAK,CAKhC,EAED,CAEA,OAAOH,CAER"}