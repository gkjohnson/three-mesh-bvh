import{i as j,B as D,bm as O,bl as H,bk as C}from"./ExtendedTriangle-DttJMGjs.js";function N(r,c=!1){const n=r[0].index!==null,m=new Set(Object.keys(r[0].attributes)),s=new Set(Object.keys(r[0].morphAttributes)),g={},t={},d=r[0].morphTargetsRelative,u=new j;let a=0;for(let e=0;e<r.length;++e){const o=r[e];let f=0;if(n!==(o.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const i in o.attributes){if(!m.has(i))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+i+'" attribute exists among all geometries, or in none of them.'),null;g[i]===void 0&&(g[i]=[]),g[i].push(o.attributes[i]),f++}if(f!==m.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(d!==o.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const i in o.morphAttributes){if(!s.has(i))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;t[i]===void 0&&(t[i]=[]),t[i].push(o.morphAttributes[i])}if(c){let i;if(n)i=o.index.count;else if(o.attributes.position!==void 0)i=o.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;u.addGroup(a,i,e),a+=i}}if(n){let e=0;const o=[];for(let f=0;f<r.length;++f){const i=r[f].index;for(let p=0;p<i.count;++p)o.push(i.getX(p)+e);e+=r[f].attributes.position.count}u.setIndex(o)}for(const e in g){const o=I(g[e]);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;u.setAttribute(e,o)}for(const e in t){const o=t[e][0].length;if(o===0)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[e]=[];for(let f=0;f<o;++f){const i=[];for(let T=0;T<t[e].length;++T)i.push(t[e][T][f]);const p=I(i);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;u.morphAttributes[e].push(p)}}return u}function I(r){let c,n,m,s=-1,g=0;for(let a=0;a<r.length;++a){const e=r[a];if(c===void 0&&(c=e.array.constructor),c!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(n===void 0&&(n=e.itemSize),n!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(m===void 0&&(m=e.normalized),m!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(s===-1&&(s=e.gpuType),s!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;g+=e.count*n}const t=new c(g),d=new D(t,n,m);let u=0;for(let a=0;a<r.length;++a){const e=r[a];if(e.isInterleavedBufferAttribute){const o=u/n;for(let f=0,i=e.count;f<i;f++)for(let p=0;p<n;p++){const T=e.getComponent(f,p);d.setComponent(f+o,p,T)}}else t.set(e.array,u);u+=e.count*n}return s!==void 0&&(d.gpuType=s),d}function L(r,c=1e-4){c=Math.max(c,Number.EPSILON);const n={},m=r.getIndex(),s=r.getAttribute("position"),g=m?m.count:s.count;let t=0;const d=Object.keys(r.attributes),u={},a={},e=[],o=["getX","getY","getZ","getW"],f=["setX","setY","setZ","setW"];for(let b=0,y=d.length;b<y;b++){const h=d[b],l=r.attributes[h];u[h]=new l.constructor(new l.array.constructor(l.count*l.itemSize),l.itemSize,l.normalized);const w=r.morphAttributes[h];w&&(a[h]||(a[h]=[]),w.forEach((A,x)=>{const E=new A.array.constructor(A.count*A.itemSize);a[h][x]=new A.constructor(E,A.itemSize,A.normalized)}))}const i=c*.5,p=Math.log10(1/c),T=Math.pow(10,p),M=i*T;for(let b=0;b<g;b++){const y=m?m.getX(b):b;let h="";for(let l=0,w=d.length;l<w;l++){const A=d[l],x=r.getAttribute(A),E=x.itemSize;for(let G=0;G<E;G++)h+=`${~~(x[o[G]](y)*T+M)},`}if(h in n)e.push(n[h]);else{for(let l=0,w=d.length;l<w;l++){const A=d[l],x=r.getAttribute(A),E=r.morphAttributes[A],G=x.itemSize,X=u[A],v=a[A];for(let B=0;B<G;B++){const R=o[B],S=f[B];if(X[S](t,x[R](y)),E)for(let U=0,k=E.length;U<k;U++)v[U][S](t,E[U][R](y))}}n[h]=t,e.push(t),t++}}const z=r.clone();for(const b in r.attributes){const y=u[b];if(z.setAttribute(b,new y.constructor(y.array.slice(0,t*y.itemSize),y.itemSize,y.normalized)),b in a)for(let h=0;h<a[b].length;h++){const l=a[b][h];z.morphAttributes[b][h]=new l.constructor(l.array.slice(0,t*l.itemSize),l.itemSize,l.normalized)}}return z.setIndex(e),z}function P(r,c){if(c===O)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),r;if(c===H||c===C){let n=r.getIndex();if(n===null){const t=[],d=r.getAttribute("position");if(d!==void 0){for(let u=0;u<d.count;u++)t.push(u);r.setIndex(t),n=r.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r}const m=n.count-2,s=[];if(c===H)for(let t=1;t<=m;t++)s.push(n.getX(0)),s.push(n.getX(t)),s.push(n.getX(t+1));else for(let t=0;t<m;t++)t%2===0?(s.push(n.getX(t)),s.push(n.getX(t+1)),s.push(n.getX(t+2))):(s.push(n.getX(t+2)),s.push(n.getX(t+1)),s.push(n.getX(t)));s.length/3!==m&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const g=r.clone();return g.setIndex(s),g.clearGroups(),g}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",c),r}export{L as a,N as m,P as t};
