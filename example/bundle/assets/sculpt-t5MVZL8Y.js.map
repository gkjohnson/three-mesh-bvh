{"version":3,"file":"sculpt-t5MVZL8Y.js","sources":["../../sculpt.js"],"sourcesContent":["import Stats from 'stats.js/src/Stats';\nimport * as dat from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport {\n\tacceleratedRaycast,\n\tcomputeBoundsTree,\n\tdisposeBoundsTree,\n\tCONTAINED,\n\tINTERSECTED,\n\tNOT_INTERSECTED,\n\tBVHHelper,\n} from 'three-mesh-bvh';\n\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nlet stats;\nlet scene, camera, renderer, controls;\nlet targetMesh, brush, symmetryBrush, bvhHelper;\nlet normalZ = new THREE.Vector3( 0, 0, 1 );\nlet brushActive = false;\nlet mouse = new THREE.Vector2(), lastMouse = new THREE.Vector2();\nlet mouseState = false, lastMouseState = false;\nlet lastCastPose = new THREE.Vector3();\nlet material, rightClick = false;\n\nconst params = {\n\tmatcap: 'Clay',\n\n\tsize: 0.1,\n\tbrush: 'clay',\n\tintensity: 50,\n\tmaxSteps: 10,\n\tinvert: false,\n\tsymmetrical: true,\n\tflatShading: false,\n\n\tdepth: 10,\n\tdisplayBVH: false,\n};\n\nconst matcaps = {};\n\ninit();\n\n// reset the sculpt mesh\nfunction reset() {\n\n\t// dispose of the mesh if it exists\n\tif ( targetMesh ) {\n\n\t\ttargetMesh.geometry.dispose();\n\t\ttargetMesh.material.dispose();\n\t\tscene.remove( targetMesh );\n\n\t}\n\n\t// merge the vertices because they're not already merged\n\tlet geometry = new THREE.IcosahedronGeometry( 1, 100 );\n\tgeometry.deleteAttribute( 'uv' );\n\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\tgeometry.attributes.position.setUsage( THREE.DynamicDrawUsage );\n\tgeometry.attributes.normal.setUsage( THREE.DynamicDrawUsage );\n\tgeometry.computeBoundsTree( { setBoundingBox: false } );\n\n\t// disable frustum culling because the verts will be updated\n\ttargetMesh = new THREE.Mesh(\n\t\tgeometry,\n\t\tmaterial,\n\t);\n\ttargetMesh.frustumCulled = false;\n\tscene.add( targetMesh );\n\n\t// initialize bvh helper\n\tif ( ! bvhHelper ) {\n\n\t\tbvhHelper = new BVHHelper( targetMesh, params.depth );\n\t\tif ( params.displayBVH ) {\n\n\t\t\tscene.add( bvhHelper );\n\n\t\t}\n\n\t}\n\n\tbvhHelper.mesh = targetMesh;\n\tbvhHelper.update();\n\n}\n\nfunction init() {\n\n\tconst bgColor = 0x060609;\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.setAnimationLoop( render );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\trenderer.domElement.style.touchAction = 'none';\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\tscene.fog = new THREE.Fog( 0x263238 / 2, 20, 60 );\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 0.5 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xffffff, 0.4 ) );\n\n\t// initialize brush cursor\n\tconst brushSegments = [ new THREE.Vector3(), new THREE.Vector3( 0, 0, 1 ) ];\n\tfor ( let i = 0; i < 50; i ++ ) {\n\n\t\tconst nexti = i + 1;\n\t\tconst x1 = Math.sin( 2 * Math.PI * i / 50 );\n\t\tconst y1 = Math.cos( 2 * Math.PI * i / 50 );\n\n\t\tconst x2 = Math.sin( 2 * Math.PI * nexti / 50 );\n\t\tconst y2 = Math.cos( 2 * Math.PI * nexti / 50 );\n\n\t\tbrushSegments.push(\n\t\t\tnew THREE.Vector3( x1, y1, 0 ),\n\t\t\tnew THREE.Vector3( x2, y2, 0 )\n\t\t);\n\n\t}\n\n\tbrush = new THREE.LineSegments();\n\tbrush.geometry.setFromPoints( brushSegments );\n\tbrush.material.color.set( 0xfb8c00 );\n\tscene.add( brush );\n\n\tsymmetryBrush = brush.clone();\n\tscene.add( symmetryBrush );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 0, 0, 3 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// init matcaps\n\tmatcaps[ 'Clay' ] = new THREE.TextureLoader().load( '../textures/B67F6B_4B2E2A_6C3A34_F3DBC6-256px.png' );\n\tmatcaps[ 'Red Wax' ] = new THREE.TextureLoader().load( '../textures/763C39_431510_210504_55241C-256px.png' );\n\tmatcaps[ 'Shiny Green' ] = new THREE.TextureLoader().load( '../textures/3B6E10_E3F2C3_88AC2E_99CE51-256px.png' );\n\tmatcaps[ 'Normal' ] = new THREE.TextureLoader().load( '../textures/7877EE_D87FC5_75D9C7_1C78C0-256px.png' );\n\tmaterial = new THREE.MeshMatcapMaterial( {\n\t\tflatShading: params.flatShading,\n\t} );\n\n\tfor ( const key in matcaps ) {\n\n\t\tmatcaps[ key ].encoding = THREE.sRGBEncoding;\n\n\t}\n\n\t// geometry setup\n\treset();\n\n\tconst gui = new dat.GUI();\n\tgui.add( params, 'matcap', Object.keys( matcaps ) );\n\n\tconst sculptFolder = gui.addFolder( 'Sculpting' );\n\tsculptFolder.add( params, 'brush', [ 'normal', 'clay', 'flatten' ] );\n\tsculptFolder.add( params, 'size' ).min( 0.025 ).max( 0.25 ).step( 0.005 );\n\tsculptFolder.add( params, 'intensity' ).min( 1 ).max( 100 ).step( 1 );\n\tsculptFolder.add( params, 'maxSteps' ).min( 1 ).max( 25 ).step( 1 );\n\tsculptFolder.add( params, 'symmetrical' );\n\tsculptFolder.add( params, 'invert' );\n\tsculptFolder.add( params, 'flatShading' ).onChange( value => {\n\n\t\ttargetMesh.material.flatShading = value;\n\t\ttargetMesh.material.needsUpdate = true;\n\n\t} );\n\tsculptFolder.open();\n\n\tconst helperFolder = gui.addFolder( 'BVH Helper' );\n\thelperFolder.add( params, 'depth' ).min( 1 ).max( 20 ).step( 1 ).onChange( d => {\n\n\t\tbvhHelper.depth = parseFloat( d );\n\t\tbvhHelper.update();\n\n\t} );\n\thelperFolder.add( params, 'displayBVH' ).onChange( display => {\n\n\t\tif ( display ) {\n\n\t\t\tscene.add( bvhHelper );\n\t\t\tbvhHelper.update();\n\n\t\t} else {\n\n\t\t\tscene.remove( bvhHelper );\n\n\t\t}\n\n\t} );\n\thelperFolder.open();\n\n\tgui.add( { reset }, 'reset' );\n\tgui.add( { rebuildBVH: () => {\n\n\t\t// don't create a bounding box because it's used in BVH construction but\n\t\t// will be out of date after moving vertices. See issue #222.\n\t\ttargetMesh.geometry.computeBoundsTree( { setBoundingBox: false } );\n\t\tbvhHelper.update();\n\n\t} }, 'rebuildBVH' );\n\tgui.open();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n\twindow.addEventListener( 'pointermove', function ( e ) {\n\n\t\tmouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tmouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n\t\tbrushActive = true;\n\n\t} );\n\n\twindow.addEventListener( 'pointerdown', e => {\n\n\t\tmouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tmouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\n\t\tmouseState = Boolean( e.buttons & 3 );\n\t\trightClick = Boolean( e.buttons & 2 );\n\t\tbrushActive = true;\n\n\t\tconst raycaster = new THREE.Raycaster();\n\t\traycaster.setFromCamera( mouse, camera );\n\t\traycaster.firstHitOnly = true;\n\n\t\tconst res = raycaster.intersectObject( targetMesh );\n\t\tcontrols.enabled = res.length === 0;\n\n\t}, true );\n\n\twindow.addEventListener( 'pointerup', e => {\n\n\t\tmouseState = Boolean( e.buttons & 3 );\n\t\tif ( e.pointerType === 'touch' ) {\n\n\t\t\tbrushActive = false;\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'contextmenu', function ( e ) {\n\n\t\te.preventDefault();\n\n\t} );\n\n\twindow.addEventListener( 'wheel', function ( e ) {\n\n\t\tlet delta = e.deltaY;\n\n\t\tif ( e.deltaMode === 1 ) {\n\n\t\t\tdelta *= 40;\n\n\t\t}\n\n\t\tif ( e.deltaMode === 2 ) {\n\n\t\t\tdelta *= 40;\n\n\t\t}\n\n\t\tparams.size += delta * 0.0001;\n\t\tparams.size = Math.max( Math.min( params.size, 0.25 ), 0.025 );\n\t\tgui.controllersRecursive().forEach( c => c.updateDisplay() );\n\n\t} );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.minDistance = 1.5;\n\n\tcontrols.addEventListener( 'start', function () {\n\n\t\tthis.active = true;\n\n\t} );\n\n\tcontrols.addEventListener( 'end', function () {\n\n\t\tthis.active = false;\n\n\t} );\n\n}\n\n// Run the perform the brush movement\nfunction performStroke( point, brushObject, brushOnly = false, accumulatedFields = {} ) {\n\n\tconst {\n\t\taccumulatedTriangles = new Set(),\n\t\taccumulatedIndices = new Set(),\n\t\taccumulatedTraversedNodeIndices = new Set(),\n\t} = accumulatedFields;\n\n\tconst inverseMatrix = new THREE.Matrix4();\n\tinverseMatrix.copy( targetMesh.matrixWorld ).invert();\n\n\tconst sphere = new THREE.Sphere();\n\tsphere.center.copy( point ).applyMatrix4( inverseMatrix );\n\tsphere.radius = params.size;\n\n\t// Collect the intersected vertices\n\tconst indices = new Set();\n\tconst tempVec = new THREE.Vector3();\n\tconst normal = new THREE.Vector3();\n\tconst indexAttr = targetMesh.geometry.index;\n\tconst posAttr = targetMesh.geometry.attributes.position;\n\tconst normalAttr = targetMesh.geometry.attributes.normal;\n\tconst triangles = new Set();\n\tconst bvh = targetMesh.geometry.boundsTree;\n\tbvh.shapecast( {\n\n\t\tintersectsBounds: ( box, isLeaf, score, depth, nodeIndex ) => {\n\n\t\t\taccumulatedTraversedNodeIndices.add( nodeIndex );\n\n\t\t\tconst intersects = sphere.intersectsBox( box );\n\t\t\tconst { min, max } = box;\n\t\t\tif ( intersects ) {\n\n\t\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\t\ttempVec.set(\n\t\t\t\t\t\t\t\tx === 0 ? min.x : max.x,\n\t\t\t\t\t\t\t\ty === 0 ? min.y : max.y,\n\t\t\t\t\t\t\t\tz === 0 ? min.z : max.z\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif ( ! sphere.containsPoint( tempVec ) ) {\n\n\t\t\t\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn CONTAINED;\n\n\t\t\t}\n\n\t\t\treturn intersects ? INTERSECTED : NOT_INTERSECTED;\n\n\t\t},\n\n\t\tintersectsTriangle: ( tri, index, contained ) => {\n\n\t\t\tconst triIndex = index;\n\t\t\ttriangles.add( triIndex );\n\t\t\taccumulatedTriangles.add( triIndex );\n\n\t\t\tconst i3 = 3 * index;\n\t\t\tconst a = i3 + 0;\n\t\t\tconst b = i3 + 1;\n\t\t\tconst c = i3 + 2;\n\t\t\tconst va = indexAttr.getX( a );\n\t\t\tconst vb = indexAttr.getX( b );\n\t\t\tconst vc = indexAttr.getX( c );\n\t\t\tif ( contained ) {\n\n\t\t\t\tindices.add( va );\n\t\t\t\tindices.add( vb );\n\t\t\t\tindices.add( vc );\n\n\t\t\t\taccumulatedIndices.add( va );\n\t\t\t\taccumulatedIndices.add( vb );\n\t\t\t\taccumulatedIndices.add( vc );\n\n\t\t\t} else {\n\n\t\t\t\tif ( sphere.containsPoint( tri.a ) ) {\n\n\t\t\t\t\tindices.add( va );\n\t\t\t\t\taccumulatedIndices.add( va );\n\n\t\t\t\t}\n\n\t\t\t\tif ( sphere.containsPoint( tri.b ) ) {\n\n\t\t\t\t\tindices.add( vb );\n\t\t\t\t\taccumulatedIndices.add( vb );\n\n\t\t\t\t}\n\n\t\t\t\tif ( sphere.containsPoint( tri.c ) ) {\n\n\t\t\t\t\tindices.add( vc );\n\t\t\t\t\taccumulatedIndices.add( vc );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\t// Compute the average normal at this point\n\tconst localPoint = new THREE.Vector3();\n\tlocalPoint.copy( point ).applyMatrix4( inverseMatrix );\n\n\tconst planePoint = new THREE.Vector3();\n\tlet totalPoints = 0;\n\tindices.forEach( index => {\n\n\t\ttempVec.fromBufferAttribute( normalAttr, index );\n\t\tnormal.add( tempVec );\n\n\t\t// compute the average point for cases where we need to flatten\n\t\t// to the plane.\n\t\tif ( ! brushOnly ) {\n\n\t\t\ttotalPoints ++;\n\t\t\ttempVec.fromBufferAttribute( posAttr, index );\n\t\t\tplanePoint.add( tempVec );\n\n\t\t}\n\n\t} );\n\tnormal.normalize();\n\tbrushObject.quaternion.setFromUnitVectors( normalZ, normal );\n\n\tif ( totalPoints ) {\n\n\t\tplanePoint.multiplyScalar( 1 / totalPoints );\n\n\t}\n\n\t// Early out if we just want to adjust the brush\n\tif ( brushOnly ) {\n\n\t\treturn;\n\n\t}\n\n\t// perform vertex adjustment\n\tconst targetHeight = params.intensity * 0.0001;\n\tconst plane = new THREE.Plane();\n\tplane.setFromNormalAndCoplanarPoint( normal, planePoint );\n\n\tindices.forEach( index => {\n\n\t\ttempVec.fromBufferAttribute( posAttr, index );\n\n\t\t// compute the offset intensity\n\t\tconst dist = tempVec.distanceTo( localPoint );\n\t\tconst negated = params.invert !== rightClick ? - 1 : 1;\n\t\tlet intensity = 1.0 - ( dist / params.size );\n\n\t\t// offset the vertex\n\t\tif ( params.brush === 'clay' ) {\n\n\t\t\tintensity = Math.pow( intensity, 3 );\n\t\t\tconst planeDist = plane.distanceToPoint( tempVec );\n\t\t\tconst clampedIntensity = negated * Math.min( intensity * 4, 1.0 );\n\t\t\ttempVec.addScaledVector( normal, clampedIntensity * targetHeight - negated * planeDist * clampedIntensity * 0.3 );\n\n\t\t} else if ( params.brush === 'normal' ) {\n\n\t\t\tintensity = Math.pow( intensity, 2 );\n\t\t\ttempVec.addScaledVector( normal, negated * intensity * targetHeight );\n\n\t\t} else if ( params.brush === 'flatten' ) {\n\n\t\t\tintensity = Math.pow( intensity, 2 );\n\n\t\t\tconst planeDist = plane.distanceToPoint( tempVec );\n\t\t\ttempVec.addScaledVector( normal, - planeDist * intensity * params.intensity * 0.01 * 0.5 );\n\n\t\t}\n\n\t\tposAttr.setXYZ( index, tempVec.x, tempVec.y, tempVec.z );\n\t\tnormalAttr.setXYZ( index, 0, 0, 0 );\n\n\t} );\n\n\t// If we found vertices\n\tif ( indices.size ) {\n\n\t\tposAttr.needsUpdate = true;\n\n\t}\n\n}\n\nfunction updateNormals( triangles, indices ) {\n\n\tconst tempVec = new THREE.Vector3();\n\tconst tempVec2 = new THREE.Vector3();\n\tconst indexAttr = targetMesh.geometry.index;\n\tconst posAttr = targetMesh.geometry.attributes.position;\n\tconst normalAttr = targetMesh.geometry.attributes.normal;\n\n\t// accumulate the normals in place in the normal buffer\n\tconst triangle = new THREE.Triangle();\n\ttriangles.forEach( tri => {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst i0 = tri3 + 0;\n\t\tconst i1 = tri3 + 1;\n\t\tconst i2 = tri3 + 2;\n\n\t\tconst v0 = indexAttr.getX( i0 );\n\t\tconst v1 = indexAttr.getX( i1 );\n\t\tconst v2 = indexAttr.getX( i2 );\n\n\t\ttriangle.a.fromBufferAttribute( posAttr, v0 );\n\t\ttriangle.b.fromBufferAttribute( posAttr, v1 );\n\t\ttriangle.c.fromBufferAttribute( posAttr, v2 );\n\t\ttriangle.getNormal( tempVec2 );\n\n\t\tif ( indices.has( v0 ) ) {\n\n\t\t\ttempVec.fromBufferAttribute( normalAttr, v0 );\n\t\t\ttempVec.add( tempVec2 );\n\t\t\tnormalAttr.setXYZ( v0, tempVec.x, tempVec.y, tempVec.z );\n\n\t\t}\n\n\t\tif ( indices.has( v1 ) ) {\n\n\t\t\ttempVec.fromBufferAttribute( normalAttr, v1 );\n\t\t\ttempVec.add( tempVec2 );\n\t\t\tnormalAttr.setXYZ( v1, tempVec.x, tempVec.y, tempVec.z );\n\n\t\t}\n\n\t\tif ( indices.has( v2 ) ) {\n\n\t\t\ttempVec.fromBufferAttribute( normalAttr, v2 );\n\t\t\ttempVec.add( tempVec2 );\n\t\t\tnormalAttr.setXYZ( v2, tempVec.x, tempVec.y, tempVec.z );\n\n\t\t}\n\n\t} );\n\n\t// normalize the accumulated normals\n\tindices.forEach( index => {\n\n\t\ttempVec.fromBufferAttribute( normalAttr, index );\n\t\ttempVec.normalize();\n\t\tnormalAttr.setXYZ( index, tempVec.x, tempVec.y, tempVec.z );\n\n\t} );\n\n\tnormalAttr.needsUpdate = true;\n\n}\n\nfunction render() {\n\n\tstats.begin();\n\n\tmaterial.matcap = matcaps[ params.matcap ];\n\n\tif ( controls.active || ! brushActive ) {\n\n\t\t// If the controls are being used then don't perform the strokes\n\t\tbrush.visible = false;\n\t\tsymmetryBrush.visible = false;\n\t\tlastCastPose.setScalar( Infinity );\n\n\t} else {\n\n\t\tconst raycaster = new THREE.Raycaster();\n\t\traycaster.setFromCamera( mouse, camera );\n\t\traycaster.firstHitOnly = true;\n\n\t\tconst hit = raycaster.intersectObject( targetMesh, true )[ 0 ];\n\t\t// if we hit the target mesh\n\t\tif ( hit ) {\n\n\t\t\tbrush.visible = true;\n\t\t\tbrush.scale.set( params.size, params.size, 0.1 );\n\t\t\tbrush.position.copy( hit.point );\n\n\t\t\tsymmetryBrush.visible = params.symmetrical;\n\t\t\tsymmetryBrush.scale.set( params.size, params.size, 0.1 );\n\t\t\tsymmetryBrush.position.copy( hit.point );\n\t\t\tsymmetryBrush.position.x *= - 1;\n\n\t\t\tcontrols.enabled = false;\n\n\t\t\t// if the last cast pose was missed in the last frame then set it to\n\t\t\t// the current point so we don't streak across the surface\n\t\t\tif ( lastCastPose.x === Infinity ) {\n\n\t\t\t\tlastCastPose.copy( hit.point );\n\n\t\t\t}\n\n\t\t\t// If the mouse isn't pressed don't perform the stroke\n\t\t\tif ( ! ( mouseState || lastMouseState ) ) {\n\n\t\t\t\tperformStroke( hit.point, brush, true );\n\t\t\t\tif ( params.symmetrical ) {\n\n\t\t\t\t\thit.point.x *= - 1;\n\t\t\t\t\tperformStroke( hit.point, symmetryBrush, true );\n\t\t\t\t\thit.point.x *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tlastMouse.copy( mouse );\n\t\t\t\tlastCastPose.copy( hit.point );\n\n\t\t\t} else {\n\n\t\t\t\t// compute the distance the mouse moved and that the cast point moved\n\t\t\t\tconst mdx = ( mouse.x - lastMouse.x ) * window.innerWidth * window.devicePixelRatio;\n\t\t\t\tconst mdy = ( mouse.y - lastMouse.y ) * window.innerHeight * window.devicePixelRatio;\n\t\t\t\tlet mdist = Math.sqrt( mdx * mdx + mdy * mdy );\n\t\t\t\tlet castDist = hit.point.distanceTo( lastCastPose );\n\n\t\t\t\tconst step = params.size * 0.15;\n\t\t\t\tconst percent = Math.max( step / castDist, 1 / params.maxSteps );\n\t\t\t\tconst mstep = mdist * percent;\n\t\t\t\tlet stepCount = 0;\n\n\t\t\t\t// perform multiple iterations toward the current mouse pose for a consistent stroke\n\t\t\t\t// TODO: recast here so he cursor is on the surface of the model which requires faster\n\t\t\t\t// refitting of the model\n\t\t\t\tconst changedTriangles = new Set();\n\t\t\t\tconst changedIndices = new Set();\n\t\t\t\tconst traversedNodeIndices = new Set();\n\t\t\t\tconst sets = {\n\n\t\t\t\t\taccumulatedTriangles: changedTriangles,\n\t\t\t\t\taccumulatedIndices: changedIndices,\n\t\t\t\t\taccumulatedTraversedNodeIndices: traversedNodeIndices,\n\n\t\t\t\t};\n\t\t\t\twhile ( castDist > step && mdist > params.size * 200 / hit.distance ) {\n\n\t\t\t\t\tlastMouse.lerp( mouse, percent );\n\t\t\t\t\tlastCastPose.lerp( hit.point, percent );\n\t\t\t\t\tcastDist -= step;\n\t\t\t\t\tmdist -= mstep;\n\n\t\t\t\t\tperformStroke( lastCastPose, brush, false, sets );\n\n\t\t\t\t\tif ( params.symmetrical ) {\n\n\t\t\t\t\t\tlastCastPose.x *= - 1;\n\t\t\t\t\t\tperformStroke( lastCastPose, symmetryBrush, false, sets );\n\t\t\t\t\t\tlastCastPose.x *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstepCount ++;\n\t\t\t\t\tif ( stepCount > params.maxSteps ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// refit the bounds and update the normals if we adjusted the mesh\n\t\t\t\tif ( stepCount > 0 ) {\n\n\t\t\t\t\t// refit bounds and normal updates could happen after every stroke\n\t\t\t\t\t// so it's up to date for the next one because both of those are used when updating\n\t\t\t\t\t// the model but it's faster to do them here.\n\t\t\t\t\tupdateNormals( changedTriangles, changedIndices );\n\t\t\t\t\ttargetMesh.geometry.boundsTree.refit( traversedNodeIndices );\n\n\t\t\t\t\tif ( bvhHelper.parent !== null ) {\n\n\t\t\t\t\t\tbvhHelper.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tperformStroke( hit.point, brush, true );\n\t\t\t\t\tif ( params.symmetrical ) {\n\n\t\t\t\t\t\thit.point.x *= - 1;\n\t\t\t\t\t\tperformStroke( hit.point, symmetryBrush, true );\n\t\t\t\t\t\thit.point.x *= - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if we didn't hit\n\t\t\tcontrols.enabled = true;\n\t\t\tbrush.visible = false;\n\t\t\tsymmetryBrush.visible = false;\n\t\t\tlastMouse.copy( mouse );\n\t\t\tlastCastPose.setScalar( Infinity );\n\n\t\t}\n\n\t}\n\n\tlastMouseState = mouseState;\n\n\trenderer.render( scene, camera );\n\tstats.end();\n\n}\n"],"names":["THREE.Mesh","acceleratedRaycast","THREE.BufferGeometry","computeBoundsTree","disposeBoundsTree","stats","scene","camera","renderer","controls","targetMesh","brush","symmetryBrush","bvhHelper","normalZ","THREE.Vector3","brushActive","mouse","THREE.Vector2","lastMouse","mouseState","lastMouseState","lastCastPose","material","rightClick","params","matcaps","init","reset","geometry","THREE.IcosahedronGeometry","BufferGeometryUtils.mergeVertices","THREE.DynamicDrawUsage","BVHHelper","THREE.WebGLRenderer","render","THREE.sRGBEncoding","THREE.Scene","THREE.Fog","light","THREE.DirectionalLight","THREE.AmbientLight","brushSegments","i","nexti","x1","y1","x2","y2","THREE.LineSegments","THREE.PerspectiveCamera","Stats","THREE.TextureLoader","THREE.MeshMatcapMaterial","key","gui","dat.GUI","sculptFolder","value","helperFolder","d","display","raycaster","THREE.Raycaster","res","delta","c","OrbitControls","performStroke","point","brushObject","brushOnly","accumulatedFields","accumulatedTriangles","accumulatedIndices","accumulatedTraversedNodeIndices","inverseMatrix","THREE.Matrix4","sphere","THREE.Sphere","indices","tempVec","normal","indexAttr","posAttr","normalAttr","triangles","box","isLeaf","score","depth","nodeIndex","intersects","min","max","x","y","z","INTERSECTED","CONTAINED","NOT_INTERSECTED","tri","index","contained","triIndex","i3","a","b","va","vb","vc","localPoint","planePoint","totalPoints","targetHeight","plane","THREE.Plane","dist","negated","intensity","planeDist","clampedIntensity","updateNormals","tempVec2","triangle","THREE.Triangle","tri3","i0","i1","i2","v0","v1","v2","hit","mdx","mdy","mdist","castDist","step","percent","mstep","stepCount","changedTriangles","changedIndices","traversedNodeIndices","sets"],"mappings":"6lBAeAA,GAAW,UAAU,QAAUC,GAC/BC,GAAqB,UAAU,kBAAoBC,GACnDD,GAAqB,UAAU,kBAAoBE,GAEnD,IAAIC,EACAC,EAAOC,EAAQC,EAAUC,EACzBC,EAAYC,EAAOC,EAAeC,EAClCC,GAAU,IAAIC,EAAe,EAAG,EAAG,CAAC,EACpCC,EAAc,GACdC,EAAQ,IAAIC,GAAiBC,EAAY,IAAID,GAC7CE,EAAa,GAAOC,GAAiB,GACrCC,EAAe,IAAIP,EACnBQ,EAAUC,GAAa,GAE3B,MAAMC,EAAS,CACd,OAAQ,OAER,KAAM,GACN,MAAO,OACP,UAAW,GACX,SAAU,GACV,OAAQ,GACR,YAAa,GACb,YAAa,GAEb,MAAO,GACP,WAAY,EACb,EAEMC,EAAU,CAAA,EAEhBC,GAAI,EAGJ,SAASC,IAAQ,CAGXlB,IAEJA,EAAW,SAAS,QAAO,EAC3BA,EAAW,SAAS,QAAO,EAC3BJ,EAAM,OAAQI,CAAU,GAKzB,IAAImB,EAAW,IAAIC,GAA2B,EAAG,GAAG,EACpDD,EAAS,gBAAiB,IAAI,EAC9BA,EAAWE,GAAmCF,CAAQ,EACtDA,EAAS,WAAW,SAAS,SAAUG,CAAsB,EAC7DH,EAAS,WAAW,OAAO,SAAUG,CAAsB,EAC3DH,EAAS,kBAAmB,CAAE,eAAgB,EAAK,CAAE,EAGrDnB,EAAa,IAAIV,GAChB6B,EACAN,CACF,EACCb,EAAW,cAAgB,GAC3BJ,EAAM,IAAKI,CAAU,EAGdG,IAENA,EAAY,IAAIoB,GAAWvB,EAAYe,EAAO,KAAK,EAC9CA,EAAO,YAEXnB,EAAM,IAAKO,CAAS,GAMtBA,EAAU,KAAOH,EACjBG,EAAU,OAAM,CAEjB,CAEA,SAASc,IAAO,CAKfnB,EAAW,IAAI0B,GAAqB,CAAE,UAAW,EAAI,CAAE,EACvD1B,EAAS,cAAe,OAAO,gBAAgB,EAC/CA,EAAS,QAAS,OAAO,WAAY,OAAO,WAAW,EACvDA,EAAS,cAAe,OAAS,CAAC,EAClCA,EAAS,iBAAkB2B,EAAM,EACjC3B,EAAS,eAAiB4B,OAC1B,SAAS,KAAK,YAAa5B,EAAS,UAAU,EAC9CA,EAAS,WAAW,MAAM,YAAc,OAGxCF,EAAQ,IAAI+B,GACZ/B,EAAM,IAAM,IAAIgC,GAAW,QAAW,EAAG,GAAI,EAAE,EAE/C,MAAMC,EAAQ,IAAIC,GAAwB,SAAU,EAAG,EACvDD,EAAM,SAAS,IAAK,EAAG,EAAG,CAAC,EAC3BjC,EAAM,IAAKiC,CAAK,EAChBjC,EAAM,IAAK,IAAImC,GAAoB,SAAU,EAAG,CAAE,EAGlD,MAAMC,EAAgB,CAAE,IAAI3B,EAAiB,IAAIA,EAAe,EAAG,EAAG,EAAG,EACzE,QAAU4B,EAAI,EAAGA,EAAI,GAAIA,IAAO,CAE/B,MAAMC,EAAQD,EAAI,EACZE,EAAK,KAAK,IAAK,EAAI,KAAK,GAAKF,EAAI,EAAE,EACnCG,EAAK,KAAK,IAAK,EAAI,KAAK,GAAKH,EAAI,EAAE,EAEnCI,EAAK,KAAK,IAAK,EAAI,KAAK,GAAKH,EAAQ,EAAE,EACvCI,EAAK,KAAK,IAAK,EAAI,KAAK,GAAKJ,EAAQ,EAAE,EAE7CF,EAAc,KACb,IAAI3B,EAAe8B,EAAIC,EAAI,CAAC,EAC5B,IAAI/B,EAAegC,EAAIC,EAAI,CAAC,CAC/B,CAEC,CAEArC,EAAQ,IAAIsC,GACZtC,EAAM,SAAS,cAAe+B,CAAa,EAC3C/B,EAAM,SAAS,MAAM,IAAK,QAAQ,EAClCL,EAAM,IAAKK,CAAK,EAEhBC,EAAgBD,EAAM,MAAK,EAC3BL,EAAM,IAAKM,CAAa,EAGxBL,EAAS,IAAI2C,GAAyB,GAAI,OAAO,WAAa,OAAO,YAAa,GAAK,EAAE,EACzF3C,EAAO,SAAS,IAAK,EAAG,EAAG,CAAC,EAC5BA,EAAO,IAAM,IACbA,EAAO,uBAAsB,EAG7BF,EAAQ,IAAI8C,GACZ,SAAS,KAAK,YAAa9C,EAAM,GAAG,EAGpCqB,EAAS,KAAW,IAAI0B,EAAmB,EAAG,KAAM,mDAAmD,EACvG1B,EAAS,SAAS,EAAK,IAAI0B,EAAmB,EAAG,KAAM,mDAAmD,EAC1G1B,EAAS,aAAa,EAAK,IAAI0B,EAAmB,EAAG,KAAM,mDAAmD,EAC9G1B,EAAS,OAAa,IAAI0B,EAAmB,EAAG,KAAM,mDAAmD,EACzG7B,EAAW,IAAI8B,GAA0B,CACxC,YAAa5B,EAAO,WACtB,CAAE,EAED,UAAY6B,KAAO5B,EAElBA,EAAS4B,GAAM,SAAWlB,OAK3BR,GAAK,EAEL,MAAM2B,EAAM,IAAIC,GAChBD,EAAI,IAAK9B,EAAQ,SAAU,OAAO,KAAMC,EAAS,EAEjD,MAAM+B,EAAeF,EAAI,UAAW,WAAW,EAC/CE,EAAa,IAAKhC,EAAQ,QAAS,CAAE,SAAU,OAAQ,UAAW,EAClEgC,EAAa,IAAKhC,EAAQ,MAAM,EAAG,IAAK,IAAK,EAAG,IAAK,KAAO,KAAM,IAAK,EACvEgC,EAAa,IAAKhC,EAAQ,WAAW,EAAG,IAAK,CAAC,EAAG,IAAK,KAAM,KAAM,CAAC,EACnEgC,EAAa,IAAKhC,EAAQ,UAAU,EAAG,IAAK,CAAC,EAAG,IAAK,IAAK,KAAM,CAAC,EACjEgC,EAAa,IAAKhC,EAAQ,aAAa,EACvCgC,EAAa,IAAKhC,EAAQ,QAAQ,EAClCgC,EAAa,IAAKhC,EAAQ,aAAa,EAAG,SAAUiC,GAAS,CAE5DhD,EAAW,SAAS,YAAcgD,EAClChD,EAAW,SAAS,YAAc,EAEnC,CAAC,EACD+C,EAAa,KAAI,EAEjB,MAAME,EAAeJ,EAAI,UAAW,YAAY,EAChDI,EAAa,IAAKlC,EAAQ,OAAO,EAAG,IAAK,CAAC,EAAG,IAAK,EAAE,EAAG,KAAM,CAAC,EAAG,SAAUmC,GAAK,CAE/E/C,EAAU,MAAQ,WAAY+C,CAAC,EAC/B/C,EAAU,OAAM,CAEjB,CAAC,EACD8C,EAAa,IAAKlC,EAAQ,YAAY,EAAG,SAAUoC,GAAW,CAExDA,GAEJvD,EAAM,IAAKO,CAAS,EACpBA,EAAU,OAAM,GAIhBP,EAAM,OAAQO,CAAS,CAIzB,CAAC,EACD8C,EAAa,KAAI,EAEjBJ,EAAI,IAAK,CAAE,MAAA3B,EAAK,EAAI,OAAO,EAC3B2B,EAAI,IAAK,CAAE,WAAY,IAAM,CAI5B7C,EAAW,SAAS,kBAAmB,CAAE,eAAgB,EAAK,CAAE,EAChEG,EAAU,OAAM,CAEjB,CAAC,EAAI,YAAY,EACjB0C,EAAI,KAAI,EAER,OAAO,iBAAkB,SAAU,UAAY,CAE9ChD,EAAO,OAAS,OAAO,WAAa,OAAO,YAC3CA,EAAO,uBAAsB,EAE7BC,EAAS,QAAS,OAAO,WAAY,OAAO,WAAW,CAExD,EAAG,EAAK,EAER,OAAO,iBAAkB,cAAe,SAAW,EAAI,CAEtDS,EAAM,EAAM,EAAE,QAAU,OAAO,WAAe,EAAI,EAClDA,EAAM,EAAI,EAAI,EAAE,QAAU,OAAO,aAAgB,EAAI,EACrDD,EAAc,EAEf,CAAC,EAED,OAAO,iBAAkB,cAAe,GAAK,CAE5CC,EAAM,EAAM,EAAE,QAAU,OAAO,WAAe,EAAI,EAClDA,EAAM,EAAI,EAAI,EAAE,QAAU,OAAO,aAAgB,EAAI,EACrDG,EAAa,GAAS,EAAE,QAAU,GAClCI,GAAa,GAAS,EAAE,QAAU,GAClCR,EAAc,GAEd,MAAM8C,EAAY,IAAIC,GACtBD,EAAU,cAAe7C,EAAOV,CAAM,EACtCuD,EAAU,aAAe,GAEzB,MAAME,EAAMF,EAAU,gBAAiBpD,CAAU,EACjDD,EAAS,QAAUuD,EAAI,SAAW,CAEnC,EAAG,EAAI,EAEP,OAAO,iBAAkB,YAAa,GAAK,CAE1C5C,EAAa,GAAS,EAAE,QAAU,GAC7B,EAAE,cAAgB,UAEtBJ,EAAc,GAIhB,CAAC,EAED,OAAO,iBAAkB,cAAe,SAAW,EAAI,CAEtD,EAAE,eAAc,CAEjB,CAAC,EAED,OAAO,iBAAkB,QAAS,SAAW,EAAI,CAEhD,IAAIiD,EAAQ,EAAE,OAET,EAAE,YAAc,IAEpBA,GAAS,IAIL,EAAE,YAAc,IAEpBA,GAAS,IAIVxC,EAAO,MAAQwC,EAAQ,KACvBxC,EAAO,KAAO,KAAK,IAAK,KAAK,IAAKA,EAAO,KAAM,GAAI,EAAI,IAAK,EAC5D8B,EAAI,qBAAoB,EAAG,QAASW,GAAKA,EAAE,eAAe,CAE3D,CAAC,EAEDzD,EAAW,IAAI0D,GAAe5D,EAAQC,EAAS,UAAU,EACzDC,EAAS,YAAc,IAEvBA,EAAS,iBAAkB,QAAS,UAAY,CAE/C,KAAK,OAAS,EAEf,CAAC,EAEDA,EAAS,iBAAkB,MAAO,UAAY,CAE7C,KAAK,OAAS,EAEf,CAAC,CAEF,CAGA,SAAS2D,EAAeC,EAAOC,EAAaC,EAAY,GAAOC,EAAoB,GAAK,CAEvF,KAAM,CACL,qBAAAC,EAAuB,IAAI,IAC3B,mBAAAC,EAAqB,IAAI,IACzB,gCAAAC,EAAkC,IAAI,GACxC,EAAKH,EAEEI,EAAgB,IAAIC,GAC1BD,EAAc,KAAMlE,EAAW,WAAW,EAAG,OAAM,EAEnD,MAAMoE,EAAS,IAAIC,GACnBD,EAAO,OAAO,KAAMT,CAAK,EAAG,aAAcO,CAAa,EACvDE,EAAO,OAASrD,EAAO,KAGvB,MAAMuD,EAAU,IAAI,IACdC,EAAU,IAAIlE,EACdmE,EAAS,IAAInE,EACboE,EAAYzE,EAAW,SAAS,MAChC0E,EAAU1E,EAAW,SAAS,WAAW,SACzC2E,EAAa3E,EAAW,SAAS,WAAW,OAC5C4E,EAAY,IAAI,IACV5E,EAAW,SAAS,WAC5B,UAAW,CAEd,iBAAkB,CAAE6E,EAAKC,EAAQC,EAAOC,EAAOC,IAAe,CAE7DhB,EAAgC,IAAKgB,CAAS,EAE9C,MAAMC,EAAad,EAAO,cAAeS,CAAG,EACtC,CAAE,IAAAM,EAAK,IAAAC,CAAG,EAAKP,EACrB,GAAKK,EAAa,CAEjB,QAAUG,EAAI,EAAGA,GAAK,EAAGA,IAExB,QAAUC,EAAI,EAAGA,GAAK,EAAGA,IAExB,QAAUC,EAAI,EAAGA,GAAK,EAAGA,IAOxB,GALAhB,EAAQ,IACPc,IAAM,EAAIF,EAAI,EAAIC,EAAI,EACtBE,IAAM,EAAIH,EAAI,EAAIC,EAAI,EACtBG,IAAM,EAAIJ,EAAI,EAAIC,EAAI,CAC9B,EACY,CAAEhB,EAAO,cAAeG,GAE5B,OAAOiB,EAUX,OAAOC,EAER,CAEA,OAAOP,EAAaM,EAAcE,EAEnC,EAEA,mBAAoB,CAAEC,EAAKC,EAAOC,IAAe,CAEhD,MAAMC,EAAWF,EACjBhB,EAAU,IAAKkB,CAAQ,EACvB/B,EAAqB,IAAK+B,CAAQ,EAElC,MAAMC,EAAK,EAAIH,EACTI,EAAID,EAAK,EACTE,EAAIF,EAAK,EACTvC,EAAIuC,EAAK,EACTG,EAAKzB,EAAU,KAAMuB,CAAC,EACtBG,EAAK1B,EAAU,KAAMwB,CAAC,EACtBG,EAAK3B,EAAU,KAAMjB,CAAC,EAC5B,OAAKqC,GAEJvB,EAAQ,IAAK4B,CAAE,EACf5B,EAAQ,IAAK6B,CAAE,EACf7B,EAAQ,IAAK8B,CAAE,EAEfpC,EAAmB,IAAKkC,CAAE,EAC1BlC,EAAmB,IAAKmC,CAAE,EAC1BnC,EAAmB,IAAKoC,CAAE,IAIrBhC,EAAO,cAAeuB,EAAI,CAAC,IAE/BrB,EAAQ,IAAK4B,CAAE,EACflC,EAAmB,IAAKkC,CAAE,GAItB9B,EAAO,cAAeuB,EAAI,CAAC,IAE/BrB,EAAQ,IAAK6B,CAAE,EACfnC,EAAmB,IAAKmC,CAAE,GAItB/B,EAAO,cAAeuB,EAAI,CAAC,IAE/BrB,EAAQ,IAAK8B,CAAE,EACfpC,EAAmB,IAAKoC,CAAE,IAMrB,EAER,CAEF,CAAE,EAGD,MAAMC,EAAa,IAAIhG,EACvBgG,EAAW,KAAM1C,GAAQ,aAAcO,CAAa,EAEpD,MAAMoC,EAAa,IAAIjG,EACvB,IAAIkG,EAAc,EA2BlB,GA1BAjC,EAAQ,QAASsB,GAAS,CAEzBrB,EAAQ,oBAAqBI,EAAYiB,CAAK,EAC9CpB,EAAO,IAAKD,CAAO,EAIZV,IAEN0C,IACAhC,EAAQ,oBAAqBG,EAASkB,CAAK,EAC3CU,EAAW,IAAK/B,CAAO,EAIzB,CAAC,EACDC,EAAO,UAAS,EAChBZ,EAAY,WAAW,mBAAoBxD,GAASoE,CAAM,EAErD+B,GAEJD,EAAW,eAAgB,EAAIC,CAAW,EAKtC1C,EAEJ,OAKD,MAAM2C,EAAezF,EAAO,UAAY,KAClC0F,EAAQ,IAAIC,GAClBD,EAAM,8BAA+BjC,EAAQ8B,CAAU,EAEvDhC,EAAQ,QAASsB,GAAS,CAEzBrB,EAAQ,oBAAqBG,EAASkB,CAAK,EAG3C,MAAMe,EAAOpC,EAAQ,WAAY8B,CAAU,EACrCO,EAAU7F,EAAO,SAAWD,GAAa,GAAM,EACrD,IAAI+F,EAAY,EAAQF,EAAO5F,EAAO,KAGtC,GAAKA,EAAO,QAAU,OAAS,CAE9B8F,EAAY,KAAK,IAAKA,EAAW,CAAC,EAClC,MAAMC,EAAYL,EAAM,gBAAiBlC,CAAO,EAC1CwC,EAAmBH,EAAU,KAAK,IAAKC,EAAY,EAAG,CAAG,EAC/DtC,EAAQ,gBAAiBC,EAAQuC,EAAmBP,EAAeI,EAAUE,EAAYC,EAAmB,EAAG,CAEhH,SAAYhG,EAAO,QAAU,SAE5B8F,EAAY,KAAK,IAAKA,EAAW,CAAC,EAClCtC,EAAQ,gBAAiBC,EAAQoC,EAAUC,EAAYL,CAAY,UAExDzF,EAAO,QAAU,UAAY,CAExC8F,EAAY,KAAK,IAAKA,EAAW,CAAC,EAElC,MAAMC,EAAYL,EAAM,gBAAiBlC,CAAO,EAChDA,EAAQ,gBAAiBC,EAAQ,CAAEsC,EAAYD,EAAY9F,EAAO,UAAY,IAAO,EAAG,CAEzF,CAEA2D,EAAQ,OAAQkB,EAAOrB,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,CAAC,EACtDI,EAAW,OAAQiB,EAAO,EAAG,EAAG,CAAC,CAElC,CAAC,EAGItB,EAAQ,OAEZI,EAAQ,YAAc,GAIxB,CAEA,SAASsC,GAAepC,EAAWN,EAAU,CAE5C,MAAMC,EAAU,IAAIlE,EACd4G,EAAW,IAAI5G,EACfoE,EAAYzE,EAAW,SAAS,MAChC0E,EAAU1E,EAAW,SAAS,WAAW,SACzC2E,EAAa3E,EAAW,SAAS,WAAW,OAG5CkH,EAAW,IAAIC,GACrBvC,EAAU,QAASe,GAAO,CAEzB,MAAMyB,EAAOzB,EAAM,EACb0B,EAAKD,EAAO,EACZE,EAAKF,EAAO,EACZG,EAAKH,EAAO,EAEZI,EAAK/C,EAAU,KAAM4C,CAAE,EACvBI,EAAKhD,EAAU,KAAM6C,CAAE,EACvBI,EAAKjD,EAAU,KAAM8C,CAAE,EAE7BL,EAAS,EAAE,oBAAqBxC,EAAS8C,CAAE,EAC3CN,EAAS,EAAE,oBAAqBxC,EAAS+C,CAAE,EAC3CP,EAAS,EAAE,oBAAqBxC,EAASgD,CAAE,EAC3CR,EAAS,UAAWD,CAAQ,EAEvB3C,EAAQ,IAAKkD,KAEjBjD,EAAQ,oBAAqBI,EAAY6C,CAAE,EAC3CjD,EAAQ,IAAK0C,CAAQ,EACrBtC,EAAW,OAAQ6C,EAAIjD,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,CAAC,GAIlDD,EAAQ,IAAKmD,KAEjBlD,EAAQ,oBAAqBI,EAAY8C,CAAE,EAC3ClD,EAAQ,IAAK0C,CAAQ,EACrBtC,EAAW,OAAQ8C,EAAIlD,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,CAAC,GAIlDD,EAAQ,IAAKoD,KAEjBnD,EAAQ,oBAAqBI,EAAY+C,CAAE,EAC3CnD,EAAQ,IAAK0C,CAAQ,EACrBtC,EAAW,OAAQ+C,EAAInD,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,CAAC,EAIxD,CAAC,EAGDD,EAAQ,QAASsB,GAAS,CAEzBrB,EAAQ,oBAAqBI,EAAYiB,CAAK,EAC9CrB,EAAQ,UAAS,EACjBI,EAAW,OAAQiB,EAAOrB,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,CAAC,CAE1D,CAAC,EAEDI,EAAW,YAAc,EAE1B,CAEA,SAASlD,IAAS,CAMjB,GAJA9B,EAAM,MAAK,EAEXkB,EAAS,OAASG,EAASD,EAAO,MAAM,EAEnChB,EAAS,QAAU,CAAEO,EAGzBL,EAAM,QAAU,GAChBC,EAAc,QAAU,GACxBU,EAAa,UAAW,GAAQ,MAE1B,CAEN,MAAMwC,EAAY,IAAIC,GACtBD,EAAU,cAAe7C,EAAOV,CAAM,EACtCuD,EAAU,aAAe,GAEzB,MAAMuE,EAAMvE,EAAU,gBAAiBpD,EAAY,EAAI,EAAI,CAAC,EAE5D,GAAK2H,EAsBJ,GApBA1H,EAAM,QAAU,GAChBA,EAAM,MAAM,IAAKc,EAAO,KAAMA,EAAO,KAAM,EAAG,EAC9Cd,EAAM,SAAS,KAAM0H,EAAI,KAAK,EAE9BzH,EAAc,QAAUa,EAAO,YAC/Bb,EAAc,MAAM,IAAKa,EAAO,KAAMA,EAAO,KAAM,EAAG,EACtDb,EAAc,SAAS,KAAMyH,EAAI,KAAK,EACtCzH,EAAc,SAAS,GAAK,GAE5BH,EAAS,QAAU,GAIda,EAAa,IAAM,KAEvBA,EAAa,KAAM+G,EAAI,KAAK,EAKxB,EAAIjH,GAAcC,IAEtB+C,EAAeiE,EAAI,MAAO1H,EAAO,EAAI,EAChCc,EAAO,cAEX4G,EAAI,MAAM,GAAK,GACfjE,EAAeiE,EAAI,MAAOzH,EAAe,EAAI,EAC7CyH,EAAI,MAAM,GAAK,IAIhBlH,EAAU,KAAMF,CAAK,EACrBK,EAAa,KAAM+G,EAAI,KAAK,MAEtB,CAGN,MAAMC,GAAQrH,EAAM,EAAIE,EAAU,GAAM,OAAO,WAAa,OAAO,iBAC7DoH,GAAQtH,EAAM,EAAIE,EAAU,GAAM,OAAO,YAAc,OAAO,iBACpE,IAAIqH,EAAQ,KAAK,KAAMF,EAAMA,EAAMC,EAAMA,CAAG,EACxCE,EAAWJ,EAAI,MAAM,WAAY/G,CAAY,EAEjD,MAAMoH,EAAOjH,EAAO,KAAO,IACrBkH,EAAU,KAAK,IAAKD,EAAOD,EAAU,EAAIhH,EAAO,QAAQ,EACxDmH,EAAQJ,EAAQG,EACtB,IAAIE,EAAY,EAKhB,MAAMC,EAAmB,IAAI,IACvBC,EAAiB,IAAI,IACrBC,EAAuB,IAAI,IAC3BC,EAAO,CAEZ,qBAAsBH,EACtB,mBAAoBC,EACpB,gCAAiCC,CAEtC,EACI,KAAQP,EAAWC,GAAQF,EAAQ/G,EAAO,KAAO,IAAM4G,EAAI,WAE1DlH,EAAU,KAAMF,EAAO0H,CAAO,EAC9BrH,EAAa,KAAM+G,EAAI,MAAOM,CAAO,EACrCF,GAAYC,EACZF,GAASI,EAETxE,EAAe9C,EAAcX,EAAO,GAAOsI,CAAI,EAE1CxH,EAAO,cAEXH,EAAa,GAAK,GAClB8C,EAAe9C,EAAcV,EAAe,GAAOqI,CAAI,EACvD3H,EAAa,GAAK,IAInBuH,IACK,EAAAA,EAAYpH,EAAO,YAAxB,CASIoH,EAAY,GAKhBnB,GAAeoB,EAAkBC,CAAc,EAC/CrI,EAAW,SAAS,WAAW,MAAOsI,CAAoB,EAErDnI,EAAU,SAAW,MAEzBA,EAAU,OAAM,IAMjBuD,EAAeiE,EAAI,MAAO1H,EAAO,EAAI,EAChCc,EAAO,cAEX4G,EAAI,MAAM,GAAK,GACfjE,EAAeiE,EAAI,MAAOzH,EAAe,EAAI,EAC7CyH,EAAI,MAAM,GAAK,IAMlB,MAKA5H,EAAS,QAAU,GACnBE,EAAM,QAAU,GAChBC,EAAc,QAAU,GACxBO,EAAU,KAAMF,CAAK,EACrBK,EAAa,UAAW,GAAQ,CAIlC,CAEAD,GAAiBD,EAEjBZ,EAAS,OAAQF,EAAOC,CAAM,EAC9BF,EAAM,IAAG,CAEV"}