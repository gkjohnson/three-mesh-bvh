{"version":3,"file":"cpuPathTracing-BY8gx54g.js","sources":["../../pathtracing/utils.js","../../pathtracing/ggxSampling.js","../../pathtracing/materialSampling.js","../../cpuPathTracing.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nconst tempVector = new Vector3();\nconst tempVector1 = new Vector3();\nconst tempVector2 = new Vector3();\n\nexport const EPSILON = 1e-7;\n\n// https://docs.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\nexport const ANTIALIAS_WIDTH = 16;\nexport const ANTIALIAS_OFFSETS = [\n\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ],\n];\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\nexport function schlickFresnel( cosine, f0 ) {\n\n\treturn f0 + ( 1.0 - f0 ) * Math.pow( 1.0 - cosine, 5.0 );\n\n}\n\n// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\nexport function schlickFresnelFromIor( cosine, iorRatio ) {\n\n\t// Schlick approximation\n\tconst r0 = Math.pow( ( 1 - iorRatio ) / ( 1 + iorRatio ), 2 );\n\treturn schlickFresnel( cosine, r0 );\n\n}\n\nexport function refract( dir, norm, iorRatio, target ) {\n\n\t// snell's law\n\t// ior1 * sin( t1 ) = ior2 * sin( t2 )\n\tlet cosTheta = Math.min( - dir.dot( norm ), 1.0 );\n\n\ttempVector\n\t\t.copy( dir )\n\t\t.addScaledVector( norm, cosTheta )\n\t\t.multiplyScalar( iorRatio );\n\n\ttarget\n\t\t.copy( norm )\n\t\t.multiplyScalar( - Math.sqrt( Math.abs( 1.0 - tempVector.lengthSq() ) ) )\n\t\t.add( tempVector );\n\n}\n\n// forms a basis with the normal vector as Z\nexport function getBasisFromNormal( normal, targetMatrix ) {\n\n\tif ( Math.abs( normal.x ) > 0.5 ) {\n\n\t\ttempVector.set( 0, 1, 0 );\n\n\t} else {\n\n\t\ttempVector.set( 1, 0, 0 );\n\n\t}\n\n\ttempVector1.crossVectors( normal, tempVector ).normalize();\n\ttempVector2.crossVectors( normal, tempVector1 ).normalize();\n\ttargetMatrix.makeBasis( tempVector2, tempVector1, normal );\n\n}\n\nexport function getHalfVector( a, b, target ) {\n\n\treturn target.addVectors( a, b ).normalize();\n\n}\n\n// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n// we find a ray like that we ignore it to avoid artifacts.\n// This function returns if the direction is on the same side of both planes.\nexport function isDirectionValid( direction, surfaceNormal, geometryNormal ) {\n\n\tconst aboveSurfaceNormal = direction.dot( surfaceNormal ) > 0;\n\tconst aboveGeometryNormal = direction.dot( geometryNormal ) > 0;\n\treturn aboveSurfaceNormal === aboveGeometryNormal;\n\n}\n","import { Vector3 } from 'three';\n\nconst _V = new Vector3();\nconst _T1 = new Vector3();\nconst _T2 = new Vector3();\nconst _N = new Vector3();\nconst _Z_VECTOR = new Vector3( 0, 0, 1 );\nconst M_PI = Math.PI;\n\n// The GGX functions provide sampling and distribution information for normals as output so\n// in order to get probability of scatter direction the half vector must be computed and provided.\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n// [2] http://jcgt.org/published/0007/04/01/\n// [4] http://jcgt.org/published/0003/02/03/\n\nexport function ggxDirection( incidentDir, roughnessX, roughnessY, random1, random2, target ) {\n\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t// function below, as well\n\n\t// Implementation from reference [1]\n\t// stretch view\n\tconst V = _V.set( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ).normalize();\n\n\t// orthonormal basis\n\tconst T1 = ( V.z < 0.9999 ) ? _T1.crossVectors( V, _Z_VECTOR ).normalize() : _T1.set( 1, 0, 0 );\n\tconst T2 = _T2.crossVectors( T1, V );\n\n\t// sample point with polar coordinates (r, phi)\n\tconst a = 1.0 / ( 1.0 + V.z );\n\tconst r = Math.sqrt( random1 );\n\tconst phi = ( random2 < a ) ? random2 / a * M_PI : M_PI + ( random2 - a ) / ( 1.0 - a ) * M_PI;\n\tconst P1 = r * Math.cos( phi );\n\tconst P2 = r * Math.sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\n\n\t// compute normal\n\tT1.multiplyScalar( P1 );\n\tT2.multiplyScalar( P2 );\n\tconst N = _N.addVectors( T1, T2 ).addScaledVector( V, Math.sqrt( Math.max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) ) );\n\n\t// unstretch\n\tN.x *= roughnessX;\n\tN.y *= roughnessY;\n\tN.z = Math.max( 0.0, N.z );\n\tN.normalize();\n\n\ttarget.copy( N );\n\n\treturn target;\n\n}\n\n// Below are PDF and related functions for use in a Monte Carlo path tracer\n// as specified in Appendix B of the following paper\n// See equation (2) from reference [2]\nfunction ggxLamda( theta, roughness ) {\n\n\tconst tanTheta = Math.tan( theta );\n\tconst tanTheta2 = tanTheta * tanTheta;\n\tconst alpha2 = roughness * roughness;\n\n\tconst numerator = - 1 + Math.sqrt( 1 + alpha2 * tanTheta2 );\n\treturn numerator / 2;\n\n}\n\n// See equation (2) from reference [2]\nexport function ggxShadowMaskG1( theta, roughness ) {\n\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n}\n\n// See equation (125) from reference [4]\nexport function ggxShadowMaskG2( wi, wo, roughness ) {\n\n\tconst incidentTheta = Math.acos( wi.z );\n\tconst scatterTheta = Math.acos( wo.z );\n\treturn 1.0 / ( 1 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n}\n\nexport function ggxDistribution( halfVector, roughness ) {\n\n\t// See equation (33) from reference [0]\n\tconst a2 = roughness * roughness;\n\tconst cosTheta = halfVector.z;\n\tconst cosTheta4 = Math.pow( cosTheta, 4 );\n\n\tif ( cosTheta === 0 ) return 0;\n\n\tconst theta = Math.acos( halfVector.z );\n\tconst tanTheta = Math.tan( theta );\n\tconst tanTheta2 = Math.pow( tanTheta, 2 );\n\n\tconst denom = Math.PI * cosTheta4 * Math.pow( a2 + tanTheta2, 2 );\n\treturn a2 / denom;\n\n\t// See equation (1) from reference [2]\n\t// const { x, y, z } = halfVector;\n\t// const a2 = roughness * roughness;\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\n\t// const mult2 = mult * mult;\n\n\t// return 1.0 / Math.PI * a2 * mult2;\n\n}\n\n// See equation (3) from reference [2]\nexport function ggxPDF( wi, halfVector, roughness ) {\n\n\tconst incidentTheta = Math.acos( wi.z );\n\tconst D = ggxDistribution( halfVector, roughness );\n\tconst G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\treturn D * G1 * Math.max( 0.0, wi.dot( halfVector ) ) / wi.z;\n\n}\n","import { schlickFresnelFromIor, refract, getHalfVector } from './utils.js';\nimport { ggxDirection, ggxPDF, ggxShadowMaskG2, ggxDistribution } from './ggxSampling.js';\nimport { MathUtils, Vector3, Color } from 'three';\n\n// Technically this value should be based on the index of refraction of the given dielectric.\nconst tempDir = new Vector3();\nconst halfVector = new Vector3();\nconst tempColor = new Color();\nconst whiteColor = new Color( 0xffffff );\n\n// diffuse\nfunction diffusePDF( wo, wi, material, hit ) {\n\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\n\tconst cosValue = wi.z;\n\treturn cosValue / Math.PI;\n\n}\n\nfunction diffuseDirection( wo, hit, material, lightDirection ) {\n\n\tlightDirection.randomDirection();\n\tlightDirection.z += 1;\n\tlightDirection.normalize();\n\n}\n\nfunction diffuseColor( wo, wi, material, hit, colorTarget ) {\n\n\t// TODO: scale by 1 - F here\n\t// note on division by PI\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wi.z / Math.PI / Math.PI )\n\t\t.multiplyScalar( 1.0 - transmission );\n\n}\n\n// specular\nfunction specularPDF( wo, wi, material, hit ) {\n\n\t// See equation (17) in http://jcgt.org/published/0003/02/03/\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\tgetHalfVector( wi, wo, halfVector );\n\treturn ggxPDF( wi, halfVector, filteredRoughness ) / ( 4 * wi.dot( halfVector ) );\n\n}\n\nfunction specularDirection( wo, hit, material, lightDirection ) {\n\n\t// sample ggx vndf distribution which gives a new normal\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\tggxDirection(\n\t\two,\n\t\tfilteredRoughness,\n\t\tfilteredRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\tlightDirection.copy( wo ).reflect( halfVector ).multiplyScalar( - 1 );\n\n}\n\nfunction specularColor( wo, wi, material, hit, colorTarget ) {\n\n\t// if roughness is set to 0 then D === NaN which results in black pixels\n\tconst { metalness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst filteredRoughness = hit.filteredSurfaceRoughness;\n\n\tgetHalfVector( wo, wi, halfVector );\n\tconst iorRatio = frontFace ? 1 / ior : ior;\n\tconst G = ggxShadowMaskG2( wi, wo, filteredRoughness );\n\tconst D = ggxDistribution( halfVector, filteredRoughness );\n\n\tlet F = schlickFresnelFromIor( wi.dot( halfVector ), iorRatio );\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tconst cannotRefract = iorRatio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\tF = 1;\n\n\t}\n\n\tcolorTarget\n\t\t.lerpColors( whiteColor, material.color, metalness )\n\t\t.multiplyScalar( G * D / ( 4 * Math.abs( wi.z * wo.z ) ) )\n\t\t.multiplyScalar( MathUtils.lerp( F, 1.0, metalness ) )\n\t\t.multiplyScalar( wi.z ); // scale the light by the direction the light is coming in from\n\n}\n\n/*\n// transmission\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? ior : 1 / ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\n\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\n\n\t// sample ggx vndf distribution which gives a new normal\n\tggxDirection(\n\t\two,\n\t\tminRoughness,\n\t\tminRoughness,\n\t\tMath.random(),\n\t\tMath.random(),\n\t\thalfVector,\n\t);\n\n\t// apply to new ray by reflecting off the new normal\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, halfVector, ratio, lightDirection );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\n\t\t.multiplyScalar( transmission );\n\n}\n*/\n\n// TODO: This is just using a basic cosine-weighted specular distribution with an\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\nfunction transmissionPDF( wo, wi, material, hit ) {\n\n\tconst { ior } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treturn 0.0;\n\n\t}\n\n\treturn 1.0 / ( 1.0 - reflectance );\n\n}\n\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\n\n\tconst { roughness, ior } = material;\n\tconst { frontFace } = hit;\n\tconst ratio = frontFace ? 1 / ior : ior;\n\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\n\trefract( tempDir, new Vector3( 0, 0, 1 ), ratio, lightDirection );\n\ttempDir.randomDirection().multiplyScalar( roughness );\n\tlightDirection.add( tempDir );\n\n}\n\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\n\n\tconst { metalness, transmission } = material;\n\tcolorTarget\n\t\t.copy( material.color )\n\t\t.multiplyScalar( 1.0 - metalness )\n\t\t.multiplyScalar( transmission );\n\n}\n\nexport function bsdfPdf( wo, wi, material, hit ) {\n\n\tconst { ior, metalness, transmission } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1;\n\n\t}\n\n\tlet spdf = 0;\n\tlet dpdf = 0;\n\tlet tpdf = 0;\n\n\tif ( wi.z < 0 ) {\n\n\t\ttpdf = transmissionPDF( wo, wi, material, hit );\n\n\t} else {\n\n\t\tspdf = specularPDF( wo, wi, material, hit );\n\t\tdpdf = diffusePDF( wo, wi, material, hit );\n\n\t}\n\n\tconst transSpecularProb = MathUtils.lerp( reflectance, 1.0, metalness );\n\tconst diffSpecularProb = 0.5 + 0.5 * metalness;\n\tconst pdf =\n\t\tspdf * transmission * transSpecularProb\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\n\treturn pdf;\n\n}\n\nexport function bsdfColor( wo, wi, material, hit, targetColor ) {\n\n\tif ( wi.z < 0 ) {\n\n\t\ttransmissionColor( wo, wi, material, hit, targetColor );\n\n\t} else {\n\n\t\tdiffuseColor( wo, wi, material, hit, targetColor );\n\t\ttargetColor.multiplyScalar( 1.0 - material.transmission );\n\n\t\tspecularColor( wo, wi, material, hit, tempColor );\n\t\ttargetColor.add( tempColor );\n\n\t}\n\n}\n\nexport function bsdfSample( wo, hit, material, sampleInfo ) {\n\n\tconst lightDirection = sampleInfo.direction;\n\tconst { ior, metalness, transmission } = material;\n\tconst { frontFace } = hit;\n\n\tconst ratio = frontFace ? 1 / ior : ior;\n\tconst cosTheta = Math.min( wo.z, 1.0 );\n\tconst sinTheta = Math.sqrt( 1.0 - cosTheta * cosTheta );\n\tlet reflectance = schlickFresnelFromIor( cosTheta, ratio );\n\tconst cannotRefract = ratio * sinTheta > 1.0;\n\tif ( cannotRefract ) {\n\n\t\treflectance = 1;\n\n\t}\n\n\tif ( Math.random() < transmission ) {\n\n\t\tconst specularProb = MathUtils.lerp( reflectance, 1.0, metalness );\n\t\tif ( Math.random() < specularProb ) {\n\n\t\t\tspecularDirection( wo, hit, material, lightDirection );\n\n\t\t} else {\n\n\t\t\ttransmissionDirection( wo, hit, material, lightDirection );\n\n\t\t}\n\n\t} else {\n\n\t\tconst specularProb = 0.5 + 0.5 * metalness;\n\t\tif ( Math.random() < specularProb ) {\n\n\t\t\tspecularDirection( wo, hit, material, lightDirection );\n\n\t\t} else {\n\n\t\t\tdiffuseDirection( wo, hit, material, lightDirection );\n\n\t\t}\n\n\t}\n\n\tsampleInfo.pdf = bsdfPdf( wo, lightDirection, material, hit );\n\tbsdfColor( wo, lightDirection, material, hit, sampleInfo.color );\n\n}\n\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { bsdfSample, bsdfColor, bsdfPdf } from './pathtracing/materialSampling.js';\n\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport {\n\tacceleratedRaycast,\n\tcomputeBoundsTree,\n\tdisposeBoundsTree,\n\tSAH,\n\tCENTER,\n} from 'three-mesh-bvh';\nimport {\n\tGenerateMeshBVHWorker,\n} from 'three-mesh-bvh/worker';\nimport { ANTIALIAS_OFFSETS, ANTIALIAS_WIDTH, EPSILON, getBasisFromNormal, isDirectionValid } from './pathtracing/utils.js';\n\nTHREE.Mesh.prototype.raycast = acceleratedRaycast;\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;\n\nlet scene, camera, renderer, light, clock;\nlet fsQuad, controls;\nlet dataTexture, samples, task, delay, scanLinePercent;\nlet scanLineElement, containerElement, outputContainer;\nlet renderStartTime, computationTime;\nlet mesh, materials, lightMesh, floorMesh;\n\n// constants\nconst DELAY_TIME = 300;\nconst FADE_DELAY = 150;\n\n// reusable fields\nconst triangle = new THREE.Triangle();\nconst normal0 = new THREE.Vector3();\nconst normal1 = new THREE.Vector3();\nconst normal2 = new THREE.Vector3();\nconst barycoord = new THREE.Vector3();\nconst spherical = new THREE.Spherical();\nconst normalBasis = new THREE.Matrix4();\nconst invBasis = new THREE.Matrix4();\nconst localDirection = new THREE.Vector3();\nconst tempColor = new THREE.Color();\nconst tempVector = new THREE.Vector3();\n\nconst models = {};\nconst params = {\n\tmodel: 'Dragon',\n\tresolution: {\n\t\tresolutionScale: 0.5,\n\t\tsmoothImageScaling: false,\n\t\tstretchImage: true,\n\t},\n\tpathTracing: {\n\t\tpause: false,\n\t\tdisplayScanLine: false,\n\t\tantialiasing: true,\n\t\tbounces: 10,\n\t\tfilterGlossyFactor: 0.5,\n\t\tsmoothNormals: true,\n\t\tdirectLightSampling: true,\n\t},\n\tmaterial: {\n\t\tcolor: '#0099ff',\n\t\temissive: '#000000',\n\t\temissiveIntensity: 1,\n\t\troughness: 0.1,\n\t\tmetalness: 0.0,\n\t\tior: 1.8,\n\t\ttransmission: 0.0,\n\t},\n\tfloor: {\n\t\tenable: true,\n\t\tcolor: '#7f7f7f',\n\t\troughness: 0.1,\n\t\tmetalness: 0.1,\n\t\twidth: 10,\n\t\theight: 10,\n\t},\n\tlight: {\n\t\tenable: true,\n\t\tposition: 'Diagonal',\n\t\tintensity: 30.0,\n\t\tcolor: '#ffffff',\n\t\twidth: 1,\n\t\theight: 1,\n\t},\n\tenvironment: {\n\t\tskyMode: 'sky',\n\t\tskyIntensity: 0.025,\n\t}\n};\n\ninit();\nrender();\n\nfunction init() {\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 1 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\n\t// container of the canvas and scan line to be centered\n\tcontainerElement = document.createElement( 'div' );\n\tcontainerElement.style.position = 'absolute';\n\tcontainerElement.style.inset = '0';\n\tcontainerElement.style.margin = 'auto';\n\tcontainerElement.style.zIndex = '-1';\n\tdocument.body.appendChild( containerElement );\n\tcontainerElement.appendChild( renderer.domElement );\n\n\t// scan line element for tracking render progress\n\tscanLineElement = document.createElement( 'div' );\n\tscanLineElement.style.width = '100%';\n\tscanLineElement.style.position = 'absolute';\n\tscanLineElement.style.borderBottom = '1px solid #e91e63';\n\tscanLineElement.style.visibility = 'hidden';\n\tcontainerElement.appendChild( scanLineElement );\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tfsQuad = new FullScreenQuad( new THREE.MeshBasicMaterial() );\n\tfsQuad.material.transparent = true;\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( - 2.5, 1.5, 2.5 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\t// light\n\tlight = new THREE.HemisphereLight( 0xffffff, 0x666666, 1 );\n\tscene.add( light );\n\n\tlightMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneGeometry( 1, 1, 1, 1 ),\n\t\tnew THREE.MeshBasicMaterial( { side: THREE.DoubleSide } ),\n\t);\n\tlightMesh.position.set( 2, 2, 2 );\n\tlightMesh.lookAt( 0, 0, 0 );\n\tscene.add( lightMesh );\n\n\tfloorMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneGeometry( 1, 1, 1, 1 ),\n\t\tnew THREE.MeshStandardMaterial( { side: THREE.DoubleSide } ),\n\t);\n\tfloorMesh.rotation.x = - Math.PI / 2;\n\tfloorMesh.scale.setScalar( 1 );\n\tfloorMesh.material.ior = 1.6;\n\tfloorMesh.material.transmission = 0;\n\tscene.add( floorMesh );\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.addEventListener( 'change', resetImage );\n\n\twindow.addEventListener( 'resize', onResize, false );\n\tonResize();\n\n\t// Load sphere\n\tmodels[ 'Sphere' ] = null;\n\t{\n\n\t\tconst sphereMesh = new THREE.Mesh(\n\t\t\tnew THREE.SphereGeometry( 1, 100, 50 ),\n\t\t\tnew THREE.MeshStandardMaterial(),\n\t\t);\n\n\t\tconst { geometry, materials } = mergeMeshes( [ sphereMesh ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tscene.add( merged );\n\n\t\tgeometry.computeBoundsTree( { strategy: SAH, maxLeafSize: 1 } );\n\t\tmodels[ 'Sphere' ] = { mesh: merged, materials, floorHeight: - 1 };\n\n\t}\n\n\tmodels[ 'Cornell Box' ] = null;\n\t{\n\n\t\tconst planeGeom = new THREE.PlaneGeometry( 1, 1, 1, 1 );\n\t\tconst leftWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0x00ee00,\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} )\n\t\t);\n\t\tleftWall.rotation.y = Math.PI / 2;\n\t\tleftWall.position.x = - 2;\n\t\tleftWall.scale.setScalar( 4 );\n\t\tleftWall.updateMatrixWorld( true );\n\n\t\tconst rightWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xee0000,\n\t\t\t} ),\n\t\t);\n\t\trightWall.rotation.y = Math.PI / 2;\n\t\trightWall.position.x = 2;\n\t\trightWall.scale.setScalar( 4 );\n\t\trightWall.updateMatrixWorld( true );\n\n\t\tconst backWall = new THREE.Mesh(\n\t\t\tplaneGeom,\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t} ),\n\t\t);\n\t\tbackWall.position.z = - 2;\n\t\tbackWall.scale.setScalar( 4 );\n\t\tbackWall.updateMatrixWorld( true );\n\n\t\tconst ceiling = new THREE.Mesh(\n\t\t\tplaneGeom.clone(),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t} ),\n\t\t);\n\t\tceiling.rotation.x = Math.PI / 2;\n\t\tceiling.position.y = 2;\n\t\tceiling.scale.setScalar( 4 );\n\t\tceiling.updateMatrixWorld( true );\n\n\t\tconst box = new THREE.Mesh(\n\t\t\tnew THREE.BoxGeometry( 1, 2, 1 ),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} ),\n\t\t);\n\t\tbox.position.y = - 1.0;\n\t\tbox.position.x = - 0.6;\n\t\tbox.position.z = - 0.25;\n\t\tbox.rotation.y = Math.PI / 4;\n\n\t\tconst box2 = new THREE.Mesh(\n\t\t\tnew THREE.BoxGeometry( 1, 1, 1 ),\n\t\t\tnew THREE.MeshStandardMaterial( {\n\t\t\t\tside: THREE.DoubleSide,\n\t\t\t} ),\n\t\t);\n\t\tbox2.position.y = - 1.5;\n\t\tbox2.position.x = 0.75;\n\t\tbox2.position.z = 0.5;\n\t\tbox2.rotation.y = - Math.PI / 8;\n\n\t\tconst { geometry, materials } = mergeMeshes( [ box, box2, leftWall, rightWall, backWall, ceiling ], true );\n\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\tscene.add( merged );\n\n\t\tgeometry.computeBoundsTree( { strategy: SAH, maxLeafSize: 1 } );\n\t\tmodels[ 'Cornell Box' ] = { mesh: merged, materials, floorHeight: - 2 };\n\n\t}\n\n\t// Load dragon\n\tmodels[ 'Dragon' ] = null;\n\tnew GLTFLoader()\n\t\t.load( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/dragon-attenuation/DragonAttenuation.glb', gltf => {\n\n\t\t\tlet mesh;\n\t\t\tgltf.scene.traverse( c => {\n\n\t\t\t\tif ( c.isMesh && c.name === 'Dragon' ) {\n\n\t\t\t\t\tmesh = c;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tmesh.material = new THREE.MeshStandardMaterial();\n\t\t\tmesh.geometry.center().scale( 0.25, 0.25, 0.25 ).rotateX( Math.PI / 2 );\n\t\t\tmesh.position.set( 0, 0, 0 );\n\t\t\tmesh.scale.set( 1, 1, 1 );\n\t\t\tmesh.quaternion.identity();\n\n\t\t\tconst { geometry, materials } = mergeMeshes( [ mesh ], true );\n\t\t\tconst merged = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\t\tconst generator = new GenerateMeshBVHWorker();\n\t\t\tgenerator\n\t\t\t\t.generate( geometry, { maxLeafSize: 1, strategy: SAH } )\n\t\t\t\t.then( bvh => {\n\n\t\t\t\t\tmodels[ 'Dragon' ] = { mesh: merged, materials, floorHeight: mesh.geometry.boundingBox.min.y };\n\t\t\t\t\tgeometry.boundsTree = bvh;\n\t\t\t\t\tgenerator.dispose();\n\t\t\t\t\tscene.add( merged );\n\n\t\t\t\t} );\n\n\t\t} );\n\n\tmodels[ 'Engine' ] = null;\n\tnew GLTFLoader()\n\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t.load( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/internal-combustion-engine/model.gltf', gltf => {\n\n\t\t\tconst originalMesh = gltf.scene.children[ 0 ];\n\t\t\tconst originalGeometry = originalMesh.geometry;\n\t\t\tconst newGeometry = new THREE.BufferGeometry();\n\n\t\t\tconst ogPosAttr = originalGeometry.attributes.position;\n\t\t\tconst ogNormAttr = originalGeometry.attributes.normal;\n\t\t\tconst posAttr = new THREE.BufferAttribute( new Float32Array( ogPosAttr.count * 3 ), 3, false );\n\t\t\tconst normAttr = new THREE.BufferAttribute( new Float32Array( ogNormAttr.count * 3 ), 3, false );\n\n\t\t\tconst vec = new THREE.Vector3();\n\t\t\tfor ( let i = 0, l = ogPosAttr.count; i < l; i ++ ) {\n\n\t\t\t\tvec.fromBufferAttribute( ogPosAttr, i );\n\t\t\t\tposAttr.setXYZ( i, vec.x, vec.y, vec.z );\n\n\t\t\t\tvec.fromBufferAttribute( ogNormAttr, i );\n\t\t\t\tvec.multiplyScalar( 1 / 127 );\n\t\t\t\tnormAttr.setXYZ( i, vec.x, vec.y, vec.z );\n\n\t\t\t}\n\n\t\t\toriginalMesh.scale.multiplyScalar( 5 );\n\t\t\toriginalMesh.updateMatrixWorld();\n\t\t\tnewGeometry.setAttribute( 'position', posAttr );\n\t\t\tnewGeometry.setAttribute( 'normal', normAttr );\n\t\t\tnewGeometry.setAttribute( 'materialIndex', new THREE.BufferAttribute( new Uint8Array( posAttr.count ), 1, false ) );\n\t\t\tnewGeometry.setIndex( originalGeometry.index );\n\t\t\tnewGeometry.applyMatrix4( originalMesh.matrixWorld ).center();\n\t\t\tnewGeometry.computeBoundingBox();\n\n\t\t\tconst mesh = new THREE.Mesh( newGeometry, new THREE.MeshStandardMaterial() );\n\t\t\tconst generator = new GenerateMeshBVHWorker();\n\t\t\tgenerator\n\t\t\t\t.generate( newGeometry, { maxLeafSize: 1, strategy: CENTER } )\n\t\t\t\t.then( bvh => {\n\n\t\t\t\t\tmodels[ 'Engine' ] = {\n\t\t\t\t\t\tmesh,\n\t\t\t\t\t\tmaterials: [ new THREE.MeshStandardMaterial() ],\n\t\t\t\t\t\tfloorHeight: newGeometry.boundingBox.min.y,\n\t\t\t\t\t};\n\t\t\t\t\tnewGeometry.boundsTree = bvh;\n\t\t\t\t\tgenerator.dispose();\n\n\t\t\t\t\tscene.add( mesh );\n\n\t\t\t\t} );\n\n\t\t} );\n\n\tsamples = 0;\n\tclock = new THREE.Clock();\n\n\tconst gui = new GUI();\n\tgui.add( params, 'model', Object.keys( models ) ).onChange( resetImage );\n\n\tconst resolutionFolder = gui.addFolder( 'resolution' );\n\tresolutionFolder.add( params.resolution, 'resolutionScale', 0.1, 1, 0.01 ).onChange( onResize );\n\tresolutionFolder.add( params.resolution, 'smoothImageScaling' ).onChange( onResize );\n\tresolutionFolder.add( params.resolution, 'stretchImage' ).onChange( onResize );\n\tresolutionFolder.open();\n\n\tconst pathTracingFolder = gui.addFolder( 'path tracing' );\n\tpathTracingFolder.add( params.pathTracing, 'pause' );\n\tpathTracingFolder.add( params.pathTracing, 'displayScanLine' ).onChange( v => {\n\n\t\tscanLineElement.style.visibility = v ? 'visible' : 'hidden';\n\n\t} );\n\tpathTracingFolder.add( params.pathTracing, 'antialiasing' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'directLightSampling' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'smoothNormals' ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'bounces', 1, 50, 1 ).onChange( resetImage );\n\tpathTracingFolder.add( params.pathTracing, 'filterGlossyFactor', 0, 1, 0.001 ).onChange( resetImage );\n\tpathTracingFolder.open();\n\n\tconst materialFolder = gui.addFolder( 'model' );\n\tmaterialFolder.addColor( params.material, 'color' ).onChange( resetImage );\n\tmaterialFolder.addColor( params.material, 'emissive' ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'emissiveIntensity', 0, 5, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'roughness', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'metalness', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'transmission', 0, 1.0, 0.001 ).onChange( resetImage );\n\tmaterialFolder.add( params.material, 'ior', 1.0, 2.5, 0.001 ).onChange( resetImage );\n\tmaterialFolder.open();\n\n\tconst floorFolder = gui.addFolder( 'floor' );\n\tfloorFolder.add( params.floor, 'enable' ).onChange( resetImage );\n\tfloorFolder.addColor( params.floor, 'color' ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'roughness', 0, 1, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'metalness', 0, 1, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'width', 3, 20, 0.001 ).onChange( resetImage );\n\tfloorFolder.add( params.floor, 'height', 3, 20, 0.001 ).onChange( resetImage );\n\n\tconst lightFolder = gui.addFolder( 'light' );\n\tlightFolder.add( params.light, 'enable' ).onChange( resetImage );\n\tlightFolder.addColor( params.light, 'color' ).onChange( resetImage );\n\tlightFolder.add( params.light, 'intensity', 0, 100, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'width', 0, 5, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'height', 0, 5, 0.001 ).onChange( resetImage );\n\tlightFolder.add( params.light, 'position', [ 'Diagonal', 'Above', 'Below' ] ).onChange( resetImage );\n\n\tconst envFolder = gui.addFolder( 'environment' );\n\tenvFolder.add( params.environment, 'skyMode', [ 'sky', 'sun', 'checkerboard' ] ).onChange( resetImage );\n\tenvFolder.add( params.environment, 'skyIntensity', 0, 5, 0.001 ).onChange( resetImage );\n\n\tonResize();\n\n}\n\n// Merges meshes into a single geometry, returns a series of materials and geometry with a vertex attribute buffer\n// containing information about the material index to use\nfunction mergeMeshes( meshes, cloneGeometry = true ) {\n\n\tconst transformedGeometry = [];\n\tconst materials = [];\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\tconst mesh = meshes[ i ];\n\t\tconst originalGeometry = meshes[ i ].geometry;\n\t\tconst geom = cloneGeometry ? originalGeometry.clone() : cloneGeometry;\n\t\tmesh.updateMatrixWorld();\n\t\tgeom.applyMatrix4( mesh.matrixWorld );\n\n\t\tconst vertexCount = geom.attributes.position.count;\n\t\tconst materialIndexArray = new Uint8Array( vertexCount ).fill( i );\n\t\tgeom.setAttribute( 'materialIndex', new THREE.BufferAttribute( materialIndexArray, 1, false ) );\n\n\t\ttransformedGeometry.push( geom );\n\t\tmaterials.push( mesh.material );\n\n\t}\n\n\tconst geometry = BufferGeometryUtils.mergeGeometries( transformedGeometry, false );\n\treturn { geometry, materials };\n\n}\n\nfunction onResize() {\n\n\tfunction resizeDataTexture( w, h ) {\n\n\t\tif ( ! dataTexture || dataTexture.image.width !== w || dataTexture.image.height !== h ) {\n\n\t\t\tif ( dataTexture ) {\n\n\t\t\t\tdataTexture.dispose();\n\n\t\t\t}\n\n\t\t\tdataTexture = new THREE.DataTexture( new Float32Array( w * h * 4 ), w, h, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tresetImage();\n\n\t\t}\n\n\t}\n\n\tcamera.aspect = window.innerWidth / window.innerHeight;\n\tcamera.updateProjectionMatrix();\n\n\t// compute the new resolution based on the use parameters\n\tconst dpr = window.devicePixelRatio;\n\tconst resolutionScale = params.resolution.resolutionScale;\n\tif ( params.resolution.stretchImage ) {\n\n\t\tcontainerElement.style.width = `${ window.innerWidth }px`;\n\t\tcontainerElement.style.height = `${ window.innerHeight }px`;\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\trenderer.setPixelRatio( dpr * resolutionScale );\n\t\tresizeDataTexture(\n\t\t\tMath.floor( window.innerWidth * dpr * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * dpr * resolutionScale ),\n\t\t);\n\n\t} else {\n\n\t\tcontainerElement.style.width = `${ window.innerWidth * resolutionScale }px`;\n\t\tcontainerElement.style.height = `${ window.innerHeight * resolutionScale }px`;\n\t\trenderer.setSize(\n\t\t\tMath.floor( window.innerWidth * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * resolutionScale )\n\t\t);\n\t\trenderer.setPixelRatio( dpr );\n\t\tresizeDataTexture(\n\t\t\tMath.floor( window.innerWidth * dpr * resolutionScale ),\n\t\t\tMath.floor( window.innerHeight * dpr * resolutionScale ),\n\t\t);\n\n\t}\n\n\trenderer.domElement.style.imageRendering = params.resolution.smoothImageScaling ? 'auto' : 'pixelated';\n\n}\n\nfunction resetImage() {\n\n\t// clear the draw buffer and restart the path tracing loop\n\tdataTexture.image.data.fill( 0 );\n\tdataTexture.needsUpdate = true;\n\tsamples = 0;\n\ttask = runPathTracingLoop();\n\tdelay = 0;\n\tscanLineElement.style.visibility = 'hidden';\n\tscanLinePercent = 100;\n\n\tlightMesh.scale.set( params.light.width, params.light.height, 1 );\n\tlightMesh.material.color.set( params.light.color ).multiplyScalar( params.light.intensity );\n\tlightMesh.visible = params.light.enable;\n\n\tfloorMesh.scale.set( params.floor.width, params.floor.height, 1 );\n\tfloorMesh.material.color.set( params.floor.color );\n\tfloorMesh.material.roughness = Math.pow( params.floor.roughness, 2.0 ); // perceptual roughness\n\tfloorMesh.material.metalness = params.floor.metalness;\n\tfloorMesh.visible = params.floor.enable;\n\n}\n\nfunction* runPathTracingLoop() {\n\n\t// extract options\n\tconst { width, height, data } = dataTexture.image;\n\tconst bounces = parseInt( params.pathTracing.bounces );\n\tconst skyIntensity = parseFloat( params.environment.skyIntensity );\n\tconst skyMode = params.environment.skyMode;\n\tconst smoothNormals = params.pathTracing.smoothNormals;\n\n\t// reusable variables\n\tconst radianceColor = new THREE.Color();\n\tconst throughputColor = new THREE.Color();\n\tconst halfVector = new THREE.Vector3();\n\tconst normal = new THREE.Vector3();\n\tconst ssPoint = new THREE.Vector2();\n\tconst rayStack = new Array( bounces ).fill().map( () => new THREE.Ray() );\n\tconst lightForward = new THREE.Vector3( 0, 0, 1 ).transformDirection( lightMesh.matrixWorld );\n\tconst lightWidth = lightMesh.scale.x;\n\tconst lightHeight = lightMesh.scale.y;\n\tconst raycaster = new THREE.Raycaster();\n\traycaster.firstHitOnly = true;\n\n\tconst seedRay = new THREE.Ray();\n\tconst sampleInfo = {\n\t\tpdf: 0,\n\t\tcolor: new THREE.Color(),\n\t\tdirection: new THREE.Vector3(),\n\t};\n\n\t// initialization of progress variables\n\tlet lastStartTime = performance.now();\n\trenderStartTime = performance.now();\n\tcomputationTime = 0;\n\tscanLinePercent = 100;\n\tscanLineElement.style.visibility = params.pathTracing.displayScanLine ? 'visible' : 'hidden';\n\n\t// ensure the materials are all set to double side for transmissive rendering\n\tmesh.material.side = THREE.DoubleSide;\n\tmaterials.forEach( material => {\n\n\t\tmaterial.side = THREE.DoubleSide;\n\n\t} );\n\n\twhile ( true ) {\n\n\t\tlet randomOffsetX = 0;\n\t\tlet randomOffsetY = 0;\n\t\tif ( params.pathTracing.antialiasing ) {\n\n\t\t\tconst antiAliasIndex = ( samples ) % ANTIALIAS_OFFSETS.length;\n\t\t\t[ randomOffsetX, randomOffsetY ] = ANTIALIAS_OFFSETS[ antiAliasIndex ];\n\t\t\trandomOffsetX = ( randomOffsetX / ANTIALIAS_WIDTH ) / width;\n\t\t\trandomOffsetY = ( randomOffsetY / ANTIALIAS_WIDTH ) / height;\n\n\t\t}\n\n\t\tfor ( let y = height - 1; y >= 0; y -- ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t// get the camera ray\n\t\t\t\tssPoint.set( randomOffsetX + x / ( width - 1 ), randomOffsetY + y / ( height - 1 ) );\n\t\t\t\traycaster.setFromCamera( { x: ssPoint.x * 2 - 1, y: ssPoint.y * 2 - 1 }, camera );\n\n\t\t\t\t// get the camera look direction\n\t\t\t\ttempVector.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t\t// copy the ray to the starting ray to pass into the pathTrace function and adjust it\n\t\t\t\t// so ti starts at the camera near clip plane\n\t\t\t\tseedRay.direction.copy( raycaster.ray.direction );\n\t\t\t\tseedRay.origin\n\t\t\t\t\t.copy( raycaster.ray.origin )\n\t\t\t\t\t.addScaledVector( raycaster.ray.direction, camera.near / raycaster.ray.direction.dot( tempVector ) );\n\n\t\t\t\t// run the path trace\n\t\t\t\tradianceColor.set( 0 );\n\t\t\t\tpathTrace( seedRay, radianceColor );\n\n\t\t\t\t// accumulate a rolling average color into the data texture\n\t\t\t\tconst index = ( y * width + x ) * 4;\n\t\t\t\tconst r = data[ index + 0 ];\n\t\t\t\tconst g = data[ index + 1 ];\n\t\t\t\tconst b = data[ index + 2 ];\n\t\t\t\tdata[ index + 0 ] += ( radianceColor.r - r ) / ( samples + 1 );\n\t\t\t\tdata[ index + 1 ] += ( radianceColor.g - g ) / ( samples + 1 );\n\t\t\t\tdata[ index + 2 ] += ( radianceColor.b - b ) / ( samples + 1 );\n\t\t\t\tdata[ index + 3 ] = 1.0;\n\n\t\t\t\t// if we've rendered for ~16ms then wait for the next tick\n\t\t\t\tconst delta = performance.now() - lastStartTime;\n\t\t\t\tif ( delta > 16 ) {\n\n\t\t\t\t\tcomputationTime += delta;\n\t\t\t\t\tscanLinePercent = 100 * y / height;\n\n\t\t\t\t\tyield;\n\t\t\t\t\tlastStartTime = performance.now();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tsamples ++;\n\n\t}\n\n\t// extract other necessary information from the hit\n\tfunction expandHitInformation( hit, ray, accumulatedRoughness ) {\n\n\t\tconst object = hit.object;\n\t\tconst posAttr = object.geometry.attributes.position;\n\t\tconst normalAttr = object.geometry.attributes.normal;\n\t\tconst materialAttr = object.geometry.attributes.materialIndex;\n\n\t\tconst face = hit.face;\n\t\tconst geometryNormal = hit.face.normal;\n\t\tif ( smoothNormals ) {\n\n\t\t\tconst point = hit.point;\n\t\t\ttriangle.a.fromBufferAttribute( posAttr, face.a );\n\t\t\ttriangle.b.fromBufferAttribute( posAttr, face.b );\n\t\t\ttriangle.c.fromBufferAttribute( posAttr, face.c );\n\n\t\t\tnormal0.fromBufferAttribute( normalAttr, face.a );\n\t\t\tnormal1.fromBufferAttribute( normalAttr, face.b );\n\t\t\tnormal2.fromBufferAttribute( normalAttr, face.c );\n\n\t\t\ttriangle.getBarycoord( point, barycoord );\n\n\t\t\tnormal\n\t\t\t\t.setScalar( 0 )\n\t\t\t\t.addScaledVector( normal0, barycoord.x )\n\t\t\t\t.addScaledVector( normal1, barycoord.y )\n\t\t\t\t.addScaledVector( normal2, barycoord.z )\n\t\t\t\t.normalize();\n\n\t\t} else {\n\n\t\t\tnormal.copy( geometryNormal );\n\n\t\t}\n\n\t\tgeometryNormal.transformDirection( object.matrixWorld );\n\t\tnormal.transformDirection( object.matrixWorld );\n\n\t\tconst hitFrontFace = geometryNormal.dot( ray.direction ) < 0;\n\t\tif ( ! hitFrontFace ) {\n\n\t\t\tnormal.multiplyScalar( - 1 );\n\t\t\tgeometryNormal.multiplyScalar( - 1 );\n\n\t\t}\n\n\t\tlet material = object.material;\n\t\tif ( materialAttr ) {\n\n\t\t\tconst materialIndex = materialAttr.getX( face.a );\n\t\t\tmaterial = materials[ materialIndex ];\n\n\t\t}\n\n\t\thit.material = material;\n\t\thit.normal = normal;\n\t\thit.geometryNormal = geometryNormal;\n\t\thit.frontFace = hitFrontFace;\n\n\t\t// compute the filtered roughness value to use during specular reflection computations. A minimum\n\t\t// value of 1e-6 is needed because the GGX functions do not work with a roughness value of 0 and\n\t\t// the accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\thit.filteredSurfaceRoughness = Math.min(\n\t\t\tMath.max(\n\t\t\t\t1e-6,\n\t\t\t\tmaterial.roughness,\n\t\t\t\taccumulatedRoughness * params.pathTracing.filterGlossyFactor * 5.0,\n\t\t\t),\n\t\t\t1.0,\n\t\t);\n\n\n\t}\n\n\t// trace a path starting at the given ray\n\tfunction pathTrace( ray, targetColor ) {\n\n\t\tlet currentRay = ray;\n\t\tlet lastPdf = 0;\n\t\tlet accumulatedRoughness = 0;\n\t\tthroughputColor.set( 0xffffff );\n\t\tfor ( let i = 0; i < bounces; i ++ ) {\n\n\t\t\t// get the ray intersection\n\t\t\tlet hit = null;\n\t\t\traycaster.ray.copy( currentRay );\n\n\t\t\tconst objects = [ mesh ];\n\t\t\tif ( params.light.enable ) {\n\n\t\t\t\tobjects.push( lightMesh );\n\n\t\t\t}\n\n\t\t\tif ( params.floor.enable ) {\n\n\t\t\t\tobjects.push( floorMesh );\n\n\t\t\t}\n\n\t\t\thit = raycaster.intersectObjects( objects, true )[ 0 ];\n\n\t\t\t// check if we hit the light or the model\n\t\t\tif ( hit ) {\n\n\t\t\t\tif ( hit.object === lightMesh ) {\n\n\t\t\t\t\t// only add light on one side\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tconst lightColor = lightMesh.material.color;\n\t\t\t\t\t\ttargetColor.r = Math.min( lightColor.r, 1.0 );\n\t\t\t\t\t\ttargetColor.g = Math.min( lightColor.g, 1.0 );\n\t\t\t\t\t\ttargetColor.b = Math.min( lightColor.b, 1.0 );\n\n\t\t\t\t\t} else if ( currentRay.direction.dot( lightForward ) < 0 ) {\n\n\t\t\t\t\t\t// only add light on one side\n\t\t\t\t\t\tconst lightDistSq = hit.distance * hit.distance;\n\t\t\t\t\t\tconst lightArea = lightWidth * lightHeight;\n\t\t\t\t\t\tconst lightPdf = lightDistSq / ( lightArea * - currentRay.direction.dot( lightForward ) );\n\n\t\t\t\t\t\tconst weight = lastPdf / ( lastPdf + lightPdf );\n\t\t\t\t\t\ttargetColor.r += weight * throughputColor.r * lightMesh.material.color.r;\n\t\t\t\t\t\ttargetColor.g += weight * throughputColor.g * lightMesh.material.color.g;\n\t\t\t\t\t\ttargetColor.b += weight * throughputColor.b * lightMesh.material.color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\n\t\t\t\t\texpandHitInformation( hit, currentRay, accumulatedRoughness );\n\t\t\t\t\tconst { material } = hit;\n\t\t\t\t\tconst nextRay = rayStack[ i ];\n\n\t\t\t\t\t// get the local normal frame\n\t\t\t\t\tgetBasisFromNormal( hit.normal, normalBasis );\n\t\t\t\t\tinvBasis.copy( normalBasis ).invert();\n\n\t\t\t\t\t/* Direct Light Sampling */\n\t\t\t\t\tif ( params.light.enable ) {\n\n\t\t\t\t\t\t// get a random point on the surface of the light\n\t\t\t\t\t\ttempVector\n\t\t\t\t\t\t\t.set( Math.random() - 0.5, Math.random() - 0.5, 0 )\n\t\t\t\t\t\t\t.applyMatrix4( lightMesh.matrixWorld );\n\n\t\t\t\t\t\t// get a ray to the light point\n\t\t\t\t\t\t// note that the ray always starts on the front side of the face implying that transmissive\n\t\t\t\t\t\t// contributions are not included here.\n\t\t\t\t\t\tnextRay.origin.copy( hit.point ).addScaledVector( hit.geometryNormal, EPSILON );\n\t\t\t\t\t\tnextRay.direction.subVectors( tempVector, nextRay.origin ).normalize();\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnextRay.direction.dot( lightForward ) < 0\n\t\t\t\t\t\t\t&& isDirectionValid( nextRay.direction, hit.normal, hit.geometryNormal )\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// compute the probability of hitting the light on the hemisphere\n\t\t\t\t\t\t\tconst lightArea = lightWidth * lightHeight;\n\t\t\t\t\t\t\tconst lightDistSq = nextRay.origin.distanceToSquared( tempVector );\n\t\t\t\t\t\t\tconst lightPdf = lightDistSq / ( lightArea * - nextRay.direction.dot( lightForward ) );\n\n\t\t\t\t\t\t\traycaster.ray.copy( nextRay );\n\t\t\t\t\t\t\tconst shadowHit = raycaster.intersectObjects( objects, true )[ 0 ];\n\t\t\t\t\t\t\tif ( shadowHit && shadowHit.object === lightMesh ) {\n\n\t\t\t\t\t\t\t\t// get the incoming and outgoing directions in the normal frame\n\t\t\t\t\t\t\t\tlocalDirection.copy( currentRay.direction ).applyMatrix4( invBasis ).multiplyScalar( - 1 ).normalize();\n\t\t\t\t\t\t\t\ttempVector.copy( nextRay.direction ).applyMatrix4( invBasis ).normalize();\n\t\t\t\t\t\t\t\tlocalDirection.normalize();\n\n\t\t\t\t\t\t\t\t// get the material color and pdf\n\t\t\t\t\t\t\t\tbsdfColor( localDirection, tempVector, material, hit, tempColor );\n\n\t\t\t\t\t\t\t\t// add light contribution to the final color\n\t\t\t\t\t\t\t\tconst materialPdf = bsdfPdf( localDirection, tempVector, material, hit );\n\t\t\t\t\t\t\t\tconst misWeight = lightPdf / ( materialPdf + lightPdf );\n\t\t\t\t\t\t\t\ttargetColor.r += lightMesh.material.color.r * throughputColor.r * tempColor.r * misWeight / lightPdf;\n\t\t\t\t\t\t\t\ttargetColor.g += lightMesh.material.color.g * throughputColor.g * tempColor.g * misWeight / lightPdf;\n\t\t\t\t\t\t\t\ttargetColor.b += lightMesh.material.color.b * throughputColor.b * tempColor.b * misWeight / lightPdf;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* BSDF Sampling */\n\t\t\t\t\t// compute the outgoing vector (towards the camera) to feed into the bsdf to get the\n\t\t\t\t\t// incident light vector.\n\t\t\t\t\tlocalDirection.copy( currentRay.direction ).applyMatrix4( invBasis )\n\t\t\t\t\t\t.multiplyScalar( - 1 ).normalize();\n\n\t\t\t\t\t// sample the surface to get the pdf, reflected color, and direction\n\t\t\t\t\tbsdfSample( localDirection, hit, material, sampleInfo );\n\n\t\t\t\t\t// accumulate a roughness based on the sin of the half vector with the surface normal which\n\t\t\t\t\t// can be used with subsequent ray bounces to avoid fireflies similar to Blender functionality\n\t\t\t\t\thalfVector.addVectors( localDirection, sampleInfo.direction ).normalize();\n\t\t\t\t\taccumulatedRoughness += Math.sin( Math.acos( halfVector.z ) );\n\n\t\t\t\t\t// transform ray back to world frame and offset from surface\n\t\t\t\t\tnextRay.direction.copy( sampleInfo.direction ).applyMatrix4( normalBasis ).normalize();\n\n\t\t\t\t\tconst isBelowSurface = nextRay.direction.dot( hit.geometryNormal ) < 0;\n\t\t\t\t\tnextRay.origin.copy( hit.point )\n\t\t\t\t\t\t.addScaledVector( hit.geometryNormal, isBelowSurface ? - EPSILON : EPSILON );\n\n\t\t\t\t\t// emission contribution\n\t\t\t\t\tconst { emissive, emissiveIntensity } = material;\n\t\t\t\t\ttargetColor.r += ( emissiveIntensity * emissive.r * throughputColor.r );\n\t\t\t\t\ttargetColor.g += ( emissiveIntensity * emissive.g * throughputColor.g );\n\t\t\t\t\ttargetColor.b += ( emissiveIntensity * emissive.b * throughputColor.b );\n\n\t\t\t\t\t// If our PDF indicates there's a less than 0 probability of sampling this new direction then\n\t\t\t\t\t// don't include it in our sampling and terminate the ray modeling that the ray has been absorbed.\n\t\t\t\t\tif (\n\t\t\t\t\t\tsampleInfo.pdf <= 0\n\t\t\t\t\t\t|| ! isDirectionValid( nextRay.direction, hit.normal, hit.geometryNormal )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsampleInfo.color.multiplyScalar( 1 / sampleInfo.pdf );\n\t\t\t\t\tthroughputColor.multiply( sampleInfo.color );\n\t\t\t\t\tcurrentRay = nextRay;\n\t\t\t\t\tlastPdf = sampleInfo.pdf;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: is this contribution supposed to be weighted with multiple importance sampling, as well?\n\t\t\t\tsampleSkyBox( currentRay.direction, tempColor );\n\t\t\t\ttempColor.multiply( throughputColor );\n\t\t\t\ttargetColor.add( tempColor );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// sample the skybox in the given direction and put the sampled color into \"target\"\n\tfunction sampleSkyBox( direction, target ) {\n\n\t\tif ( skyMode === 'checkerboard' ) {\n\n\t\t\tspherical.setFromVector3( direction );\n\n\t\t\tconst angleStep = Math.PI / 10;\n\t\t\tconst thetaEven = Math.floor( spherical.theta / angleStep ) % 2 === 0;\n\t\t\tconst phiEven = Math.floor( spherical.phi / angleStep ) % 2 === 0;\n\t\t\tconst isBlack = thetaEven === phiEven;\n\t\t\ttarget.set( isBlack ? 0 : 0xffffff ).multiplyScalar( 1.5 );\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t} else if ( skyMode === 'sun' ) {\n\n\t\t\tnormal0.setScalar( 1 ).normalize();\n\n\t\t\tlet value = Math.max( 0.0, direction.dot( normal0 ) + 1.0 ) / 2.0;\n\t\t\tvalue *= value;\n\t\t\ttarget.r = THREE.MathUtils.lerp( 0.01, 0.5, value );\n\t\t\ttarget.g = THREE.MathUtils.lerp( 0.01, 0.7, value );\n\t\t\ttarget.b = THREE.MathUtils.lerp( 0.01, 1.0, value );\n\n\t\t\tif ( value > 0.95 ) {\n\n\t\t\t\tlet value2 = ( value - 0.95 ) / 0.05;\n\t\t\t\tvalue2 *= value2;\n\t\t\t\ttarget.r = THREE.MathUtils.lerp( 0.5, 10.0, value2 );\n\t\t\t\ttarget.g = THREE.MathUtils.lerp( 0.7, 10.0, value2 );\n\t\t\t\ttarget.b = THREE.MathUtils.lerp( 1.0, 10.0, value2 );\n\n\t\t\t}\n\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t} else {\n\n\t\t\tconst value = ( direction.y + 0.5 ) / 2.0;\n\t\t\ttarget.r = THREE.MathUtils.lerp( 1.0, 0.5, value );\n\t\t\ttarget.g = THREE.MathUtils.lerp( 1.0, 0.7, value );\n\t\t\ttarget.b = THREE.MathUtils.lerp( 1.0, 1.0, value );\n\t\t\ttarget.multiplyScalar( skyIntensity );\n\n\t\t}\n\n\t}\n\n}\n\nfunction toHumanReadableTime( ms ) {\n\n\tms = ms || 0;\n\n\tlet seconds = ms * 1e-3;\n\tconst minutes = Math.floor( seconds / 60 );\n\tseconds = seconds - minutes * 60;\n\n\tconst minutesString = ( minutes < 10 ? '0' : '' ) + minutes;\n\tconst secondsString = ( seconds < 10 ? '0' : '' ) + seconds.toFixed( 3 );\n\n\treturn `${ minutesString }m ${ secondsString }s`;\n\n}\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tfor ( const key in models ) {\n\n\t\tif ( models[ key ] ) {\n\n\t\t\tmodels[ key ].mesh.visible = false;\n\n\t\t}\n\n\t}\n\n\t// select the model and initialize set the 0 material with the user settings\n\tif ( models[ params.model ] ) {\n\n\t\tconst model = models[ params.model ];\n\t\tmodel.mesh.visible = true;\n\t\tmesh = model.mesh;\n\t\tmaterials = model.materials;\n\t\tfloorMesh.position.y = model.floorHeight;\n\n\t\t// initialize ior and transmission not present on materials already\n\t\tmaterials.forEach( m => {\n\n\t\t\tif ( m.ior === undefined ) m.ior = 1;\n\t\t\tif ( m.transmission === undefined ) m.transmission = 0.0;\n\n\t\t} );\n\n\t\tconst material = materials[ 0 ];\n\t\tmaterial.color.set( params.material.color ).convertSRGBToLinear();\n\t\tmaterial.emissive.set( params.material.emissive ).convertSRGBToLinear();\n\t\tmaterial.emissiveIntensity = parseFloat( params.material.emissiveIntensity );\n\t\tmaterial.ior = parseFloat( params.material.ior );\n\t\tmaterial.metalness = parseFloat( params.material.metalness );\n\t\tmaterial.transmission = parseFloat( params.material.transmission );\n\n\t\t// use a \"perceptualRoughness\" concept when interpreting user input\n\t\t// https://google.github.io/filament/Filament.html#materialsystem/standardmodelsummary\n\t\tmaterial.roughness = Math.pow( parseFloat( params.material.roughness ), 2.0 );\n\n\t\t// adjust the position of the area light before rendering\n\t\tswitch ( params.light.position ) {\n\n\t\t\tcase 'Below':\n\t\t\t\tlightMesh.rotation.set( - Math.PI / 2, 0, 0 );\n\t\t\t\tlightMesh.position.set( 0, model.floorHeight + 1e-3, 0 );\n\t\t\t\tbreak;\n\n\t\t\tcase 'Above':\n\t\t\t\tlightMesh.rotation.set( Math.PI / 2, 0, 0 );\n\t\t\t\tlightMesh.position.set( 0, 2 - 1e-3, 0 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlightMesh.position.set( 2, 2, 2 );\n\t\t\t\tlightMesh.lookAt( 0, 0, 0 );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\n\t\tmesh = null;\n\t\tmaterials = null;\n\t\tfloorMesh.position.y = 0;\n\n\t}\n\n\t// Fade the path traced image in after the user stops moving the camera\n\tlet fade = 0;\n\tif ( delay > FADE_DELAY ) {\n\n\t\tfade = Math.min( ( delay - FADE_DELAY ) / ( DELAY_TIME - FADE_DELAY ), 1.0 );\n\n\t}\n\n\t// update the scan line\n\tscanLineElement.style.bottom = `${ scanLinePercent }%`;\n\tif ( params.resolution.stretchImage ) {\n\n\t\tscanLineElement.style.borderBottomWidth = `${ Math.ceil( 1 / params.resolution.resolutionScale ) }px`;\n\n\t} else {\n\n\t\tscanLineElement.style.borderBottomWidth = '1px';\n\n\t}\n\n\t// render the scene\n\trenderer.render( scene, camera );\n\trenderer.autoClear = false;\n\n\t// overlay the path traced image\n\tfsQuad.material.map = dataTexture;\n\tfsQuad.material.opacity = fade;\n\tfsQuad.render( renderer );\n\trenderer.autoClear = true;\n\n\t// run the path tracing\n\t// world matrices are up to date because of the above render\n\tif ( mesh && ! params.pathTracing.pause ) {\n\n\t\ttask.next();\n\n\t}\n\n\t// force the data texture to upload now that it's changed but do it after render so the\n\t// upload happens asynchronously and will be ready next frame.\n\tdataTexture.needsUpdate = true;\n\trenderer.compile( fsQuad._mesh );\n\n\t// count down the fade\n\tif ( delay < DELAY_TIME ) {\n\n\t\tdelay += clock.getDelta() * 1e3;\n\n\t}\n\n\toutputContainer.innerText =\n\t\t`completed samples : ${ samples }\\n` +\n\t\t`computation time  : ${ toHumanReadableTime( computationTime ) }\\n` +\n\t\t`elapsed time      : ${ toHumanReadableTime( performance.now() - renderStartTime ) }`;\n\n}\n\n"],"names":["tempVector","Vector3","tempVector1","tempVector2","EPSILON","ANTIALIAS_WIDTH","ANTIALIAS_OFFSETS","schlickFresnel","cosine","f0","schlickFresnelFromIor","iorRatio","r0","refract","dir","norm","target","cosTheta","getBasisFromNormal","normal","targetMatrix","getHalfVector","a","b","isDirectionValid","direction","surfaceNormal","geometryNormal","aboveSurfaceNormal","aboveGeometryNormal","_V","_T1","_T2","_N","_Z_VECTOR","M_PI","ggxDirection","incidentDir","roughnessX","roughnessY","random1","random2","V","T1","T2","r","phi","P1","P2","N","ggxLamda","theta","roughness","tanTheta","tanTheta2","alpha2","ggxShadowMaskG1","ggxShadowMaskG2","wi","wo","incidentTheta","scatterTheta","ggxDistribution","halfVector","a2","cosTheta4","denom","ggxPDF","D","G1","tempDir","tempColor","Color","whiteColor","diffusePDF","material","hit","diffuseDirection","lightDirection","diffuseColor","colorTarget","metalness","transmission","specularPDF","filteredRoughness","specularDirection","specularColor","ior","frontFace","G","F","sinTheta","MathUtils","transmissionPDF","ratio","reflectance","transmissionDirection","transmissionColor","bsdfPdf","spdf","dpdf","tpdf","transSpecularProb","diffSpecularProb","bsdfColor","targetColor","bsdfSample","sampleInfo","specularProb","THREE.Mesh","acceleratedRaycast","THREE.BufferGeometry","computeBoundsTree","disposeBoundsTree","scene","camera","renderer","light","clock","fsQuad","controls","dataTexture","samples","task","delay","scanLinePercent","scanLineElement","containerElement","outputContainer","renderStartTime","computationTime","mesh","materials","lightMesh","floorMesh","DELAY_TIME","FADE_DELAY","triangle","THREE.Triangle","normal0","THREE.Vector3","normal1","normal2","barycoord","spherical","THREE.Spherical","normalBasis","THREE.Matrix4","invBasis","localDirection","THREE.Color","models","params","init","render","THREE.WebGLRenderer","THREE.sRGBEncoding","FullScreenQuad","THREE.MeshBasicMaterial","THREE.Scene","THREE.PerspectiveCamera","THREE.HemisphereLight","THREE.PlaneGeometry","THREE.DoubleSide","THREE.MeshStandardMaterial","OrbitControls","resetImage","onResize","sphereMesh","THREE.SphereGeometry","geometry","mergeMeshes","merged","SAH","planeGeom","leftWall","rightWall","backWall","ceiling","box","THREE.BoxGeometry","box2","GLTFLoader","gltf","c","generator","GenerateMeshBVHWorker","bvh","MeshoptDecoder","originalMesh","originalGeometry","newGeometry","ogPosAttr","ogNormAttr","posAttr","THREE.BufferAttribute","normAttr","vec","i","l","CENTER","THREE.Clock","gui","GUI","resolutionFolder","pathTracingFolder","v","materialFolder","floorFolder","lightFolder","envFolder","meshes","cloneGeometry","transformedGeometry","geom","vertexCount","materialIndexArray","BufferGeometryUtils.mergeGeometries","resizeDataTexture","w","h","THREE.DataTexture","THREE.RGBAFormat","THREE.FloatType","dpr","resolutionScale","runPathTracingLoop","width","height","data","bounces","skyIntensity","skyMode","smoothNormals","radianceColor","throughputColor","ssPoint","THREE.Vector2","rayStack","THREE.Ray","lightForward","lightWidth","lightHeight","raycaster","THREE.Raycaster","seedRay","lastStartTime","randomOffsetX","randomOffsetY","antiAliasIndex","y","pathTrace","index","g","delta","expandHitInformation","ray","accumulatedRoughness","object","normalAttr","materialAttr","face","point","hitFrontFace","materialIndex","currentRay","lastPdf","objects","lightColor","lightDistSq","lightArea","lightPdf","weight","nextRay","shadowHit","materialPdf","misWeight","isBelowSurface","emissive","emissiveIntensity","sampleSkyBox","angleStep","thetaEven","phiEven","isBlack","value","THREE.MathUtils","value2","toHumanReadableTime","ms","seconds","minutes","minutesString","secondsString","key","model","m","fade"],"mappings":"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"}