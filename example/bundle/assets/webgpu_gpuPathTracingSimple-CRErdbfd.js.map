{"version":3,"file":"webgpu_gpuPathTracingSimple-CRErdbfd.js","sources":["../../../src/webgpu/bvh_ray_functions.wgsl.js","../../webgpu_gpuPathTracingSimple.js"],"sourcesContent":["import { wgslFn } from 'three/tsl';\nimport { bvhNodeStruct, intersectionResultStruct, intersectsBounds, rayStruct, constants } from './common_functions.wgsl.js';\n\nexport const intersectsTriangle = wgslFn( /* wgsl */ `\n\n\tfn intersectsTriangle( ray: Ray, a: vec3f, b: vec3f, c: vec3f ) -> IntersectionResult {\n\n\t\tvar result: IntersectionResult;\n\t\tresult.didHit = false;\n\n\t\tlet edge1 = b - a;\n\t\tlet edge2 = c - a;\n\t\tlet n = cross( edge1, edge2 );\n\n\t\tlet det = - dot( ray.direction, n );\n\n\t\tif ( abs( det ) < TRI_INTERSECT_EPSILON ) {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tlet invdet = 1.0 / det;\n\n\t\tlet AO = ray.origin - a;\n\t\tlet DAO = cross( AO, ray.direction );\n\n\t\tlet u = dot( edge2, DAO ) * invdet;\n\t\tlet v = -dot( edge1, DAO ) * invdet;\n\t\tlet t = dot( AO, n ) * invdet;\n\n\t\tlet w = 1.0 - u - v;\n\n\t\tif ( u < - TRI_INTERSECT_EPSILON || v < - TRI_INTERSECT_EPSILON || w < - TRI_INTERSECT_EPSILON || t < TRI_INTERSECT_EPSILON ) {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tresult.didHit = true;\n\t\tresult.barycoord = vec3f( w, u, v );\n\t\tresult.dist = t;\n\t\tresult.side = sign( det );\n\t\tresult.normal = result.side * normalize( n );\n\n\t\treturn result;\n\n\t}\n\n`, [ rayStruct, intersectionResultStruct, constants ] );\n\nexport const intersectTriangles = wgslFn( /* wgsl */ `\n\n\tfn intersectTriangles(\n\t\tbvh_position: ptr<storage, array<vec3f>, read>,\n\t\tbvh_index: ptr<storage, array<vec3u>, read>,\n\t\toffset: u32,\n\t\tcount: u32,\n\t\tray: Ray\n\t) -> IntersectionResult {\n\n\t\tvar closestResult: IntersectionResult;\n\n\t\tclosestResult.didHit = false;\n\t\tclosestResult.dist = INFINITY;\n\n\t\tfor ( var i = offset; i < offset + count; i = i + 1u ) {\n\n\t\t\tlet indices = bvh_index[ i ];\n\t\t\tlet a = bvh_position[ indices.x ];\n\t\t\tlet b = bvh_position[ indices.y ];\n\t\t\tlet c = bvh_position[ indices.z ];\n\n\t\t\tvar triResult = intersectsTriangle( ray, a, b, c );\n\n\t\t\tif ( triResult.didHit && triResult.dist < closestResult.dist ) {\n\n\t\t\t\tclosestResult = triResult;\n\t\t\t\tclosestResult.indices = vec4u( indices.xyz, i );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n`, [ intersectsTriangle, rayStruct, intersectionResultStruct, constants ] );\n\nexport const bvhIntersectFirstHit = wgslFn( /* wgsl */ `\n\n\tfn bvhIntersectFirstHit(\n\t\tbvh_index: ptr<storage, array<vec3u>, read>,\n\t\tbvh_position: ptr<storage, array<vec3f>, read>,\n\t\tbvh: ptr<storage, array<BVHNode>,read>,\n\t\tray: Ray,\n\t) -> IntersectionResult {\n\n\t\tvar pointer = 0;\n\t\tvar stack: array<u32, BVH_STACK_DEPTH>;\n\t\tstack[ 0 ] = 0u;\n\n\t\tvar bestHit: IntersectionResult;\n\n\t\tbestHit.didHit = false;\n\t\tbestHit.dist = INFINITY;\n\n\t\tloop {\n\n\t\t\tif ( pointer < 0 || pointer >= i32( BVH_STACK_DEPTH ) ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlet currNodeIndex = stack[ pointer ];\n\t\t\tlet node = bvh[ currNodeIndex ];\n\n\t\t\tpointer = pointer - 1;\n\n\t\t\tvar boundsHitDistance: f32 = 0.0;\n\n\t\t\tif ( ! intersectsBounds( ray, node.bounds, &boundsHitDistance ) || boundsHitDistance > bestHit.dist ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tlet boundsInfox = node.splitAxisOrTriangleCount;\n\t\t\tlet boundsInfoy = node.rightChildOrTriangleOffset;\n\n\t\t\tlet isLeaf = ( boundsInfox & 0xffff0000u ) != 0u;\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tlet count = boundsInfox & 0x0000ffffu;\n\t\t\t\tlet offset = boundsInfoy;\n\n\t\t\t\tlet localHit = intersectTriangles(\n\t\t\t\t\tbvh_position, bvh_index, offset,\n\t\t\t\t\tcount, ray\n\t\t\t\t);\n\n\t\t\t\tif ( localHit.didHit && localHit.dist < bestHit.dist ) {\n\n\t\t\t\t\tbestHit = localHit;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlet leftIndex = currNodeIndex + 1u;\n\t\t\t\tlet splitAxis = boundsInfox & 0x0000ffffu;\n\t\t\t\tlet rightIndex = currNodeIndex + boundsInfoy;\n\n\t\t\t\tlet leftToRight = ray.direction[splitAxis] >= 0.0;\n\t\t\t\tlet c1 = select( rightIndex, leftIndex, leftToRight );\n\t\t\t\tlet c2 = select( leftIndex, rightIndex, leftToRight );\n\n\t\t\t\tpointer = pointer + 1;\n\t\t\t\tstack[ pointer ] = c2;\n\n\t\t\t\tpointer = pointer + 1;\n\t\t\t\tstack[ pointer ] = c1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestHit;\n\n\t}\n\n`, [ intersectTriangles, intersectsBounds, rayStruct, bvhNodeStruct, intersectionResultStruct, constants ] );\n","import * as THREE from 'three';\nimport { WebGPURenderer, StorageBufferAttribute, StorageTexture, MeshBasicNodeMaterial } from 'three/webgpu';\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\nimport { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';\nimport Stats from 'three/addons/libs/stats.module.js';\nimport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\nimport {\n\tattribute, uniform, wgslFn, varyingProperty,\n\ttextureStore, texture, colorSpaceToWorking,\n\tstorage, workgroupId, localId,\n} from 'three/tsl';\n\n// three-mesh-bvh\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\nimport { ndcToCameraRay, bvhIntersectFirstHit, getVertexAttribute } from 'three-mesh-bvh/webgpu';\n\nconst params = {\n\tenableRaytracing: true,\n\tanimate: true,\n\tresolutionScale: 1.0 / window.devicePixelRatio,\n\tsmoothNormals: true,\n};\n\nlet renderer, camera, scene, gui, stats;\nlet fsQuad, mesh, clock, controls;\nlet fsMaterial, computeKernel, outputTex;\nlet dispatchSize = [];\nconst WORKGROUP_SIZE = [ 8, 8, 1 ];\n\ninit();\n\nfunction init() {\n\n\t// renderer\n\trenderer = new WebGPURenderer( {\n\n\t\tcanvas: document.createElement( 'canvas' ),\n\t\tantialias: true,\n\t\tforceWebGL: false,\n\n\t} );\n\trenderer.setAnimationLoop( render );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setClearColor( 0x09141a );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.outputColorSpace = THREE.SRGBColorSpace;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene init\n\tscene = new THREE.Scene();\n\n\t// light init\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xb0bec5, 0.5 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10 );\n\tcamera.position.set( 0, 0, 4 );\n\tcamera.updateProjectionMatrix();\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// geometry init\n\tconst knotGeometry = new THREE.TorusKnotGeometry( 1, 0.3, 300, 50 );\n\tconst bvh = new MeshBVH( knotGeometry, { maxLeafSize: 1, strategy: SAH } );\n\tmesh = new THREE.Mesh( knotGeometry, new THREE.MeshStandardMaterial() );\n\tscene.add( mesh );\n\n\t// animation\n\tclock = new THREE.Clock();\n\n\t// TSL\n\tconst geom_index = new StorageBufferAttribute( knotGeometry.index.array, 3 );\n\tconst geom_position = new StorageBufferAttribute( knotGeometry.attributes.position.array, 3 );\n\tconst geom_normals = new StorageBufferAttribute( knotGeometry.attributes.normal.array, 3 );\n\tconst bvhNodes = new StorageBufferAttribute( new Float32Array( bvh._roots[ 0 ] ), 8 );\n\n\tconst computeShaderParams = {\n\t\toutputTex: textureStore( outputTex ),\n\t\tsmoothNormals: uniform( 1 ),\n\n\t\t// transforms\n\t\tinverseProjectionMatrix: uniform( new THREE.Matrix4() ),\n\t\tcameraToModelMatrix: uniform( new THREE.Matrix4() ),\n\n\t\t// bvh and geometry definition\n\t\tgeom_index: storage( geom_index, 'uvec3', geom_index.count ).toReadOnly(),\n\t\tgeom_position: storage( geom_position, 'vec3', geom_position.count ).toReadOnly(),\n\t\tgeom_normals: storage( geom_normals, 'vec3', geom_normals.count ).toReadOnly(),\n\t\tbvh: storage( bvhNodes, 'BVHNode', bvhNodes.count ).toReadOnly(),\n\n\t\t// compute variables\n\t\tworkgroupSize: uniform( new THREE.Vector3() ),\n\t\tworkgroupId: workgroupId,\n\t\tlocalId: localId\n\t};\n\n\tconst computeShader = wgslFn( /* wgsl */`\n\n\t\tfn compute(\n\t\t\toutputTex: texture_storage_2d<rgba8unorm, write>,\n\t\t\tsmoothNormals: u32,\n\t\t\tinverseProjectionMatrix: mat4x4f,\n\t\t\tcameraToModelMatrix: mat4x4f,\n\t\t\tgeom_position: ptr<storage, array<vec3f>, read>,\n\t\t\tgeom_index: ptr<storage, array<vec3u>, read>,\n\t\t\tgeom_normals: ptr<storage, array<vec3f>, read>,\n\t\t\tbvh: ptr<storage, array<BVHNode>, read>,\n\t\t\tworkgroupSize: vec3u,\n\t\t\tworkgroupId: vec3u,\n\t\t\tlocalId: vec3u,\n\t\t) -> void {\n\n\t\t\t// to screen coordinates\n\t\t\tlet dimensions = textureDimensions( outputTex );\n\t\t\tlet indexUV = workgroupSize.xy * workgroupId.xy + localId.xy;\n\t\t\tlet uv = vec2f( indexUV ) / vec2f( dimensions );\n\t\t\tlet ndc = uv * 2.0 - vec2f( 1.0 );\n\n\t\t\t// scene ray\n\t\t\tvar ray = ndcToCameraRay( ndc, cameraToModelMatrix * inverseProjectionMatrix );\n\n\t\t\t// get hit result\n\t\t\tlet hitResult = bvhIntersectFirstHit( geom_index, geom_position, bvh, ray );\n\n\t\t\t// write result\n\t\t\tif ( hitResult.didHit && hitResult.dist < 1.0 ) {\n\n\t\t\t\tlet normal = select(\n\t\t\t\t\thitResult.normal,\n\t\t\t\t\tnormalize( getVertexAttribute( hitResult.barycoord, hitResult.indices.xyz, geom_normals ) ),\n\t\t\t\t\tsmoothNormals > 0u,\n\t\t\t\t);\n\t\t\t\ttextureStore( outputTex, indexUV, vec4f( normal, 1.0 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet background = vec4f( 0.0366, 0.0813, 0.1057, 1.0 );\n\t\t\t\ttextureStore( outputTex, indexUV, background );\n\n\t\t\t}\n\n\t\t}\n\t`, [ ndcToCameraRay, bvhIntersectFirstHit, getVertexAttribute ] );\n\n\tcomputeKernel = computeShader( computeShaderParams ).computeKernel( WORKGROUP_SIZE );\n\n\t// screen quad\n\tconst vUv = varyingProperty( 'vec2', 'vUv' );\n\tconst wgslVertexShader = wgslFn( /* wgsl */`\n\t\tfn vertex( position: vec3f, uv: vec2f ) -> vec3f {\n\t\t\tvaryings.vUv = uv;\n\t\t\treturn position;\n\t\t}\n\t`, [ vUv ] );\n\n\tfsMaterial = new MeshBasicNodeMaterial();\n\tfsMaterial.positionNode = wgslVertexShader( {\n\t\tposition: attribute( 'position' ),\n\t\tuv: attribute( 'uv' )\n\t} );\n\n\tfsMaterial.colorNode = colorSpaceToWorking( texture( outputTex, vUv ), THREE.SRGBColorSpace );\n\tfsQuad = new FullScreenQuad( fsMaterial );\n\n\t// controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\t// gui\n\tgui = new GUI();\n\tgui.add( params, 'enableRaytracing' );\n\tgui.add( params, 'animate' );\n\tgui.add( params, 'smoothNormals' );\n\tgui.add( params, 'resolutionScale', 0.1, 1, 0.01 ).onChange( resize );\n\tgui.open();\n\n\t// resize\n\twindow.addEventListener( 'resize', resize, false );\n\tresize();\n\n}\n\nfunction resize() {\n\n\tconst w = window.innerWidth;\n\tconst h = window.innerHeight;\n\tconst dpr = window.devicePixelRatio;\n\tconst scale = params.resolutionScale;\n\n\tcamera.aspect = w / h;\n\tcamera.updateProjectionMatrix();\n\n\trenderer.setSize( w, h );\n\trenderer.setPixelRatio( dpr );\n\n\t// reconstruct texture\n\tif ( outputTex ) {\n\n\t\toutputTex.dispose();\n\n\t}\n\n\toutputTex = new StorageTexture( w * dpr * scale, h * dpr * scale );\n\toutputTex.format = THREE.RGBAFormat;\n\toutputTex.type = THREE.UnsignedByteType;\n\toutputTex.magFilter = THREE.LinearFilter;\n\n}\n\nfunction render() {\n\n\tstats.update();\n\n\tconst delta = clock.getDelta();\n\tif ( params.animate ) {\n\n\t\tmesh.rotation.y += delta;\n\n\t}\n\n\tif ( params.enableRaytracing ) {\n\n\t\tdispatchSize = [\n\t\t\tMath.ceil( outputTex.width / WORKGROUP_SIZE[ 0 ] ),\n\t\t\tMath.ceil( outputTex.height / WORKGROUP_SIZE[ 1 ] ),\n\t\t];\n\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tcomputeKernel.computeNode.parameters.outputTex.value = outputTex;\n\t\tcomputeKernel.computeNode.parameters.smoothNormals.value = Number( params.smoothNormals );\n\t\tcomputeKernel.computeNode.parameters.inverseProjectionMatrix.value = camera.projectionMatrixInverse;\n\t\tcomputeKernel.computeNode.parameters.cameraToModelMatrix.value.copy( mesh.matrixWorld ).invert().multiply( camera.matrixWorld );\n\t\tcomputeKernel.computeNode.parameters.workgroupSize.value.fromArray( WORKGROUP_SIZE );\n\t\trenderer.compute( computeKernel, dispatchSize );\n\n\t\tfsMaterial.colorNode.colorNode.value = outputTex;\n\t\tfsQuad.render( renderer );\n\n\t} else {\n\n\t\trenderer.render( scene, camera );\n\n\t}\n\n}\n"],"names":["intersectsTriangle","wgslFn","rayStruct","intersectionResultStruct","constants","intersectTriangles","bvhIntersectFirstHit","intersectsBounds","bvhNodeStruct","params","renderer","camera","scene","gui","stats","fsQuad","mesh","clock","fsMaterial","computeKernel","outputTex","dispatchSize","WORKGROUP_SIZE","init","WebGPURenderer","render","THREE.SRGBColorSpace","THREE.Scene","light","THREE.DirectionalLight","THREE.AmbientLight","THREE.PerspectiveCamera","Stats","knotGeometry","THREE.TorusKnotGeometry","bvh","MeshBVH","SAH","THREE.Mesh","THREE.MeshStandardMaterial","THREE.Clock","geom_index","StorageBufferAttribute","geom_position","geom_normals","bvhNodes","computeShaderParams","textureStore","uniform","THREE.Matrix4","storage","THREE.Vector3","workgroupId","localId","ndcToCameraRay","getVertexAttribute","vUv","varyingProperty","wgslVertexShader","MeshBasicNodeMaterial","attribute","colorSpaceToWorking","texture","FullScreenQuad","OrbitControls","GUI","resize","w","h","dpr","scale","StorageTexture","THREE.RGBAFormat","THREE.UnsignedByteType","THREE.LinearFilter","delta"],"mappings":"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"}