{"version":3,"file":"MeshBVH-DQV6PBDm.js","sources":["../../../src/core/Constants.js","../../../src/utils/ArrayBoxUtilities.js","../../../src/core/utils/nodeBufferUtils.js","../../../src/core/build/computeBoundsUtils.js","../../../src/core/build/splitUtils.js","../../../src/core/BVHNode.js","../../../src/core/build/sortUtils.js","../../../src/core/build/buildUtils.js","../../../src/core/build/buildTree.js","../../../src/utils/PrimitivePool.js","../../../src/core/utils/BufferStack.js","../../../src/core/cast/shapecast.js","../../../src/core/cast/bvhcast.js","../../../src/core/BVH.js","../../../src/utils/BufferUtils.js","../../../src/core/build/geometryUtils.js","../../../src/core/GeometryBVH.js","../../../src/math/OrientedBox.js","../../../src/utils/ExtendedTrianglePool.js","../../../src/core/cast/closestPointToPoint.js","../../../src/utils/ThreeRayIntersectUtilities.js","../../../src/utils/TriangleUtilities.js","../../../src/core/utils/iterationUtils.generated.js","../../../src/core/cast/refit.generated.js","../../../src/core/utils/intersectUtils.js","../../../src/core/utils/iterationUtils_indirect.generated.js","../../../src/core/cast/raycast.generated.js","../../../src/core/cast/raycastFirst.generated.js","../../../src/core/cast/intersectsGeometry.generated.js","../../../src/core/cast/closestPointToGeometry.generated.js","../../../src/core/cast/refit_indirect.generated.js","../../../src/core/cast/raycast_indirect.generated.js","../../../src/core/cast/raycastFirst_indirect.generated.js","../../../src/core/cast/intersectsGeometry_indirect.generated.js","../../../src/core/cast/closestPointToGeometry_indirect.generated.js","../../../src/utils/GeometryRayIntersectUtilities.js","../../../src/core/MeshBVH.js"],"sourcesContent":["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a primitive intersection vs traversing\n// bounds.\n// TODO: could be tuned per primitive type (triangles vs lines vs points)\nexport const PRIMITIVE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const UINT32_PER_NODE = BYTES_PER_NODE / 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// Bit masks for 32 bit node data\nexport const LEAFNODE_MASK_32 = IS_LEAFNODE_FLAG << 16;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafSize: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n\trange: null,\n\t[ SKIP_GENERATION ]: false,\n};\n\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided primitive bounds\nexport function expandByPrimitiveBounds( startIndex, primitiveBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = primitiveBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = primitiveBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { IS_LEAFNODE_FLAG, UINT32_PER_NODE } from '../Constants.js';\n\nexport function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === IS_LEAFNODE_FLAG;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\n// Returns the uint32-aligned offset of the left child node for performance\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + UINT32_PER_NODE;\n\n}\n\n// Returns the uint32-aligned offset of the right child node for performance\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\t// stored value is relative offset from parent, convert to absolute uint32 index\n\tconst relativeOffset = uint32Array[ n32 + 6 ];\n\treturn n32 + relativeOffset * UINT32_PER_NODE;\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","// computes the union of the bounds of all of the given primitives and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the primitives, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( primitiveBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst boundsOffset = primitiveBounds.offset || 0;\n\tfor ( let i = ( offset - boundsOffset ) * 6, end = ( offset + count - boundsOffset ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = primitiveBounds[ i + 0 ];\n\t\tconst hx = primitiveBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = primitiveBounds[ i + 2 ];\n\t\tconst hy = primitiveBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = primitiveBounds[ i + 4 ];\n\t\tconst hz = primitiveBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByPrimitiveBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, PRIMITIVE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = /* @__PURE__ */ new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = /* @__PURE__ */ new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, primitiveBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( primitiveBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = PRIMITIVE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst boundsOffset = primitiveBounds.offset || 0;\n\t\tconst cStart = ( offset - boundsOffset ) * 6;\n\t\tconst cEnd = ( offset + count - boundsOffset ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer primitives than we're planning to split then just check all\n\t\t\t// the primitive positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each primitive and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + PRIMITIVE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = primitiveBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByPrimitiveBounds( c, primitiveBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no primitives\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + PRIMITIVE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `BVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of all the provided primitives\nfunction getAverage( primitiveBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tconst boundsOffset = primitiveBounds.offset;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += primitiveBounds[ ( i - boundsOffset ) * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class BVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","// reorders the partition buffer such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nexport function partition( buffer, stride, primitiveBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\tconst boundsOffset = primitiveBounds.offset || 0;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && primitiveBounds[ ( left - boundsOffset ) * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a primitive center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && primitiveBounds[ ( right - boundsOffset ) * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the primitives at index\n\t\t\t// left and right; that's the elements in the partition buffer and the bounds\n\t\t\tfor ( let i = 0; i < stride; i ++ ) {\n\n\t\t\t\tlet t0 = buffer[ left * stride + i ];\n\t\t\t\tbuffer[ left * stride + i ] = buffer[ right * stride + i ];\n\t\t\t\tbuffer[ right * stride + i ] = t0;\n\n\t\t\t}\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst l = left - boundsOffset;\n\t\t\t\tconst r = right - boundsOffset;\n\t\t\t\tconst tb = primitiveBounds[ l * 6 + i ];\n\t\t\t\tprimitiveBounds[ l * 6 + i ] = primitiveBounds[ r * 6 + i ];\n\t\t\t\tprimitiveBounds[ r * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst node32Index = byteOffset / 4;\n\tconst node16Index = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ node32Index + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tuint8Array.set( new Uint8Array( node.buffer ), byteOffset );\n\t\t\treturn byteOffset + node.buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tuint32Array[ node32Index + 6 ] = node.offset;\n\t\t\tuint16Array[ node16Index + 14 ] = node.count;\n\t\t\tuint16Array[ node16Index + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst { left, right, splitAxis } = node;\n\n\t\t// fill in the left node contents\n\t\tconst leftByteOffset = byteOffset + BYTES_PER_NODE;\n\t\tlet rightByteOffset = _populateBuffer( leftByteOffset, left );\n\n\t\t// calculate relative offset from parent to right child\n\t\tconst currentNodeIndex = byteOffset / BYTES_PER_NODE;\n\t\tconst rightNodeIndex = rightByteOffset / BYTES_PER_NODE;\n\t\tconst relativeRightIndex = rightNodeIndex - currentNodeIndex;\n\n\t\t// check if the relative offset is too high\n\t\tif ( relativeRightIndex > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store relative child node offset greater than 32 bits.' );\n\n\t\t}\n\n\t\t// fill in the right node contents (store as relative offset)\n\t\tuint32Array[ node32Index + 6 ] = relativeRightIndex;\n\t\tuint32Array[ node32Index + 7 ] = splitAxis;\n\n\t\t// return the next available buffer pointer\n\t\treturn _populateBuffer( rightByteOffset, right );\n\n\t}\n\n}\n","import { getBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { BVHNode } from '../BVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function buildTree( bvh, primitiveBounds, offset, count, options, loadRange ) {\n\n\t// expand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafSize,\n\t\tstrategy,\n\t\tonProgress,\n\t} = options;\n\n\tconst partitionBuffer = bvh.primitiveBuffer;\n\tconst partitionStride = bvh.primitiveBufferStride;\n\n\t// generate intermediate variables\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new BVHNode();\n\tgetBounds( primitiveBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( primitivesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( ( primitivesProcessed - loadRange.offset ) / loadRange.count );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its primitives and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `BVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafSize || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, primitiveBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( partitionBuffer, partitionStride, primitiveBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new BVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( primitiveBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new BVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( primitiveBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\t// get the range of buffer data to construct / arrange\n\tconst rootRanges = bvh.getRootRanges( options.range );\n\tconst firstRange = rootRanges[ 0 ];\n\tconst lastRange = rootRanges[ rootRanges.length - 1 ];\n\tconst fullRange = {\n\t\toffset: firstRange.offset,\n\t\tcount: lastRange.offset + lastRange.count - firstRange.offset,\n\t};\n\n\t// construct the primitive bounds for sorting\n\tconst primitiveBounds = new Float32Array( 6 * fullRange.count );\n\tprimitiveBounds.offset = fullRange.offset;\n\tbvh.computePrimitiveBounds( fullRange.offset, fullRange.count, primitiveBounds );\n\n\t// Build BVH roots\n\tbvh._roots = rootRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, primitiveBounds, range.offset, range.count, options, fullRange );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = /* @__PURE__ */ new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED, UINT32_PER_NODE } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexOffset + nodeIndex32 / UINT32_PER_NODE, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexOffset + c1 / UINT32_PER_NODE, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexOffset + c2 / UINT32_PER_NODE, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { BYTES_PER_NODE, UINT32_PER_NODE } from '../Constants.js';\n\nconst _bufferStack1 = /* @__PURE__ */ new BufferStack.constructor();\nconst _bufferStack2 = /* @__PURE__ */ new BufferStack.constructor();\nconst _boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\nconst _leftBox1 = /* @__PURE__ */ new Box3();\nconst _rightBox1 = /* @__PURE__ */ new Box3();\n\nconst _leftBox2 = /* @__PURE__ */ new Box3();\nconst _rightBox2 = /* @__PURE__ */ new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet nodeOffset1 = 0;\n\tlet nodeOffset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\tnodeOffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\tnodeOffset1, nodeOffset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\tnodeOffset2 += otherRoots[ j ].byteLength / BYTES_PER_NODE;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\tnodeOffset1 += roots[ i ].byteLength / BYTES_PER_NODE;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexOffset = 0,\n\tnode2IndexOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\t// Note the \"nodeIndex\" values are just intended to be used as unique identifiers in the tree and\n\t\t// not used for accessing data\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexOffset + node2Index32 / UINT32_PER_NODE,\n\t\t\t\tdepth1, node1IndexOffset + node1Index32 / UINT32_PER_NODE,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexOffset + node1Index32 / UINT32_PER_NODE,\n\t\t\t\tdepth2, node2IndexOffset + node2Index32 / UINT32_PER_NODE,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexOffset, node2IndexOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexOffset, node1IndexOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { Box3 } from 'three';\nimport { BYTES_PER_NODE, UINT32_PER_NODE, DEFAULT_OPTIONS, FLOAT32_EPSILON } from './Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, LEFT_NODE, RIGHT_NODE, SPLIT_AXIS, COUNT, OFFSET } from './utils/nodeBufferUtils.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { shapecast as shapecastFunc } from './cast/shapecast.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst _tempBox = /* @__PURE__ */ new Box3();\nconst _tempBuffer = /* @__PURE__ */ new Float32Array( 6 );\n\nexport class BVH {\n\n\tconstructor() {\n\n\t\tthis._roots = null;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = null;\n\n\t}\n\n\tinit( options ) {\n\n\t\toptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\n\t\tbuildPackedTree( this, options );\n\n\t}\n\n\tgetRootRanges( /* range */ ) {\n\n\t\t// TODO: can we avoid passing range in here?\n\t\tthrow new Error( 'BVH: getRootRanges() not implemented' );\n\n\t}\n\n\t// write the i-th primitive bounds in a 6-value min / max format to the buffer\n\t// starting at the given \"writeOffset\"\n\twritePrimitiveBounds( /* i, buffer, writeOffset */ ) {\n\n\t\tthrow new Error( 'BVH: writePrimitiveBounds() not implemented' );\n\n\t}\n\n\t// writes the union bounds of all primitives in the given range in a min / max format\n\t// to the buffer\n\twritePrimitiveRangeBounds( offset, count, targetBuffer, baseIndex ) {\n\n\t\t// Initialize bounds\n\t\tlet minX = Infinity;\n\t\tlet minY = Infinity;\n\t\tlet minZ = Infinity;\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\t// compute union of all bounds\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tthis.writePrimitiveBounds( i, _tempBuffer, 0 );\n\n\t\t\t// compute union\n\t\t\tconst [ lx, ly, lz, rx, ry, rz ] = _tempBuffer;\n\t\t\tif ( lx < minX ) minX = lx;\n\t\t\tif ( rx > maxX ) maxX = rx;\n\t\t\tif ( ly < minY ) minY = ly;\n\t\t\tif ( ry > maxY ) maxY = ry;\n\t\t\tif ( lz < minZ ) minZ = lz;\n\t\t\tif ( rz > maxZ ) maxZ = rz;\n\n\t\t}\n\n\t\t// write bounds\n\t\ttargetBuffer[ baseIndex + 0 ] = minX;\n\t\ttargetBuffer[ baseIndex + 1 ] = minY;\n\t\ttargetBuffer[ baseIndex + 2 ] = minZ;\n\t\ttargetBuffer[ baseIndex + 3 ] = maxX;\n\t\ttargetBuffer[ baseIndex + 4 ] = maxY;\n\t\ttargetBuffer[ baseIndex + 5 ] = maxZ;\n\n\t\treturn targetBuffer;\n\n\t}\n\n\tcomputePrimitiveBounds( offset, count, targetBuffer ) {\n\n\t\tconst boundsOffset = targetBuffer.offset || 0;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tthis.writePrimitiveBounds( i, _tempBuffer, 0 );\n\n\t\t\t// construction primitive bounds requires a center + half extents format\n\t\t\tconst [ lx, ly, lz, rx, ry, rz ] = _tempBuffer;\n\n\t\t\tconst cx = ( lx + rx ) / 2;\n\t\t\tconst cy = ( ly + ry ) / 2;\n\t\t\tconst cz = ( lz + rz ) / 2;\n\n\t\t\tconst hx = ( rx - lx ) / 2;\n\t\t\tconst hy = ( ry - ly ) / 2;\n\t\t\tconst hz = ( rz - lz ) / 2;\n\n\t\t\tconst baseIndex = ( i - boundsOffset ) * 6;\n\t\t\ttargetBuffer[ baseIndex + 0 ] = cx;\n\t\t\ttargetBuffer[ baseIndex + 1 ] = hx + ( Math.abs( cx ) + hx ) * FLOAT32_EPSILON;\n\t\t\ttargetBuffer[ baseIndex + 2 ] = cy;\n\t\t\ttargetBuffer[ baseIndex + 3 ] = hy + ( Math.abs( cy ) + hy ) * FLOAT32_EPSILON;\n\t\t\ttargetBuffer[ baseIndex + 4 ] = cz;\n\t\t\ttargetBuffer[ baseIndex + 5 ] = hz + ( Math.abs( cz ) + hz ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\tshiftPrimitiveOffsets( offset ) {\n\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tif ( indirectBuffer ) {\n\n\t\t\t// the offsets are embedded in the indirect buffer\n\t\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\t\tindirectBuffer[ i ] += offset;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// offsets are embedded in the leaf nodes\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let rootIndex = 0; rootIndex < roots.length; rootIndex ++ ) {\n\n\t\t\t\tconst root = roots[ rootIndex ];\n\t\t\t\tconst uint32Array = new Uint32Array( root );\n\t\t\t\tconst uint16Array = new Uint16Array( root );\n\t\t\t\tconst totalNodes = root.byteLength / BYTES_PER_NODE;\n\t\t\t\tfor ( let node = 0; node < totalNodes; node ++ ) {\n\n\t\t\t\t\tconst node32Index = UINT32_PER_NODE * node;\n\t\t\t\t\tconst node16Index = 2 * node32Index;\n\t\t\t\t\tif ( IS_LEAF( node16Index, uint16Array ) ) {\n\n\t\t\t\t\t\t// offset value\n\t\t\t\t\t\tuint32Array[ node32Index + 6 ] += offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = IS_LEAF( node16Index, uint16Array );\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\tconst left = LEFT_NODE( node32Index );\n\t\t\t\tconst right = RIGHT_NODE( node32Index, uint32Array );\n\t\t\t\tconst splitAxis = SPLIT_AXIS( node32Index, uint32Array );\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\trefit( /* nodeIndices = null */ ) {\n\n\t\t// TODO: add support for \"nodeIndices\"\n\t\t// if ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t// \tnodeIndices = new Set( nodeIndices );\n\n\t\t// }\n\n\t\tconst roots = this._roots;\n\t\tfor ( let rootIndex = 0, rootCount = roots.length; rootIndex < rootCount; rootIndex ++ ) {\n\n\t\t\tconst buffer = roots[ rootIndex ];\n\t\t\tconst uint32Array = new Uint32Array( buffer );\n\t\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t\tconst float32Array = new Float32Array( buffer );\n\t\t\tconst totalNodes = buffer.byteLength / BYTES_PER_NODE;\n\n\t\t\t// Traverse nodes from right to left so children are updated before parents\n\t\t\tfor ( let nodeIndex = totalNodes - 1; nodeIndex >= 0; nodeIndex -- ) {\n\n\t\t\t\tconst nodeIndex32 = nodeIndex * UINT32_PER_NODE;\n\t\t\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\t\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t// get the bounds\n\t\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\t\tthis.writePrimitiveRangeBounds( offset, count, _tempBuffer, 0 );\n\n\t\t\t\t\t// write directly to node bounds (already in min/max format)\n\t\t\t\t\tfloat32Array.set( _tempBuffer, nodeIndex32 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t\t\t// Union the bounds of left and right children\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst leftMin = float32Array[ left + i ];\n\t\t\t\t\t\tconst leftMax = float32Array[ left + i + 3 ];\n\t\t\t\t\t\tconst rightMin = float32Array[ right + i ];\n\t\t\t\t\t\tconst rightMax = float32Array[ right + i + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = leftMin < rightMin ? leftMin : rightMin;\n\t\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = leftMax > rightMax ? leftMax : rightMax;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), _tempBox );\n\t\t\ttarget.union( _tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n\t// Base shapecast implementation that can be used by subclasses\n\t// TODO: see if we can get rid of \"iterateFunc\" here as well as the primitive so the function\n\t// API aligns with the \"shapecast\" implementation\n\tshapecast( callbacks ) {\n\n\t\t// TODO: can we get rid of \"scratchPrimitive\" and / or \"iterate\"? Or merge them somehow\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsPrimitive,\n\t\t\tscratchPrimitive,\n\t\t\titerate,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsPrimitive ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterate( offset, count, this, intersectsPrimitive, contained, depth, scratchPrimitive );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsPrimitive ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterate( offset, count, this, intersectsPrimitive, contained, depth, scratchPrimitive );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet nodeOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecastFunc( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, nodeOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeOffset += root.byteLength / BYTES_PER_NODE;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet { intersectsRanges } = callbacks;\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\n\t}\n\n}\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getFullPrimitiveRange( geo, range, stride ) {\n\n\tconst primitiveCount = getVertexCount( geo ) / stride;\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst start = drawRange.start / stride;\n\tconst end = ( drawRange.start + drawRange.count ) / stride;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( primitiveCount, end ) - offset;\n\treturn {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t};\n\n}\n\nfunction getPrimitiveGroupRanges( geo, stride ) {\n\n\treturn geo.groups.map( group => ( {\n\t\toffset: group.start / stride,\n\t\tcount: group.count / stride,\n\t} ));\n\n}\n\n// Function that extracts a set of mutually exclusive ranges representing the primitives being\n// drawn as determined by the geometry groups, draw range, and user specified range\nexport function getRootPrimitiveRanges( geo, range, stride ) {\n\n\tconst drawRange = getFullPrimitiveRange( geo, range, stride );\n\tconst primitiveRanges = getPrimitiveGroupRanges( geo, stride );\n\tif ( ! primitiveRanges.length ) {\n\n\t\treturn [ drawRange ];\n\n\t}\n\n\tconst ranges = [];\n\tconst drawRangeStart = drawRange.offset;\n\tconst drawRangeEnd = drawRange.offset + drawRange.count;\n\n\t// Create events for group boundaries\n\tconst primitiveCount = getVertexCount( geo ) / stride;\n\tconst events = [];\n\tfor ( const group of primitiveRanges ) {\n\n\t\t// Account for cases where group size is set to Infinity\n\t\tconst { offset, count } = group;\n\t\tconst groupStart = offset;\n\t\tconst groupCount = isFinite( count ) ? count : ( primitiveCount - offset );\n\t\tconst groupEnd = ( offset + groupCount );\n\n\t\t// Only add events if the group intersects with the draw range\n\t\tif ( groupStart < drawRangeEnd && groupEnd > drawRangeStart ) {\n\n\t\t\tevents.push( { pos: Math.max( drawRangeStart, groupStart ), isStart: true } );\n\t\t\tevents.push( { pos: Math.min( drawRangeEnd, groupEnd ), isStart: false } );\n\n\t\t}\n\n\t}\n\n\t// Sort events by position, with 'end' events before 'start' events at the same position\n\tevents.sort( ( a, b ) => {\n\n\t\tif ( a.pos !== b.pos ) {\n\n\t\t\treturn a.pos - b.pos;\n\n\t\t} else {\n\n\t\t\treturn a.type === 'end' ? - 1 : 1;\n\n\t\t}\n\n\t} );\n\n\t// sweep through events and create ranges where activeGroups > 0\n\tlet activeGroups = 0;\n\tlet lastPos = null;\n\tfor ( const event of events ) {\n\n\t\tconst newPos = event.pos;\n\t\tif ( activeGroups !== 0 && newPos !== lastPos ) {\n\n\t\t\tranges.push( {\n\t\t\t\toffset: lastPos,\n\t\t\t\tcount: newPos - lastPos,\n\t\t\t} );\n\n\t\t}\n\n\t\tactiveGroups += event.isStart ? 1 : - 1;\n\t\tlastPos = newPos;\n\n\t}\n\n\treturn ranges;\n\n}\n","import { Box3 } from 'three';\nimport { SKIP_GENERATION, DEFAULT_OPTIONS } from './Constants.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { ensureIndex, getRootPrimitiveRanges } from './build/geometryUtils.js';\nimport { BVH } from './BVH.js';\n\n// construct a new buffer that points to the set of triangles represented by the given ranges\nexport function generateIndirectBuffer( ranges, useSharedArrayBuffer ) {\n\n\tconst lastRange = ranges[ ranges.length - 1 ];\n\tconst useUint32 = lastRange.offset + lastRange.count > 2 ** 16;\n\n\t// use getRootIndexRanges which excludes gaps\n\tconst length = ranges.reduce( ( acc, val ) => acc + val.count, 0 );\n\tconst byteCount = useUint32 ? 4 : 2;\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( length * byteCount ) : new ArrayBuffer( length * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\n\t// construct a compact form of the triangles in these ranges\n\tlet index = 0;\n\tfor ( let r = 0; r < ranges.length; r ++ ) {\n\n\t\tconst { offset, count } = ranges[ r ];\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tindirectBuffer[ index + i ] = offset + i;\n\n\t\t}\n\n\t\tindex += count;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport class GeometryBVH extends BVH {\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tget primitiveStride() {\n\n\t\treturn null;\n\n\t}\n\n\tget primitiveBufferStride() {\n\n\t\treturn this.indirect ? 1 : this.primitiveStride;\n\n\t}\n\tset primitiveBufferStride( v ) {}\n\n\tget primitiveBuffer() {\n\n\t\treturn this.indirect ? this._indirectBuffer : this.geometry.index.array;\n\n\t}\n\tset primitiveBuffer( v ) {}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'BVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'BVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'BVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tsuper();\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis.resolvePrimitiveIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\t\tthis.primitiveBuffer = null;\n\t\tthis.primitiveBufferStride = null;\n\t\tthis._indirectBuffer = null;\n\n\t\toptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\n\t\t// build the BVH unless we're deserializing\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis.init( options );\n\n\t\t}\n\n\t}\n\n\tinit( options ) {\n\n\t\tconst { geometry, primitiveStride } = this;\n\n\t\tif ( options.indirect ) {\n\n\t\t\t// construct an buffer that is indirectly sorts the triangles used for the BVH\n\t\t\tconst ranges = getRootPrimitiveRanges( geometry, options.range, primitiveStride );\n\t\t\tconst indirectBuffer = generateIndirectBuffer( ranges, options.useSharedArrayBuffer );\n\t\t\tthis._indirectBuffer = indirectBuffer;\n\n\t\t} else {\n\n\t\t\tensureIndex( geometry, options );\n\n\t\t}\n\n\t\tsuper.init( options );\n\n\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t}\n\n\t}\n\n\t// Abstract methods to be implemented by subclasses\n\tgetRootRanges( range ) {\n\n\t\t// TODO: can we avoid passing options in here\n\t\tif ( this.indirect ) {\n\n\t\t\treturn [ { offset: 0, count: this._indirectBuffer.length } ];\n\n\n\t\t} else {\n\n\t\t\treturn getRootPrimitiveRanges( this.geometry, range, this.primitiveStride );\n\n\t\t}\n\n\t}\n\n\traycastObject3D( /* object, raycaster, intersects = [] */ ) {\n\n\t\tthrow new Error( 'BVH: raycastObject3D() not implemented' );\n\n\t}\n\n}\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = /* @__PURE__ */ new ExtendedTriangle();\n\tconst pointsArr = /* @__PURE__ */ new Array( 3 );\n\tconst cachedSatBounds = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = /* @__PURE__ */ new SeparatingAxisBounds();\n\tconst cachedAxis = /* @__PURE__ */ new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = /* @__PURE__ */ new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = /* @__PURE__ */ new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = /* @__PURE__ */ new Vector3();\n\tconst point2 = /* @__PURE__ */ new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide, REVISION } from 'three';\n\nconst IS_GT_REVISION_169 = parseInt( REVISION ) >= 169;\nconst IS_LT_REVISION_161 = parseInt( REVISION ) <= 161;\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = new Vector2();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv );\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.uv = res;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = new Vector2();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, intersection.uv1 );\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.uv1 = res;\n\n\t\t\t}\n\n\t\t\tif ( IS_LT_REVISION_161 ) {\n\n\t\t\t\tintersection.uv2 = intersection.uv1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = new Vector3();\n\t\t\tconst res = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, intersection.normal );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tif ( ! IS_GT_REVISION_169 ) {\n\n\t\t\t\tintersection.normal = res;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t\tif ( IS_GT_REVISION_169 ) {\n\n\t\t\tconst barycoord = new Vector3();\n\t\t\tTriangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );\n\n\t\t\tintersection.barycoord = barycoord;\n\n\t\t}\n\n\t}\n\n\treturn intersection;\n\n}\n\nfunction getSide( materialOrSide ) {\n\n\treturn materialOrSide && materialOrSide.isMaterial ? materialOrSide.side : materialOrSide;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nexport function intersectTri( geometry, materialOrSide, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst { index, groups } = geometry;\n\tif ( geometry.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geometry.attributes;\n\tif ( Array.isArray( materialOrSide ) ) {\n\n\t\t// check which groups a triangle is present in and run the intersections\n\t\t// TODO: we shouldn't need to run and intersection test multiple times\n\t\tconst firstIndex = tri * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst { start, count, materialIndex } = groups[ i ];\n\t\t\tif ( firstIndex >= start && firstIndex < start + count ) {\n\n\t\t\t\tconst side = getSide( materialOrSide[ materialIndex ] );\n\t\t\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tintersection.faceIndex = tri;\n\t\t\t\t\tintersection.face.materialIndex = materialIndex;\n\n\t\t\t\t\tif ( intersections ) {\n\n\t\t\t\t\t\tintersections.push( intersection );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn intersection;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// run the intersection for the single material\n\t\tconst side = getSide( materialOrSide );\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tintersection.face.materialIndex = 0;\n\n\t\t\tif ( intersections ) {\n\n\t\t\t\tintersections.push( intersection );\n\n\t\t\t} else {\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n}\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract barycoord\n\tconst barycoord = target && target.barycoord ? target.barycoord : new Vector3();\n\tTriangle.getBarycoord( point, tempV1, tempV2, tempV3, barycoord );\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\t\ttarget.barycoord = barycoord;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv,\n\t\t\tbarycoord: barycoord,\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n\nfunction intersectTris( bvh, materialOrSide, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, materialOrSide, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, materialOrSide, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, materialOrSide, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { UINT32_PER_NODE, BYTES_PER_NODE } from '../Constants.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( nodeIndex32, byteOffset, force = false ) {\n\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] = minx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] = miny;\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] = maxx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] = maxy;\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tconst leftNodeId = left / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tconst rightNodeId = right / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tincludesLeft = nodeIndices.has( leftNodeId );\n\t\t\t\t\tincludesRight = nodeIndices.has( rightNodeId );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst left_i = left + i;\n\t\t\t\t\tconst right_i = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ left_i ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ left_i + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ right_i ];\n\t\t\t\t\tconst maxRightValue = float32Array[ right_i + 3 ];\n\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n\nfunction intersectTris_indirect( bvh, materialOrSide, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, materialOrSide, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, materialOrSide, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, materialOrSide, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, materialOrSide, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, materialOrSide, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, materialOrSide, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, materialOrSide, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, materialOrSide, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, materialOrSide, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, materialOrSide, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, materialOrSide, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { getTriCount } from '../build/geometryUtils.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tconst otherTriangleCount = getTriCount( otherGeometry );\n\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { UINT32_PER_NODE, BYTES_PER_NODE } from '../Constants.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( nodeIndex32, byteOffset, force = false ) {\n\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 0 ] = minx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 1 ] = miny;\n\t\t\t\tfloat32Array[ nodeIndex32 + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ nodeIndex32 + 3 ] = maxx;\n\t\t\t\tfloat32Array[ nodeIndex32 + 4 ] = maxy;\n\t\t\t\tfloat32Array[ nodeIndex32 + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tconst leftNodeId = left / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tconst rightNodeId = right / UINT32_PER_NODE + byteOffset / BYTES_PER_NODE;\n\t\t\t\t\tincludesLeft = nodeIndices.has( leftNodeId );\n\t\t\t\t\tincludesRight = nodeIndices.has( rightNodeId );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst left_i = left + i;\n\t\t\t\t\tconst right_i = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ left_i ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ left_i + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ right_i ];\n\t\t\t\t\tconst maxRightValue = float32Array[ right_i + 3 ];\n\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ nodeIndex32 + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, materialOrSide, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, materialOrSide, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, materialOrSide, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, materialOrSide, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, materialOrSide, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, materialOrSide, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, materialOrSide, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, materialOrSide, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, materialOrSide, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { getTriCount } from '../build/geometryUtils.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tconst otherTriangleCount = getTriCount( otherGeometry );\n\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = otherTriangleCount * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\treturn hit;\n\n}\n","import { BufferAttribute, FrontSide, Ray, Vector3, Matrix4 } from 'three';\nimport { SKIP_GENERATION, BYTES_PER_NODE, UINT32_PER_NODE, FLOAT32_EPSILON } from './Constants.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { IS_LEAF } from './utils/nodeBufferUtils.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\nimport { GeometryBVH } from './GeometryBVH.js';\n\nconst _obb = /* @__PURE__ */ new OrientedBox();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _direction = /* @__PURE__ */ new Vector3();\nconst _inverseMatrix = /* @__PURE__ */ new Matrix4();\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _getters = [ 'getX', 'getY', 'getZ' ];\n\nexport class MeshBVH extends GeometryBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tconst result = {\n\t\t\tversion: 1,\n\t\t\troots: null,\n\t\t\tindex: null,\n\t\t\tindirectBuffer: null,\n\t\t};\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult.roots = rootData.map( root => root.slice() );\n\t\t\tresult.index = indexAttribute ? indexAttribute.array.slice() : null;\n\t\t\tresult.indirectBuffer = indirectBuffer ? indirectBuffer.slice() : null;\n\n\t\t} else {\n\n\t\t\tresult.roots = rootData;\n\t\t\tresult.index = indexAttribute ? indexAttribute.array : null;\n\t\t\tresult.indirectBuffer = indirectBuffer;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\n\t\t// handle backwards compatibility by fixing up the buffer roots\n\t\t// see issue gkjohnson/three-mesh-bvh#759\n\t\tif ( ! data.version ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH.deserialize: Serialization format has been changed and will be fixed up. ' +\n\t\t\t\t'It is recommended to regenerate any stored serialized data.'\n\t\t\t);\n\t\t\tfixupVersion0( roots );\n\n\t\t}\n\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t\t// convert version 0 serialized data (uint32 indices) to version 1 (node indices)\n\t\tfunction fixupVersion0( roots ) {\n\n\t\t\tfor ( let rootIndex = 0; rootIndex < roots.length; rootIndex ++ ) {\n\n\t\t\t\tconst root = roots[ rootIndex ];\n\t\t\t\tconst uint32Array = new Uint32Array( root );\n\t\t\t\tconst uint16Array = new Uint16Array( root );\n\n\t\t\t\t// iterate over nodes and convert right child offsets\n\t\t\t\tfor ( let node = 0, l = root.byteLength / BYTES_PER_NODE; node < l; node ++ ) {\n\n\t\t\t\t\tconst node32Index = UINT32_PER_NODE * node;\n\t\t\t\t\tconst node16Index = 2 * node32Index;\n\t\t\t\t\tif ( ! IS_LEAF( node16Index, uint16Array ) ) {\n\n\t\t\t\t\t\t// convert absolute right child offset to relative offset\n\t\t\t\t\t\tuint32Array[ node32Index + 6 ] = uint32Array[ node32Index + 6 ] / UINT32_PER_NODE - node;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget primitiveStride() {\n\n\t\treturn 3;\n\n\t}\n\n\tget resolveTriangleIndex() {\n\n\t\treturn this.resolvePrimitiveIndex;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( options.maxLeafTris ) {\n\n\t\t\tconsole.warn( 'MeshBVH: \"maxLeafTris\" option has been deprecated. Use maxLeafSize, instead.' );\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tmaxLeafSize: options.maxLeafTris,\n\t\t\t};\n\n\t\t}\n\n\t\tsuper( geometry, options );\n\n\t}\n\n\t// implement abstract methods from BVH base class\n\tshiftTriangleOffsets( offset ) {\n\n\t\treturn super.shiftPrimitiveOffsets( offset );\n\n\t}\n\n\t// write primitive bounds to the buffer - used only for validateBounds at the moment\n\twritePrimitiveBounds( i, targetBuffer, baseIndex ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst index = geometry.index ? geometry.index.array : null;\n\n\t\tconst tri = indirectBuffer ? indirectBuffer[ i ] : i;\n\t\tconst tri3 = tri * 3;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tconst a = posAttr[ _getters[ el ] ]( ai );\n\t\t\tconst b = posAttr[ _getters[ el ] ]( bi );\n\t\t\tconst c = posAttr[ _getters[ el ] ]( ci );\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Write in min/max format [minx, miny, minz, maxx, maxy, maxz]\n\t\t\ttargetBuffer[ baseIndex + el ] = min;\n\t\t\ttargetBuffer[ baseIndex + el + 3 ] = max;\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size count * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index (i - offset) * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tcomputePrimitiveBounds( offset, count, targetBuffer ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst indirectBuffer = this._indirectBuffer;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst index = geometry.index ? geometry.index.array : null;\n\t\tconst normalized = posAttr.normalized;\n\n\t\tif ( offset < 0 || count + offset - targetBuffer.offset > targetBuffer.length / 6 ) {\n\n\t\t\tthrow new Error( 'MeshBVH: compute triangle bounds range is invalid.' );\n\n\t\t}\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\t\tconst writeOffset = targetBuffer.offset;\n\n\t\t// iterate over the triangle range\n\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\tconst tri = indirectBuffer ? indirectBuffer[ i ] : i;\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst boundsIndexOffset = ( i - writeOffset ) * 6;\n\n\t\t\tlet ai = tri3 + 0;\n\t\t\tlet bi = tri3 + 1;\n\t\t\tlet ci = tri3 + 2;\n\n\t\t\tif ( index ) {\n\n\t\t\t\tai = index[ ai ];\n\t\t\t\tbi = index[ bi ];\n\t\t\t\tci = index[ ci ];\n\n\t\t\t}\n\n\t\t\t// we add the stride and offset here since we access the array directly\n\t\t\t// below for the sake of performance\n\t\t\tif ( ! normalized ) {\n\n\t\t\t\tai = ai * stride + bufferOffset;\n\t\t\t\tbi = bi * stride + bufferOffset;\n\t\t\t\tci = ci * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttargetBuffer[ boundsIndexOffset + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttargetBuffer[ boundsIndexOffset + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetBuffer;\n\n\t}\n\n\traycastObject3D( object, raycaster, intersects = [] ) {\n\n\t\tconst { material } = object;\n\t\tif ( material === undefined ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t_inverseMatrix.copy( object.matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\t_worldScale.setFromMatrixScale( object.matrixWorld );\n\t\t_direction.copy( _ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = _direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tlet hit = this.raycastFirst( _ray, material, near, far );\n\t\t\thit = convertRaycastIntersect( hit, object, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = this.raycast( _ray, material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], object, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst intersects = [];\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\traycastFunc( this, i, materialOrSide, ray, intersects, near, far );\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tlet closestResult = null;\n\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst result = raycastFirstFunc( this, i, materialOrSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst result = super.shapecast(\n\t\t\t{\n\t\t\t\t...callbacks,\n\t\t\t\tintersectsPrimitive: callbacks.intersectsTriangle,\n\t\t\t\tscratchPrimitive: triangle,\n\n\t\t\t\t// TODO: is the performance significant enough for the added complexity here?\n\t\t\t\t// can we just use one function?\n\t\t\t\titerate: this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles,\n\t\t\t}\n\t\t);\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tif ( ! ( otherBvh instanceof MeshBVH ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: \"intersectsTriangles\" callback can only be used with another MeshBVH.' );\n\n\t\t\t}\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, nodeIndex1, depth2, nodeIndex2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.bvhcast( otherBvh, matrixToLocal, { intersectsRanges } );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\t_obb.set( box.min, box.max, boxToMesh );\n\t\t_obb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => _obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => _obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n}\n"],"names":["CENTER","AVERAGE","SAH","NOT_INTERSECTED","INTERSECTED","CONTAINED","PRIMITIVE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","UINT32_PER_NODE","IS_LEAFNODE_FLAG","LEAFNODE_MASK_32","FLOAT32_EPSILON","SKIP_GENERATION","DEFAULT_OPTIONS","arrayToBox","nodeIndex32","array","target","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","i","dist","copyBounds","source","unionBounds","a","b","aVal","bVal","d","d3","expandByPrimitiveBounds","startIndex","primitiveBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","relativeOffset","SPLIT_AXIS","BOUNDING_DATA_INDEX","getBounds","offset","count","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","boundsOffset","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","BIN_COUNT","binsSort","sahBins","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","axis","pos","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","c","bin","leftCacheBounds","rightCacheBounds","splitCount","bi","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","avg","BVHNode","partition","buffer","stride","split","left","right","axisOffset","t0","l","r","tb","float32Array","uint8Array","MAX_POINTER","countNodes","node","populateBuffer","byteOffset","_populateBuffer","node32Index","node16Index","isLeaf","boundingData","splitAxis","leftByteOffset","rightByteOffset","currentNodeIndex","relativeRightIndex","buildTree","bvh","options","loadRange","maxDepth","verbose","maxLeafSize","onProgress","partitionBuffer","partitionStride","cacheCentroidBoundingData","reachedMaxDepth","root","splitNode","triggerProgress","primitivesProcessed","depth","splitOffset","lstart","lcount","rstart","rcount","buildPackedTree","BufferConstructor","rootRanges","firstRange","lastRange","fullRange","range","nodeCount","PrimitivePool","getNewPrimitive","primitives","primitive","_BufferStack","stack","prevBuffer","BufferStack","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","nodeOffset","result","shapecastTraverse","length","geometry","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexOffset","nodeIndex16","getLeftOffset","getRightEndOffset","c1","c2","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","isC2Leaf","c2Intersection","c2StopTraversal","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","bvhcast","otherBvh","matrixToLocal","intersectsRanges","roots","otherRoots","nodeOffset1","nodeOffset2","invMat","Matrix4","il","localBox","j","jl","_traverse","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexOffset","node2IndexOffset","depth1","depth2","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","_tempBox","_tempBuffer","BVH","targetBuffer","baseIndex","minX","minY","minZ","maxX","maxY","maxZ","indirectBuffer","rootIndex","totalNodes","callback","rootCount","nodeIndex","leftMin","leftMax","rightMin","rightMax","callbacks","intersectsPrimitive","scratchPrimitive","iterate","originalIntersectsRange","contained","shapecastFunc","isSharedArrayBufferSupported","convertToBufferType","ArrayConstructor","getVertexCount","geo","getTriCount","getIndexArray","vertexCount","ensureIndex","index","BufferAttribute","getFullPrimitiveRange","primitiveCount","drawRange","start","getPrimitiveGroupRanges","group","getRootPrimitiveRanges","primitiveRanges","ranges","drawRangeStart","drawRangeEnd","events","groupStart","groupCount","groupEnd","activeGroups","lastPos","event","newPos","generateIndirectBuffer","useSharedArrayBuffer","useUint32","acc","val","byteCount","GeometryBVH","v","primitiveStride","OrientedBox","min","max","matrix","Vector3","SeparatingAxisBounds","other","points","y","z","satBounds","satAxes","minVec","sb","pi","alignedSatBounds","aabbBounds","box","saTri","ExtendedTriangle","pointsArr","cachedSatBounds","cachedSatBounds2","cachedAxis","triangle","sa","triSatBounds","triSatAxes","sa1","i2","sa2","point","target1","xyzFields","segments1","Line3","segments2","point1","point2","threshold","target2","threshold2","closestDistanceSq","p","i1","nextIndex","nextIndex2","index2","p1","p2","f1","f2","f3","line2","x","l1","l2","closestPointsSegmentToSegment","ExtendedTrianglePoolBase","ExtendedTrianglePool","temp1","closestPointToPoint","minThreshold","maxThreshold","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","tri","triIndex","distSq","closestDistance","IS_GT_REVISION_169","REVISION","IS_LT_REVISION_161","_vA","_vB","_vC","_uvA","Vector2","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkIntersection","ray","pA","pB","pC","side","near","far","intersect","BackSide","DoubleSide","distance","checkBufferGeometryIntersection","position","normal","uv","uv1","intersection","res","Triangle","face","barycoord","getSide","materialOrSide","intersectTri","intersections","triOffset","groups","firstIndex","materialIndex","setTriangle","ta","tc","i0","intersectTris","_indirectBuffer","intersectClosestTri","iterateOverTriangles","intersectsTriangleFunc","refit","nodeIndices","indexArr","posAttr","force","forceChildren","includesLeft","includesRight","leftNodeId","rightNodeId","traverseLeft","traverseRight","leftChange","rightChange","didChange","left_i","right_i","minLeftValue","maxLeftValue","minRightValue","maxRightValue","intersectRay","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","intersectTris_indirect","vi","intersectClosestTri_indirect","iterateOverTriangles_indirect","raycast","intersects","_raycast","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","thisGeometry","thisIndex","thisPos","otherIndex","otherPos","otherTriangleCount","tempMatrix","temp2","temp3","temp4","closestPointToGeometry","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","triCount","refit_indirect","t","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","ti2","convertRaycastIntersect","hit","object","raycaster","_obb","_ray","Ray","_direction","_inverseMatrix","_worldScale","_getters","MeshBVH","rootData","indexAttribute","data","fixupVersion0","newIndex","tri3","ai","ci","el","normalized","posArr","bufferOffset","getters","writeOffset","boundsIndexOffset","halfExtents","el2","material","scaleFactor","hits","FrontSide","raycastFunc","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","nodeIndex1","nodeIndex2","originalIntersectsRanges","boxToMesh","sphere"],"mappings":"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"}