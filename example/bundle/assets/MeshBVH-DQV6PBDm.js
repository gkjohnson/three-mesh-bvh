import{b as O,n as Q,B as Dn,V as z,dG as bt,ba as pt,dH as kn,o as gn,J as _t,U as yt,y as qn,t as Yn,b9 as Vn,Y as Zn,x as An}from"./ExtendedTriangle-hsPasuNU.js";const Fn=0,On=1,Wn=2,Ye=0,Ze=1,dn=2,qt=1.25,wn=1,H=32,I=H/4,pn=65535,Oe=pn<<16,Ft=Math.pow(2,-24),yn=Symbol("SKIP_GENERATION"),Hn={strategy:Fn,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[yn]:!1};function R(i,t,n){return n.min.x=t[i],n.min.y=t[i+1],n.min.z=t[i+2],n.max.x=t[i+3],n.max.y=t[i+4],n.max.z=t[i+5],n}function Bn(i){let t=-1,n=-1/0;for(let e=0;e<3;e++){const s=i[e+3]-i[e];s>n&&(n=s,t=e)}return t}function bn(i,t){t.set(i)}function _n(i,t,n){let e,s;for(let o=0;o<3;o++){const r=o+3;e=i[o],s=t[o],n[o]=e<s?e:s,e=i[r],s=t[r],n[r]=e>s?e:s}}function Tt(i,t,n){for(let e=0;e<3;e++){const s=t[i+2*e],o=t[i+2*e+1],r=s-o,a=s+o;r<n[e]&&(n[e]=r),a>n[e+3]&&(n[e+3]=a)}}function xt(i){const t=i[3]-i[0],n=i[4]-i[1],e=i[5]-i[2];return 2*(t*n+n*e+e*t)}function D(i,t){return t[i+15]===pn}function $(i,t){return t[i+6]}function X(i,t){return t[i+14]}function V(i){return i+I}function F(i,t){const n=t[i+6];return i+n*I}function xn(i,t){return t[i+7]}function We(i){return i}function Yt(i,t,n,e,s){let o=1/0,r=1/0,a=1/0,l=-1/0,x=-1/0,p=-1/0,f=1/0,c=1/0,u=1/0,h=-1/0,A=-1/0,g=-1/0;const w=i.offset||0;for(let y=(t-w)*6,d=(t+n-w)*6;y<d;y+=6){const m=i[y+0],B=i[y+1],P=m-B,S=m+B;P<o&&(o=P),S>l&&(l=S),m<f&&(f=m),m>h&&(h=m);const b=i[y+2],v=i[y+3],_=b-v,M=b+v;_<r&&(r=_),M>x&&(x=M),b<c&&(c=b),b>A&&(A=b);const T=i[y+4],U=i[y+5],C=T-U,L=T+U;C<a&&(a=C),L>p&&(p=L),T<u&&(u=T),T>g&&(g=T)}e[0]=o,e[1]=r,e[2]=a,e[3]=l,e[4]=x,e[5]=p,s[0]=f,s[1]=c,s[2]=u,s[3]=h,s[4]=A,s[5]=g}const W=32,jn=(i,t)=>i.candidate-t.candidate,j=new Array(W).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Pt=new Float32Array(6);function Kn(i,t,n,e,s,o){let r=-1,a=0;if(o===Fn)r=Bn(t),r!==-1&&(a=(t[r]+t[r+3])/2);else if(o===On)r=Bn(i),r!==-1&&(a=Jn(n,e,s,r));else if(o===Wn){const l=xt(i);let x=qt*s;const p=n.offset||0,f=(e-p)*6,c=(e+s-p)*6;for(let u=0;u<3;u++){const h=t[u],w=(t[u+3]-h)/W;if(s<W/4){const y=[...j];y.length=s;let d=0;for(let B=f;B<c;B+=6,d++){const P=y[d];P.candidate=n[B+2*u],P.count=0;const{bounds:S,leftCacheBounds:b,rightCacheBounds:v}=P;for(let _=0;_<3;_++)v[_]=1/0,v[_+3]=-1/0,b[_]=1/0,b[_+3]=-1/0,S[_]=1/0,S[_+3]=-1/0;Tt(B,n,S)}y.sort(jn);let m=s;for(let B=0;B<m;B++){const P=y[B];for(;B+1<m&&y[B+1].candidate===P.candidate;)y.splice(B+1,1),m--}for(let B=f;B<c;B+=6){const P=n[B+2*u];for(let S=0;S<m;S++){const b=y[S];P>=b.candidate?Tt(B,n,b.rightCacheBounds):(Tt(B,n,b.leftCacheBounds),b.count++)}}for(let B=0;B<m;B++){const P=y[B],S=P.count,b=s-P.count,v=P.leftCacheBounds,_=P.rightCacheBounds;let M=0;S!==0&&(M=xt(v)/l);let T=0;b!==0&&(T=xt(_)/l);const U=wn+qt*(M*S+T*b);U<x&&(r=u,x=U,a=P.candidate)}}else{for(let m=0;m<W;m++){const B=j[m];B.count=0,B.candidate=h+w+m*w;const P=B.bounds;for(let S=0;S<3;S++)P[S]=1/0,P[S+3]=-1/0}for(let m=f;m<c;m+=6){let S=~~((n[m+2*u]-h)/w);S>=W&&(S=W-1);const b=j[S];b.count++,Tt(m,n,b.bounds)}const y=j[W-1];bn(y.bounds,y.rightCacheBounds);for(let m=W-2;m>=0;m--){const B=j[m],P=j[m+1];_n(B.bounds,P.rightCacheBounds,B.rightCacheBounds)}let d=0;for(let m=0;m<W-1;m++){const B=j[m],P=B.count,S=B.bounds,v=j[m+1].rightCacheBounds;P!==0&&(d===0?bn(S,Pt):_n(S,Pt,Pt)),d+=P;let _=0,M=0;d!==0&&(_=xt(Pt)/l);const T=s-d;T!==0&&(M=xt(v)/l);const U=wn+qt*(_*d+M*T);U<x&&(r=u,x=U,a=B.candidate)}}}}else console.warn(`BVH: Invalid build strategy value ${o} used.`);return{axis:r,pos:a}}function Jn(i,t,n,e){let s=0;const o=i.offset;for(let r=t,a=t+n;r<a;r++)s+=i[(r-o)*6+e*2];return s/n}class Zt{constructor(){this.boundingData=new Float32Array(6)}}function Qn(i,t,n,e,s,o){let r=e,a=e+s-1;const l=o.pos,x=o.axis*2,p=n.offset||0;for(;;){for(;r<=a&&n[(r-p)*6+x]<l;)r++;for(;r<=a&&n[(a-p)*6+x]>=l;)a--;if(r<a){for(let f=0;f<t;f++){let c=i[r*t+f];i[r*t+f]=i[a*t+f],i[a*t+f]=c}for(let f=0;f<6;f++){const c=r-p,u=a-p,h=n[c*6+f];n[c*6+f]=n[u*6+f],n[u*6+f]=h}r++,a--}else return r}}let $n,Ht,tn,Xn;const Gn=Math.pow(2,32);function nn(i){return"count"in i?1:1+nn(i.left)+nn(i.right)}function te(i,t,n){return $n=new Float32Array(n),Ht=new Uint32Array(n),tn=new Uint16Array(n),Xn=new Uint8Array(n),en(i,t)}function en(i,t){const n=i/4,e=i/2,s="count"in t,o=t.boundingData;for(let r=0;r<6;r++)$n[n+r]=o[r];if(s)return t.buffer?(Xn.set(new Uint8Array(t.buffer),i),i+t.buffer.byteLength):(Ht[n+6]=t.offset,tn[e+14]=t.count,tn[e+15]=pn,i+H);{const{left:r,right:a,splitAxis:l}=t,x=i+H;let p=en(x,r);const f=i/H,u=p/H-f;if(u>Gn)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return Ht[n+6]=u,Ht[n+7]=l,en(p,a)}}function ne(i,t,n,e,s,o){const{maxDepth:r,verbose:a,maxLeafSize:l,strategy:x,onProgress:p}=s,f=i.primitiveBuffer,c=i.primitiveBufferStride,u=new Float32Array(6);let h=!1;const A=new Zt;return Yt(t,n,e,A.boundingData,u),w(A,n,e,u),A;function g(y){p&&p((y-o.offset)/o.count)}function w(y,d,m,B=null,P=0){if(!h&&P>=r&&(h=!0,a&&console.warn(`BVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`)),m<=l||P>=r)return g(d+m),y.offset=d,y.count=m,y;const S=Kn(y.boundingData,B,t,d,m,x);if(S.axis===-1)return g(d+m),y.offset=d,y.count=m,y;const b=Qn(f,c,t,d,m,S);if(b===d||b===d+m)g(d+m),y.offset=d,y.count=m;else{y.splitAxis=S.axis;const v=new Zt,_=d,M=b-d;y.left=v,Yt(t,_,M,v.boundingData,u),w(v,_,M,u,P+1);const T=new Zt,U=b,C=m-M;y.right=T,Yt(t,U,C,T.boundingData,u),w(T,U,C,u,P+1)}return y}}function ee(i,t){const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,e=i.getRootRanges(t.range),s=e[0],o=e[e.length-1],r={offset:s.offset,count:o.offset+o.count-s.offset},a=new Float32Array(6*r.count);a.offset=r.offset,i.computePrimitiveBounds(r.offset,r.count,a),i._roots=e.map(l=>{const x=ne(i,a,l.offset,l.count,t,r),p=nn(x),f=new n(H*p);return te(0,x,f),f})}class hn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ie{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=e=>{n&&t.push(n),n=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const E=new ie;let J,ut;const it=[],St=new hn(()=>new O);function se(i,t,n,e,s,o){J=St.getPrimitive(),ut=St.getPrimitive(),it.push(J,ut),E.setBuffer(i._roots[t]);const r=sn(0,i.geometry,n,e,s,o);E.clearBuffer(),St.releasePrimitive(J),St.releasePrimitive(ut),it.pop(),it.pop();const a=it.length;return a>0&&(ut=it[a-1],J=it[a-2]),r}function sn(i,t,n,e,s=null,o=0,r=0){const{float32Array:a,uint16Array:l,uint32Array:x}=E;let p=i*2;if(D(p,l)){const c=$(i,x),u=X(p,l);return R(i,a,J),e(c,u,!1,r,o+i/I,J)}else{let _=function(T){const{uint16Array:U,uint32Array:C}=E;let L=T*2;for(;!D(L,U);)T=V(T),L=T*2;return $(T,C)},M=function(T){const{uint16Array:U,uint32Array:C}=E;let L=T*2;for(;!D(L,U);)T=F(T,C),L=T*2;return $(T,C)+X(L,U)};const c=V(i),u=F(i,x);let h=c,A=u,g,w,y,d;if(s&&(y=J,d=ut,R(h,a,y),R(A,a,d),g=s(y),w=s(d),w<g)){h=u,A=c;const T=g;g=w,w=T,y=d}y||(y=J,R(h,a,y));const m=D(h*2,l),B=n(y,m,g,r+1,o+h/I);let P;if(B===dn){const T=_(h),C=M(h)-T;P=e(T,C,!0,r+1,o+h/I,y)}else P=B&&sn(h,t,n,e,s,o,r+1);if(P)return!0;d=ut,R(A,a,d);const S=D(A*2,l),b=n(d,S,w,r+1,o+A/I);let v;if(b===dn){const T=_(A),C=M(A)-T;v=e(T,C,!0,r+1,o+A/I,d)}else v=b&&sn(A,t,n,e,s,o,r+1);return!!v}}const Bt=new E.constructor,$t=new E.constructor,K=new hn(()=>new O),st=new O,rt=new O,Ot=new O,Wt=new O;let jt=!1;function re(i,t,n,e){if(jt)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");jt=!0;const s=i._roots,o=t._roots;let r,a=0,l=0;const x=new Q().copy(n).invert();for(let p=0,f=s.length;p<f;p++){Bt.setBuffer(s[p]),l=0;const c=K.getPrimitive();R(0,Bt.float32Array,c),c.applyMatrix4(x);for(let u=0,h=o.length;u<h&&($t.setBuffer(o[u]),r=Z(0,0,n,x,e,a,l,0,0,c),$t.clearBuffer(),l+=o[u].byteLength/H,!r);u++);if(K.releasePrimitive(c),Bt.clearBuffer(),a+=s[p].byteLength/H,r)break}return jt=!1,r}function Z(i,t,n,e,s,o=0,r=0,a=0,l=0,x=null,p=!1){let f,c;p?(f=$t,c=Bt):(f=Bt,c=$t);const u=f.float32Array,h=f.uint32Array,A=f.uint16Array,g=c.float32Array,w=c.uint32Array,y=c.uint16Array,d=i*2,m=t*2,B=D(d,A),P=D(m,y);let S=!1;if(P&&B)p?S=s($(t,w),X(t*2,y),$(i,h),X(i*2,A),l,r+t/I,a,o+i/I):S=s($(i,h),X(i*2,A),$(t,w),X(t*2,y),a,o+i/I,l,r+t/I);else if(P){const b=K.getPrimitive();R(t,g,b),b.applyMatrix4(n);const v=V(i),_=F(i,h);R(v,u,st),R(_,u,rt);const M=b.intersectsBox(st),T=b.intersectsBox(rt);S=M&&Z(t,v,e,n,s,r,o,l,a+1,b,!p)||T&&Z(t,_,e,n,s,r,o,l,a+1,b,!p),K.releasePrimitive(b)}else{const b=V(t),v=F(t,w);R(b,g,Ot),R(v,g,Wt);const _=x.intersectsBox(Ot),M=x.intersectsBox(Wt);if(_&&M)S=Z(i,b,n,e,s,o,r,a,l+1,x,p)||Z(i,v,n,e,s,o,r,a,l+1,x,p);else if(_)if(B)S=Z(i,b,n,e,s,o,r,a,l+1,x,p);else{const T=K.getPrimitive();T.copy(Ot).applyMatrix4(n);const U=V(i),C=F(i,h);R(U,u,st),R(C,u,rt);const L=T.intersectsBox(st),q=T.intersectsBox(rt);S=L&&Z(b,U,e,n,s,r,o,l,a+1,T,!p)||q&&Z(b,C,e,n,s,r,o,l,a+1,T,!p),K.releasePrimitive(T)}else if(M)if(B)S=Z(i,v,n,e,s,o,r,a,l+1,x,p);else{const T=K.getPrimitive();T.copy(Wt).applyMatrix4(n);const U=V(i),C=F(i,h);R(U,u,st),R(C,u,rt);const L=T.intersectsBox(st),q=T.intersectsBox(rt);S=L&&Z(v,U,e,n,s,r,o,l,a+1,T,!p)||q&&Z(v,C,e,n,s,r,o,l,a+1,T,!p),K.releasePrimitive(T)}}return S}const Tn=new O,ot=new Float32Array(6);class oe{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(t){t={...Hn,...t},ee(this,t)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(t,n,e,s){let o=1/0,r=1/0,a=1/0,l=-1/0,x=-1/0,p=-1/0;for(let f=t,c=t+n;f<c;f++){this.writePrimitiveBounds(f,ot,0);const[u,h,A,g,w,y]=ot;u<o&&(o=u),g>l&&(l=g),h<r&&(r=h),w>x&&(x=w),A<a&&(a=A),y>p&&(p=y)}return e[s+0]=o,e[s+1]=r,e[s+2]=a,e[s+3]=l,e[s+4]=x,e[s+5]=p,e}computePrimitiveBounds(t,n,e){const s=e.offset||0;for(let o=t,r=t+n;o<r;o++){this.writePrimitiveBounds(o,ot,0);const[a,l,x,p,f,c]=ot,u=(a+p)/2,h=(l+f)/2,A=(x+c)/2,g=(p-a)/2,w=(f-l)/2,y=(c-x)/2,d=(o-s)*6;e[d+0]=u,e[d+1]=g+(Math.abs(u)+g)*Ft,e[d+2]=h,e[d+3]=w+(Math.abs(h)+w)*Ft,e[d+4]=A,e[d+5]=y+(Math.abs(A)+y)*Ft}return e}shiftPrimitiveOffsets(t){const n=this._indirectBuffer;if(n)for(let e=0,s=n.length;e<s;e++)n[e]+=t;else{const e=this._roots;for(let s=0;s<e.length;s++){const o=e[s],r=new Uint32Array(o),a=new Uint16Array(o),l=o.byteLength/H;for(let x=0;x<l;x++){const p=I*x,f=2*p;D(f,a)&&(r[p+6]+=t)}}}}traverse(t,n=0){const e=this._roots[n],s=new Uint32Array(e),o=new Uint16Array(e);r(0);function r(a,l=0){const x=a*2,p=D(x,o);if(p){const f=s[a+6],c=o[x+14];t(l,p,new Float32Array(e,a*4,6),f,c)}else{const f=V(a),c=F(a,s),u=xn(a,s);t(l,p,new Float32Array(e,a*4,6),u)||(r(f,l+1),r(c,l+1))}}}refit(){const t=this._roots;for(let n=0,e=t.length;n<e;n++){const s=t[n],o=new Uint32Array(s),r=new Uint16Array(s),a=new Float32Array(s),l=s.byteLength/H;for(let x=l-1;x>=0;x--){const p=x*I,f=p*2;if(D(f,r)){const u=$(p,o),h=X(f,r);this.writePrimitiveRangeBounds(u,h,ot,0),a.set(ot,p)}else{const u=V(p),h=F(p,o);for(let A=0;A<3;A++){const g=a[u+A],w=a[u+A+3],y=a[h+A],d=a[h+A+3];a[p+A]=g<y?g:y,a[p+A+3]=w>d?w:d}}}}}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{R(0,new Float32Array(e),Tn),t.union(Tn)}),t}shapecast(t){let{boundsTraverseOrder:n,intersectsBounds:e,intersectsRange:s,intersectsPrimitive:o,scratchPrimitive:r,iterate:a}=t;if(s&&o){const f=s;s=(c,u,h,A,g)=>f(c,u,h,A,g)?!0:a(c,u,this,o,h,A,r)}else s||(o?s=(f,c,u,h)=>a(f,c,this,o,u,h,r):s=(f,c,u)=>u);let l=!1,x=0;const p=this._roots;for(let f=0,c=p.length;f<c;f++){const u=p[f];if(l=se(this,f,e,s,n,x),l)break;x+=u.byteLength/H}return l}bvhcast(t,n,e){let{intersectsRanges:s}=e;return re(this,t,n,s)}}function ce(){return typeof SharedArrayBuffer<"u"}function je(i,t){if(i===null)return i;if(i.buffer){const n=i.buffer;if(n.constructor===t)return i;const e=i.constructor,s=new e(new t(n.byteLength));return s.set(i),s}else{if(i.constructor===t)return i;const n=new t(i.byteLength);return new Uint8Array(n).set(new Uint8Array(i)),n}}function mn(i){return i.index?i.index.count:i.attributes.position.count}function Xt(i){return mn(i)/3}function le(i,t=ArrayBuffer){return i>65535?new Uint32Array(new t(4*i)):new Uint16Array(new t(2*i))}function ae(i,t){if(!i.index){const n=i.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=le(n,e);i.setIndex(new Dn(s,1));for(let o=0;o<n;o++)s[o]=o}}function fe(i,t,n){const e=mn(i)/n,s=t||i.drawRange,o=s.start/n,r=(s.start+s.count)/n,a=Math.max(0,o),l=Math.min(e,r)-a;return{offset:Math.floor(a),count:Math.floor(l)}}function ue(i,t){return i.groups.map(n=>({offset:n.start/t,count:n.count/t}))}function Pn(i,t,n){const e=fe(i,t,n),s=ue(i,n);if(!s.length)return[e];const o=[],r=e.offset,a=e.offset+e.count,l=mn(i)/n,x=[];for(const c of s){const{offset:u,count:h}=c,A=u,g=isFinite(h)?h:l-u,w=u+g;A<a&&w>r&&(x.push({pos:Math.max(r,A),isStart:!0}),x.push({pos:Math.min(a,w),isStart:!1}))}x.sort((c,u)=>c.pos!==u.pos?c.pos-u.pos:c.type==="end"?-1:1);let p=0,f=null;for(const c of x){const u=c.pos;p!==0&&u!==f&&o.push({offset:f,count:u-f}),p+=c.isStart?1:-1,f=u}return o}function pe(i,t){const n=i[i.length-1],e=n.offset+n.count>2**16,s=i.reduce((x,p)=>x+p.count,0),o=e?4:2,r=t?new SharedArrayBuffer(s*o):new ArrayBuffer(s*o),a=e?new Uint32Array(r):new Uint16Array(r);let l=0;for(let x=0;x<i.length;x++){const{offset:p,count:f}=i[x];for(let c=0;c<f;c++)a[l+c]=p+c;l+=f}return a}class ye extends oe{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(t){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(t){}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(n.useSharedArrayBuffer&&!ce())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=t,this.resolvePrimitiveIndex=n.indirect?e=>this._indirectBuffer[e]:e=>e,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,n={...Hn,...n},n[yn]||this.init(n)}init(t){const{geometry:n,primitiveStride:e}=this;if(t.indirect){const s=Pn(n,t.range,e),o=pe(s,t.useSharedArrayBuffer);this._indirectBuffer=o}else ae(n,t);super.init(t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new O))}getRootRanges(t){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:Pn(this.geometry,t,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class k{constructor(t,n,e){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new Q,this.invMatrix=new Q,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new bt),this.alignedSatBounds=new Array(3).fill().map(()=>new bt),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),e&&this.matrix.copy(e)}set(t,n,e){this.min.copy(t),this.max.copy(n),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}k.prototype.update=(function(){return function(){const t=this.matrix,n=this.min,e=this.max,s=this.points;for(let x=0;x<=1;x++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){const c=1*x|2*p|4*f,u=s[c];u.x=x?e.x:n.x,u.y=p?e.y:n.y,u.z=f?e.z:n.z,u.applyMatrix4(t)}const o=this.satBounds,r=this.satAxes,a=s[0];for(let x=0;x<3;x++){const p=r[x],f=o[x],c=1<<x,u=s[c];p.subVectors(a,u),f.setFromPoints(p,s)}const l=this.alignedSatBounds;l[0].setFromPointsField(s,"x"),l[1].setFromPointsField(s,"y"),l[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();k.prototype.intersectsBox=(function(){const i=new bt;return function(n){this.needsUpdate&&this.update();const e=n.min,s=n.max,o=this.satBounds,r=this.satAxes,a=this.alignedSatBounds;if(i.min=e.x,i.max=s.x,a[0].isSeparated(i)||(i.min=e.y,i.max=s.y,a[1].isSeparated(i))||(i.min=e.z,i.max=s.z,a[2].isSeparated(i)))return!1;for(let l=0;l<3;l++){const x=r[l],p=o[l];if(i.setFromBox(x,n),p.isSeparated(i))return!1}return!0}})();k.prototype.intersectsTriangle=(function(){const i=new pt,t=new Array(3),n=new bt,e=new bt,s=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const a=this.satBounds,l=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let c=0;c<3;c++){const u=a[c],h=l[c];if(n.setFromPoints(h,t),u.isSeparated(n))return!1}const x=r.satBounds,p=r.satAxes,f=this.points;for(let c=0;c<3;c++){const u=x[c],h=p[c];if(n.setFromPoints(h,f),u.isSeparated(n))return!1}for(let c=0;c<3;c++){const u=l[c];for(let h=0;h<4;h++){const A=p[h];if(s.crossVectors(u,A),n.setFromPoints(s,t),e.setFromPoints(s,f),n.isSeparated(e))return!1}}return!0}})();k.prototype.closestPointToPoint=(function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}})();k.prototype.distanceToPoint=(function(){const i=new z;return function(n){return this.closestPointToPoint(n,i),n.distanceTo(i)}})();k.prototype.distanceToBox=(function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new gn),n=new Array(12).fill().map(()=>new gn),e=new z,s=new z;return function(r,a=0,l=null,x=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(l||x)&&(r.getCenter(s),this.closestPointToPoint(s,e),r.closestPointToPoint(e,s),l&&l.copy(e),x&&x.copy(s)),0;const p=a*a,f=r.min,c=r.max,u=this.points;let h=1/0;for(let g=0;g<8;g++){const w=u[g];s.copy(w).clamp(f,c);const y=w.distanceToSquared(s);if(y<h&&(h=y,l&&l.copy(w),x&&x.copy(s),y<p))return Math.sqrt(y)}let A=0;for(let g=0;g<3;g++)for(let w=0;w<=1;w++)for(let y=0;y<=1;y++){const d=(g+1)%3,m=(g+2)%3,B=w<<d|y<<m,P=1<<g|w<<d|y<<m,S=u[B],b=u[P];t[A].set(S,b);const _=i[g],M=i[d],T=i[m],U=n[A],C=U.start,L=U.end;C[_]=f[_],C[M]=w?f[M]:c[M],C[T]=y?f[T]:c[M],L[_]=c[_],L[M]=w?f[M]:c[M],L[T]=y?f[T]:c[M],A++}for(let g=0;g<=1;g++)for(let w=0;w<=1;w++)for(let y=0;y<=1;y++){s.x=g?c.x:f.x,s.y=w?c.y:f.y,s.z=y?c.z:f.z,this.closestPointToPoint(s,e);const d=s.distanceToSquared(e);if(d<h&&(h=d,l&&l.copy(e),x&&x.copy(s),d<p))return Math.sqrt(d)}for(let g=0;g<12;g++){const w=t[g];for(let y=0;y<12;y++){const d=n[y];kn(w,d,e,s);const m=e.distanceToSquared(s);if(m<h&&(h=m,l&&l.copy(e),x&&x.copy(s),m<p))return Math.sqrt(m)}}return Math.sqrt(h)}})();class xe extends hn{constructor(){super(()=>new pt)}}const Y=new xe,ht=new z,Kt=new z;function he(i,t,n={},e=0,s=1/0){const o=e*e,r=s*s;let a=1/0,l=null;if(i.shapecast({boundsTraverseOrder:p=>(ht.copy(t).clamp(p.min,p.max),ht.distanceToSquared(t)),intersectsBounds:(p,f,c)=>c<a&&c<r,intersectsTriangle:(p,f)=>{p.closestPointToPoint(t,ht);const c=t.distanceToSquared(ht);return c<a&&(Kt.copy(ht),a=c,l=f),c<o}}),a===1/0)return null;const x=Math.sqrt(a);return n.point?n.point.copy(Kt):n.point=Kt.clone(),n.distance=x,n.faceIndex=l,n}const Mt=parseInt(Vn)>=169,me=parseInt(Vn)<=161,tt=new z,nt=new z,et=new z,vt=new _t,Ut=new _t,Ct=new _t,Sn=new z,Mn=new z,vn=new z,mt=new z;function ge(i,t,n,e,s,o,r,a){let l;if(o===qn?l=i.intersectTriangle(e,n,t,!0,s):l=i.intersectTriangle(t,n,e,o!==Yn,s),l===null)return null;const x=i.origin.distanceTo(s);return x<r||x>a?null:{distance:x,point:s.clone()}}function Un(i,t,n,e,s,o,r,a,l,x,p){tt.fromBufferAttribute(t,o),nt.fromBufferAttribute(t,r),et.fromBufferAttribute(t,a);const f=ge(i,tt,nt,et,mt,l,x,p);if(f){if(e){vt.fromBufferAttribute(e,o),Ut.fromBufferAttribute(e,r),Ct.fromBufferAttribute(e,a),f.uv=new _t;const u=yt.getInterpolation(mt,tt,nt,et,vt,Ut,Ct,f.uv);Mt||(f.uv=u)}if(s){vt.fromBufferAttribute(s,o),Ut.fromBufferAttribute(s,r),Ct.fromBufferAttribute(s,a),f.uv1=new _t;const u=yt.getInterpolation(mt,tt,nt,et,vt,Ut,Ct,f.uv1);Mt||(f.uv1=u),me&&(f.uv2=f.uv1)}if(n){Sn.fromBufferAttribute(n,o),Mn.fromBufferAttribute(n,r),vn.fromBufferAttribute(n,a),f.normal=new z;const u=yt.getInterpolation(mt,tt,nt,et,Sn,Mn,vn,f.normal);f.normal.dot(i.direction)>0&&f.normal.multiplyScalar(-1),Mt||(f.normal=u)}const c={a:o,b:r,c:a,normal:new z,materialIndex:0};if(yt.getNormal(tt,nt,et,c.normal),f.face=c,f.faceIndex=o,Mt){const u=new z;yt.getBarycoord(mt,tt,nt,et,u),f.barycoord=u}}return f}function Cn(i){return i&&i.isMaterial?i.side:i}function kt(i,t,n,e,s,o,r){const a=e*3;let l=a+0,x=a+1,p=a+2;const{index:f,groups:c}=i;i.index&&(l=f.getX(l),x=f.getX(x),p=f.getX(p));const{position:u,normal:h,uv:A,uv1:g}=i.attributes;if(Array.isArray(t)){const w=e*3;for(let y=0,d=c.length;y<d;y++){const{start:m,count:B,materialIndex:P}=c[y];if(w>=m&&w<m+B){const S=Cn(t[P]),b=Un(n,u,h,A,g,l,x,p,S,o,r);if(b)if(b.faceIndex=e,b.face.materialIndex=P,s)s.push(b);else return b}}}else{const w=Cn(t),y=Un(n,u,h,A,g,l,x,p,w,o,r);if(y)if(y.faceIndex=e,y.face.materialIndex=0,s)s.push(y);else return y}return null}function N(i,t,n,e){const s=i.a,o=i.b,r=i.c;let a=t,l=t+1,x=t+2;n&&(a=n.getX(a),l=n.getX(l),x=n.getX(x)),s.x=e.getX(a),s.y=e.getY(a),s.z=e.getZ(a),o.x=e.getX(l),o.y=e.getY(l),o.z=e.getZ(l),r.x=e.getX(x),r.y=e.getY(x),r.z=e.getZ(x)}function Ae(i,t,n,e,s,o,r,a){const{geometry:l,_indirectBuffer:x}=i;for(let p=e,f=e+s;p<f;p++)kt(l,t,n,p,o,r,a)}function de(i,t,n,e,s,o,r){const{geometry:a,_indirectBuffer:l}=i;let x=1/0,p=null;for(let f=e,c=e+s;f<c;f++){let u;u=kt(a,t,n,f,null,o,r),u&&u.distance<x&&(p=u,x=u.distance)}return p}function we(i,t,n,e,s,o,r){const{geometry:a}=n,{index:l}=a,x=a.attributes.position;for(let p=i,f=t+i;p<f;p++){let c;if(c=p,N(r,c*3,l,x),r.needsUpdate=!0,e(r,c,s,o))return!0}return!1}function Be(i,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=i.geometry,e=n.index?n.index.array:null,s=n.attributes.position;let o,r,a,l,x=0;const p=i._roots;for(let c=0,u=p.length;c<u;c++)o=p[c],r=new Uint32Array(o),a=new Uint16Array(o),l=new Float32Array(o),f(0,x),x+=o.byteLength;function f(c,u,h=!1){const A=c*2;if(D(A,a)){const g=$(c,r),w=X(A,a);let y=1/0,d=1/0,m=1/0,B=-1/0,P=-1/0,S=-1/0;for(let b=3*g,v=3*(g+w);b<v;b++){let _=e[b];const M=s.getX(_),T=s.getY(_),U=s.getZ(_);M<y&&(y=M),M>B&&(B=M),T<d&&(d=T),T>P&&(P=T),U<m&&(m=U),U>S&&(S=U)}return l[c+0]!==y||l[c+1]!==d||l[c+2]!==m||l[c+3]!==B||l[c+4]!==P||l[c+5]!==S?(l[c+0]=y,l[c+1]=d,l[c+2]=m,l[c+3]=B,l[c+4]=P,l[c+5]=S,!0):!1}else{const g=V(c),w=F(c,r);let y=h,d=!1,m=!1;if(t){if(!y){const _=g/I+u/H,M=w/I+u/H;d=t.has(_),m=t.has(M),y=!d&&!m}}else d=!0,m=!0;const B=y||d,P=y||m;let S=!1;B&&(S=f(g,u,y));let b=!1;P&&(b=f(w,u,y));const v=S||b;if(v)for(let _=0;_<3;_++){const M=g+_,T=w+_,U=l[M],C=l[M+3],L=l[T],q=l[T+3];l[c+_]=U<L?U:L,l[c+_+3]=C>q?C:q}return v}}}function G(i,t,n,e,s){let o,r,a,l,x,p;const f=1/n.direction.x,c=1/n.direction.y,u=1/n.direction.z,h=n.origin.x,A=n.origin.y,g=n.origin.z;let w=t[i],y=t[i+3],d=t[i+1],m=t[i+3+1],B=t[i+2],P=t[i+3+2];return f>=0?(o=(w-h)*f,r=(y-h)*f):(o=(y-h)*f,r=(w-h)*f),c>=0?(a=(d-A)*c,l=(m-A)*c):(a=(m-A)*c,l=(d-A)*c),o>l||a>r||((a>o||isNaN(o))&&(o=a),(l<r||isNaN(r))&&(r=l),u>=0?(x=(B-g)*u,p=(P-g)*u):(x=(P-g)*u,p=(B-g)*u),o>p||x>r)?!1:((x>o||o!==o)&&(o=x),(p<r||r!==r)&&(r=p),o<=s&&r>=e)}function be(i,t,n,e,s,o,r,a){const{geometry:l,_indirectBuffer:x}=i;for(let p=e,f=e+s;p<f;p++){let c=x?x[p]:p;kt(l,t,n,c,o,r,a)}}function _e(i,t,n,e,s,o,r){const{geometry:a,_indirectBuffer:l}=i;let x=1/0,p=null;for(let f=e,c=e+s;f<c;f++){let u;u=kt(a,t,n,l?l[f]:f,null,o,r),u&&u.distance<x&&(p=u,x=u.distance)}return p}function Te(i,t,n,e,s,o,r){const{geometry:a}=n,{index:l}=a,x=a.attributes.position;for(let p=i,f=t+i;p<f;p++){let c;if(c=n.resolveTriangleIndex(p),N(r,c*3,l,x),r.needsUpdate=!0,e(r,c,s,o))return!0}return!1}function Pe(i,t,n,e,s,o,r){E.setBuffer(i._roots[t]),rn(0,i,n,e,s,o,r),E.clearBuffer()}function rn(i,t,n,e,s,o,r){const{float32Array:a,uint16Array:l,uint32Array:x}=E,p=i*2;if(D(p,l)){const c=$(i,x),u=X(p,l);Ae(t,n,e,c,u,s,o,r)}else{const c=V(i);G(c,a,e,o,r)&&rn(c,t,n,e,s,o,r);const u=F(i,x);G(u,a,e,o,r)&&rn(u,t,n,e,s,o,r)}}const Se=["x","y","z"];function Me(i,t,n,e,s,o){E.setBuffer(i._roots[t]);const r=on(0,i,n,e,s,o);return E.clearBuffer(),r}function on(i,t,n,e,s,o){const{float32Array:r,uint16Array:a,uint32Array:l}=E;let x=i*2;if(D(x,a)){const f=$(i,l),c=X(x,a);return de(t,n,e,f,c,s,o)}else{const f=xn(i,l),c=Se[f],h=e.direction[c]>=0;let A,g;h?(A=V(i),g=F(i,l)):(A=F(i,l),g=V(i));const y=G(A,r,e,s,o)?on(A,t,n,e,s,o):null;if(y){const B=y.point[c];if(h?B<=r[g+f]:B>=r[g+f+3])return y}const m=G(g,r,e,s,o)?on(g,t,n,e,s,o):null;return y&&m?y.distance<=m.distance?y:m:y||m||null}}const Lt=new O,ct=new pt,lt=new pt,gt=new Q,Ln=new k,zt=new k;function ve(i,t,n,e){E.setBuffer(i._roots[t]);const s=cn(0,i,n,e);return E.clearBuffer(),s}function cn(i,t,n,e,s=null){const{float32Array:o,uint16Array:r,uint32Array:a}=E;let l=i*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),Ln.set(n.boundingBox.min,n.boundingBox.max,e),s=Ln),D(l,r)){const p=t.geometry,f=p.index,c=p.attributes.position,u=n.index,h=n.attributes.position,A=$(i,a),g=X(l,r);if(gt.copy(e).invert(),n.boundsTree)return R(i,o,zt),zt.matrix.copy(gt),zt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:y=>zt.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(e),y.b.applyMatrix4(e),y.c.applyMatrix4(e),y.needsUpdate=!0;for(let d=A*3,m=(g+A)*3;d<m;d+=3)if(N(lt,d,f,c),lt.needsUpdate=!0,y.intersectsTriangle(lt))return!0;return!1}});{const w=Xt(n);for(let y=A*3,d=(g+A)*3;y<d;y+=3){N(ct,y,f,c),ct.a.applyMatrix4(gt),ct.b.applyMatrix4(gt),ct.c.applyMatrix4(gt),ct.needsUpdate=!0;for(let m=0,B=w*3;m<B;m+=3)if(N(lt,m,u,h),lt.needsUpdate=!0,ct.intersectsTriangle(lt))return!0}}}else{const p=V(i),f=F(i,a);return R(p,o,Lt),!!(s.intersectsBox(Lt)&&cn(p,t,n,e,s)||(R(f,o,Lt),s.intersectsBox(Lt)&&cn(f,t,n,e,s)))}}const Et=new Q,Jt=new k,At=new k,Ue=new z,Ce=new z,Le=new z,ze=new z;function Ee(i,t,n,e={},s={},o=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Jt.set(t.boundingBox.min,t.boundingBox.max,n),Jt.needsUpdate=!0;const a=i.geometry,l=a.attributes.position,x=a.index,p=t.attributes.position,f=t.index,c=Y.getPrimitive(),u=Y.getPrimitive();let h=Ue,A=Ce,g=null,w=null;s&&(g=Le,w=ze);let y=1/0,d=null,m=null;return Et.copy(n).invert(),At.matrix.copy(Et),i.shapecast({boundsTraverseOrder:B=>Jt.distanceToBox(B),intersectsBounds:(B,P,S)=>S<y&&S<r?(P&&(At.min.copy(B.min),At.max.copy(B.max),At.needsUpdate=!0),!0):!1,intersectsRange:(B,P)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:b=>At.distanceToBox(b),intersectsBounds:(b,v,_)=>_<y&&_<r,intersectsRange:(b,v)=>{for(let _=b,M=b+v;_<M;_++){N(u,3*_,f,p),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let T=B,U=B+P;T<U;T++){N(c,3*T,x,l),c.needsUpdate=!0;const C=c.distanceToTriangle(u,h,g);if(C<y&&(A.copy(h),w&&w.copy(g),y=C,d=T,m=_),C<o)return!0}}}});{const S=Xt(t);for(let b=0,v=S;b<v;b++){N(u,3*b,f,p),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let _=B,M=B+P;_<M;_++){N(c,3*_,x,l),c.needsUpdate=!0;const T=c.distanceToTriangle(u,h,g);if(T<y&&(A.copy(h),w&&w.copy(g),y=T,d=_,m=b),T<o)return!0}}}}}),Y.releasePrimitive(c),Y.releasePrimitive(u),y===1/0?null:(e.point?e.point.copy(A):e.point=A.clone(),e.distance=y,e.faceIndex=d,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(Et),A.applyMatrix4(Et),s.distance=A.sub(s.point).length(),s.faceIndex=m),e)}function Re(i,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=i.geometry,e=n.index?n.index.array:null,s=n.attributes.position;let o,r,a,l,x=0;const p=i._roots;for(let c=0,u=p.length;c<u;c++)o=p[c],r=new Uint32Array(o),a=new Uint16Array(o),l=new Float32Array(o),f(0,x),x+=o.byteLength;function f(c,u,h=!1){const A=c*2;if(D(A,a)){const g=$(c,r),w=X(A,a);let y=1/0,d=1/0,m=1/0,B=-1/0,P=-1/0,S=-1/0;for(let b=g,v=g+w;b<v;b++){const _=3*i.resolveTriangleIndex(b);for(let M=0;M<3;M++){let T=_+M;T=e?e[T]:T;const U=s.getX(T),C=s.getY(T),L=s.getZ(T);U<y&&(y=U),U>B&&(B=U),C<d&&(d=C),C>P&&(P=C),L<m&&(m=L),L>S&&(S=L)}}return l[c+0]!==y||l[c+1]!==d||l[c+2]!==m||l[c+3]!==B||l[c+4]!==P||l[c+5]!==S?(l[c+0]=y,l[c+1]=d,l[c+2]=m,l[c+3]=B,l[c+4]=P,l[c+5]=S,!0):!1}else{const g=V(c),w=F(c,r);let y=h,d=!1,m=!1;if(t){if(!y){const _=g/I+u/H,M=w/I+u/H;d=t.has(_),m=t.has(M),y=!d&&!m}}else d=!0,m=!0;const B=y||d,P=y||m;let S=!1;B&&(S=f(g,u,y));let b=!1;P&&(b=f(w,u,y));const v=S||b;if(v)for(let _=0;_<3;_++){const M=g+_,T=w+_,U=l[M],C=l[M+3],L=l[T],q=l[T+3];l[c+_]=U<L?U:L,l[c+_+3]=C>q?C:q}return v}}}function Ne(i,t,n,e,s,o,r){E.setBuffer(i._roots[t]),ln(0,i,n,e,s,o,r),E.clearBuffer()}function ln(i,t,n,e,s,o,r){const{float32Array:a,uint16Array:l,uint32Array:x}=E,p=i*2;if(D(p,l)){const c=$(i,x),u=X(p,l);be(t,n,e,c,u,s,o,r)}else{const c=V(i);G(c,a,e,o,r)&&ln(c,t,n,e,s,o,r);const u=F(i,x);G(u,a,e,o,r)&&ln(u,t,n,e,s,o,r)}}const Ie=["x","y","z"];function De(i,t,n,e,s,o){E.setBuffer(i._roots[t]);const r=an(0,i,n,e,s,o);return E.clearBuffer(),r}function an(i,t,n,e,s,o){const{float32Array:r,uint16Array:a,uint32Array:l}=E;let x=i*2;if(D(x,a)){const f=$(i,l),c=X(x,a);return _e(t,n,e,f,c,s,o)}else{const f=xn(i,l),c=Ie[f],h=e.direction[c]>=0;let A,g;h?(A=V(i),g=F(i,l)):(A=F(i,l),g=V(i));const y=G(A,r,e,s,o)?an(A,t,n,e,s,o):null;if(y){const B=y.point[c];if(h?B<=r[g+f]:B>=r[g+f+3])return y}const m=G(g,r,e,s,o)?an(g,t,n,e,s,o):null;return y&&m?y.distance<=m.distance?y:m:y||m||null}}const Rt=new O,at=new pt,ft=new pt,dt=new Q,zn=new k,Nt=new k;function Ve(i,t,n,e){E.setBuffer(i._roots[t]);const s=fn(0,i,n,e);return E.clearBuffer(),s}function fn(i,t,n,e,s=null){const{float32Array:o,uint16Array:r,uint32Array:a}=E;let l=i*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),zn.set(n.boundingBox.min,n.boundingBox.max,e),s=zn),D(l,r)){const p=t.geometry,f=p.index,c=p.attributes.position,u=n.index,h=n.attributes.position,A=$(i,a),g=X(l,r);if(dt.copy(e).invert(),n.boundsTree)return R(i,o,Nt),Nt.matrix.copy(dt),Nt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:y=>Nt.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(e),y.b.applyMatrix4(e),y.c.applyMatrix4(e),y.needsUpdate=!0;for(let d=A,m=g+A;d<m;d++)if(N(ft,3*t.resolveTriangleIndex(d),f,c),ft.needsUpdate=!0,y.intersectsTriangle(ft))return!0;return!1}});{const w=Xt(n);for(let y=A,d=g+A;y<d;y++){const m=t.resolveTriangleIndex(y);N(at,3*m,f,c),at.a.applyMatrix4(dt),at.b.applyMatrix4(dt),at.c.applyMatrix4(dt),at.needsUpdate=!0;for(let B=0,P=w*3;B<P;B+=3)if(N(ft,B,u,h),ft.needsUpdate=!0,at.intersectsTriangle(ft))return!0}}}else{const p=V(i),f=F(i,a);return R(p,o,Rt),!!(s.intersectsBox(Rt)&&fn(p,t,n,e,s)||(R(f,o,Rt),s.intersectsBox(Rt)&&fn(f,t,n,e,s)))}}const It=new Q,Qt=new k,wt=new k,Fe=new z,He=new z,$e=new z,Xe=new z;function ke(i,t,n,e={},s={},o=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Qt.set(t.boundingBox.min,t.boundingBox.max,n),Qt.needsUpdate=!0;const a=i.geometry,l=a.attributes.position,x=a.index,p=t.attributes.position,f=t.index,c=Y.getPrimitive(),u=Y.getPrimitive();let h=Fe,A=He,g=null,w=null;s&&(g=$e,w=Xe);let y=1/0,d=null,m=null;return It.copy(n).invert(),wt.matrix.copy(It),i.shapecast({boundsTraverseOrder:B=>Qt.distanceToBox(B),intersectsBounds:(B,P,S)=>S<y&&S<r?(P&&(wt.min.copy(B.min),wt.max.copy(B.max),wt.needsUpdate=!0),!0):!1,intersectsRange:(B,P)=>{if(t.boundsTree){const S=t.boundsTree;return S.shapecast({boundsTraverseOrder:b=>wt.distanceToBox(b),intersectsBounds:(b,v,_)=>_<y&&_<r,intersectsRange:(b,v)=>{for(let _=b,M=b+v;_<M;_++){const T=S.resolveTriangleIndex(_);N(u,3*T,f,p),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let U=B,C=B+P;U<C;U++){const L=i.resolveTriangleIndex(U);N(c,3*L,x,l),c.needsUpdate=!0;const q=c.distanceToTriangle(u,h,g);if(q<y&&(A.copy(h),w&&w.copy(g),y=q,d=U,m=_),q<o)return!0}}}})}else{const S=Xt(t);for(let b=0,v=S;b<v;b++){N(u,3*b,f,p),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let _=B,M=B+P;_<M;_++){const T=i.resolveTriangleIndex(_);N(c,3*T,x,l),c.needsUpdate=!0;const U=c.distanceToTriangle(u,h,g);if(U<y&&(A.copy(h),w&&w.copy(g),y=U,d=_,m=b),U<o)return!0}}}}}),Y.releasePrimitive(c),Y.releasePrimitive(u),y===1/0?null:(e.point?e.point.copy(A):e.point=A.clone(),e.distance=y,e.faceIndex=d,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(It),A.applyMatrix4(It),s.distance=A.sub(s.point).length(),s.faceIndex=m),e)}function En(i,t,n){return i===null?null:(i.point.applyMatrix4(t.matrixWorld),i.distance=i.point.distanceTo(n.ray.origin),i.object=t,i)}const Dt=new k,Vt=new Zn,Rn=new z,Nn=new Q,In=new z,Gt=["getX","getY","getZ"];class un extends ye{static serialize(t,n={}){n={cloneBuffers:!0,...n};const e=t.geometry,s=t._roots,o=t._indirectBuffer,r=e.getIndex(),a={version:1,roots:null,index:null,indirectBuffer:null};return n.cloneBuffers?(a.roots=s.map(l=>l.slice()),a.index=r?r.array.slice():null,a.indirectBuffer=o?o.slice():null):(a.roots=s,a.index=r?r.array:null,a.indirectBuffer=o),a}static deserialize(t,n,e={}){e={setIndex:!0,indirect:!!t.indirectBuffer,...e};const{index:s,roots:o,indirectBuffer:r}=t;t.version||(console.warn("MeshBVH.deserialize: Serialization format has been changed and will be fixed up. It is recommended to regenerate any stored serialized data."),l(o));const a=new un(n,{...e,[yn]:!0});if(a._roots=o,a._indirectBuffer=r||null,e.setIndex){const x=n.getIndex();if(x===null){const p=new Dn(t.index,1,!1);n.setIndex(p)}else x.array!==s&&(x.array.set(s),x.needsUpdate=!0)}return a;function l(x){for(let p=0;p<x.length;p++){const f=x[p],c=new Uint32Array(f),u=new Uint16Array(f);for(let h=0,A=f.byteLength/H;h<A;h++){const g=I*h,w=2*g;D(w,u)||(c[g+6]=c[g+6]/I-h)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(t,n={}){n.maxLeafTris&&(console.warn('MeshBVH: "maxLeafTris" option has been deprecated. Use maxLeafSize, instead.'),n={...n,maxLeafSize:n.maxLeafTris}),super(t,n)}shiftTriangleOffsets(t){return super.shiftPrimitiveOffsets(t)}writePrimitiveBounds(t,n,e){const s=this.geometry,o=this._indirectBuffer,r=s.attributes.position,a=s.index?s.index.array:null,x=(o?o[t]:t)*3;let p=x+0,f=x+1,c=x+2;a&&(p=a[p],f=a[f],c=a[c]);for(let u=0;u<3;u++){const h=r[Gt[u]](p),A=r[Gt[u]](f),g=r[Gt[u]](c);let w=h;A<w&&(w=A),g<w&&(w=g);let y=h;A>y&&(y=A),g>y&&(y=g),n[e+u]=w,n[e+u+3]=y}return n}computePrimitiveBounds(t,n,e){const s=this.geometry,o=this._indirectBuffer,r=s.attributes.position,a=s.index?s.index.array:null,l=r.normalized;if(t<0||n+t-e.offset>e.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const x=r.array,p=r.offset||0;let f=3;r.isInterleavedBufferAttribute&&(f=r.data.stride);const c=["getX","getY","getZ"],u=e.offset;for(let h=t,A=t+n;h<A;h++){const w=(o?o[h]:h)*3,y=(h-u)*6;let d=w+0,m=w+1,B=w+2;a&&(d=a[d],m=a[m],B=a[B]),l||(d=d*f+p,m=m*f+p,B=B*f+p);for(let P=0;P<3;P++){let S,b,v;l?(S=r[c[P]](d),b=r[c[P]](m),v=r[c[P]](B)):(S=x[d+P],b=x[m+P],v=x[B+P]);let _=S;b<_&&(_=b),v<_&&(_=v);let M=S;b>M&&(M=b),v>M&&(M=v);const T=(M-_)/2,U=P*2;e[y+U+0]=_+T,e[y+U+1]=T+(Math.abs(_)+T)*Ft}}return e}raycastObject3D(t,n,e=[]){const{material:s}=t;if(s===void 0)return;Nn.copy(t.matrixWorld).invert(),Vt.copy(n.ray).applyMatrix4(Nn),In.setFromMatrixScale(t.matrixWorld),Rn.copy(Vt.direction).multiply(In);const o=Rn.length(),r=n.near/o,a=n.far/o;if(n.firstHitOnly===!0){let l=this.raycastFirst(Vt,s,r,a);l=En(l,t,n),l&&e.push(l)}else{const l=this.raycast(Vt,s,r,a);for(let x=0,p=l.length;x<p;x++){const f=En(l[x],t,n);f&&e.push(f)}}return e}refit(t=null){return(this.indirect?Re:Be)(this,t)}raycast(t,n=An,e=0,s=1/0){const o=this._roots,r=[],a=this.indirect?Ne:Pe;for(let l=0,x=o.length;l<x;l++)a(this,l,n,t,r,e,s);return r}raycastFirst(t,n=An,e=0,s=1/0){const o=this._roots;let r=null;const a=this.indirect?De:Me;for(let l=0,x=o.length;l<x;l++){const p=a(this,l,n,t,e,s);p!=null&&(r==null||p.distance<r.distance)&&(r=p)}return r}intersectsGeometry(t,n){let e=!1;const s=this._roots,o=this.indirect?Ve:ve;for(let r=0,a=s.length;r<a&&(e=o(this,r,t,n),!e);r++);return e}shapecast(t){const n=Y.getPrimitive(),e=super.shapecast({...t,intersectsPrimitive:t.intersectsTriangle,scratchPrimitive:n,iterate:this.indirect?Te:we});return Y.releasePrimitive(n),e}bvhcast(t,n,e){let{intersectsRanges:s,intersectsTriangles:o}=e;const r=Y.getPrimitive(),a=this.geometry.index,l=this.geometry.attributes.position,x=this.indirect?h=>{const A=this.resolveTriangleIndex(h);N(r,A*3,a,l)}:h=>{N(r,h*3,a,l)},p=Y.getPrimitive(),f=t.geometry.index,c=t.geometry.attributes.position,u=t.indirect?h=>{const A=t.resolveTriangleIndex(h);N(p,A*3,f,c)}:h=>{N(p,h*3,f,c)};if(o){if(!(t instanceof un))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const h=(A,g,w,y,d,m,B,P)=>{for(let S=w,b=w+y;S<b;S++){u(S),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let v=A,_=A+g;v<_;v++)if(x(v),r.needsUpdate=!0,o(r,p,v,S,d,m,B,P))return!0}return!1};if(s){const A=s;s=function(g,w,y,d,m,B,P,S){return A(g,w,y,d,m,B,P,S)?!0:h(g,w,y,d,m,B,P,S)}}else s=h}return super.bvhcast(t,n,{intersectsRanges:s})}intersectsBox(t,n){return Dt.set(t.min,t.max,n),Dt.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Dt.intersectsBox(e),intersectsTriangle:e=>Dt.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,e={},s={},o=0,r=1/0){return(this.indirect?ke:Ee)(this,t,n,e,s,o,r)}closestPointToPoint(t,n={},e=0,s=1/0){return he(this,t,n,e,s)}}export{On as A,oe as B,Fn as C,ye as G,Ze as I,Oe as L,un as M,Ye as N,$ as O,hn as P,Wn as S,wn as T,dn as a,mn as b,je as c,H as d,ae as e,D as f,le as g,X as h,ce as i,xn as j,We as k,yn as l,qt as m,R as n};
//# sourceMappingURL=MeshBVH-DQV6PBDm.js.map
