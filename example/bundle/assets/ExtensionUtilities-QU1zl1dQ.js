import{M as B,K as M,j as _,n as x,Y as S,V as I,aN as V}from"./ExtendedTriangle-DttJMGjs.js";import{M as y}from"./MeshBVH-DAC57waP.js";function b(e,t,r){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(r.ray.origin),e.object=t,e)}const W=parseInt(V)>=166,g=new S,p=new I,w=new x,A=B.prototype.raycast,F=_.prototype.raycast,T=new I,s=new B,m=[];function O(e,t){this.isBatchedMesh?v.call(this,e,t):j.call(this,e,t)}function v(e,t){if(this.boundsTrees){const r=this.boundsTrees,o=this._drawInfo||this._instanceInfo,n=this._drawRanges||this._geometryInfo,i=this.matrixWorld;s.material=this.material,s.geometry=this.geometry;const l=s.geometry.boundsTree,h=s.geometry.drawRange;s.geometry.boundingSphere===null&&(s.geometry.boundingSphere=new M);for(let a=0,u=o.length;a<u;a++){if(!this.getVisibleAt(a))continue;const d=o[a].geometryIndex;if(s.geometry.boundsTree=r[d],this.getMatrixAt(a,s.matrixWorld).premultiply(i),!s.geometry.boundsTree){this.getBoundingBoxAt(d,s.geometry.boundingBox),this.getBoundingSphereAt(d,s.geometry.boundingSphere);const c=n[d];s.geometry.setDrawRange(c.start,c.count)}s.raycast(e,m);for(let c=0,R=m.length;c<R;c++){const f=m[c];f.object=this,f.batchId=a,t.push(f)}m.length=0}s.geometry.boundsTree=l,s.geometry.drawRange=h,s.material=null,s.geometry=null}else F.call(this,e,t)}function j(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;w.copy(this.matrixWorld).invert(),g.copy(e.ray).applyMatrix4(w),T.setFromMatrixScale(this.matrixWorld),p.copy(g.direction).multiply(T);const r=p.length(),o=e.near/r,n=e.far/r,i=this.geometry.boundsTree;if(e.firstHitOnly===!0){const l=b(i.raycastFirst(g,this.material,o,n),this,e);l&&t.push(l)}else{const l=i.raycast(g,this.material,o,n);for(let h=0,a=l.length;h<a;h++){const u=b(l[h],this,e);u&&t.push(u)}}}else A.call(this,e,t)}function C(e={}){return this.boundsTree=new y(this,e),this.boundsTree}function D(){this.boundsTree=null}function H(e=-1,t={}){if(!W)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");t.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),t={...t,indirect:!1,range:null};const r=this._drawRanges||this._geometryInfo,o=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(o).fill(null));const n=this.boundsTrees;for(;n.length<o;)n.push(null);if(e<0){for(let i=0;i<o;i++)t.range=r[i],n[i]=new y(this.geometry,t);return n}else return e<r.length&&(t.range=r[e],n[e]=new y(this.geometry,t)),n[e]||null}function q(e=-1){e<0?this.boundsTrees.fill(null):e<this.boundsTree.length&&(this.boundsTrees[e]=null)}export{O as a,H as b,C as c,D as d,q as e};
