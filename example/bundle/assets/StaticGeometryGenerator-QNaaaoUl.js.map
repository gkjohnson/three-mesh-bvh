{"version":3,"file":"StaticGeometryGenerator-QNaaaoUl.js","sources":["../../../src/utils/StaticGeometryGenerator.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t// remove all geometry\n\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t}\n\n\t\t\t// create dummy attributes\n\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t}\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t// copy the index\n\t\tif ( geometry.index ) {\n\n\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t}\n\n\t\t// copy and apply other attributes\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\tinvertGeometry( targetGeometry );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n"],"names":["_positionVector","Vector3","_normalVector","_tangentVector","_tangentVector4","Vector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","Matrix4","_boneMatrix","validateAttributes","attr1","attr2","sameCount","sameNormalized","sameType","sameItemSize","createAttributeClone","attr","countOverride","cons","normalized","itemSize","count","BufferAttribute","copyAttributeContents","target","targetOffset","i","l","io","array","byteOffset","addScaledMatrix","matrix","scale","targetArray","matrixArray","boneNormalTransform","mesh","index","skeleton","geometry","bones","boneInverses","weight","boneIndex","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","mergeBufferGeometries","geometries","options","targetGeometry","BufferGeometry","isIndexed","useGroups","updateIndex","skipAttributes","attributesUsed","attributes","offset","attributesCount","name","forceUpdateIndex","indexCount","targetIndex","indexOffset","attrList","key","targetAttribute","checkTypedArrayEquality","a","b","invertGeometry","v0","v2","GeometryDiff","primitiveCount","boneMatrices","StaticGeometryGenerator","meshes","finalMeshes","object","c","materials","_intermediateGeometry","_diffMap","geom","diff","attrs","applyWorldTransforms","includeNormal","includeTangent","targetAttributes","position","normal","tangent","morphPosition","morphNormal","morphTangent","normalMatrix","Matrix3"],"mappings":"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"}