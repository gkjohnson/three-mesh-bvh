{"version":3,"file":"3dtex_repro-C9_1bMBl.js","sources":["../../3dtex_repro.js"],"sourcesContent":["import * as THREE from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MeshBVH, MeshBVHUniformStruct } from 'three-mesh-bvh';\n\nclass GenerateSDFMaterial extends THREE.ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t/* common_functions.glsl.js */\n\n\t\t\t\t// A stack of uint32 indices can can store the indices for\n\t\t\t\t// a perfectly balanced tree with a depth up to 31. Lower stack\n\t\t\t\t// depth gets higher performance.\n\t\t\t\t//\n\t\t\t\t// However not all trees are balanced. Best value to set this to\n\t\t\t\t// is the trees max depth.\n\t\t\t\t#ifndef BVH_STACK_DEPTH\n\t\t\t\t#define BVH_STACK_DEPTH 60\n\t\t\t\t#endif\n\n\t\t\t\t#ifndef INFINITY\n\t\t\t\t#define INFINITY 1e20\n\t\t\t\t#endif\n\n\t\t\t\t// Utilities\n\t\t\t\tuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\t\t\t\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\t\t\t\tuvec2 uv;\n\t\t\t\t\tuv.x = index % width;\n\t\t\t\t\tuv.y = index / width;\n\n\t\t\t\t\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n\t\t\t\t}\n\n\t\t\t\tvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\t\t\t\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\t\t\t\tuvec2 uv;\n\t\t\t\t\tuv.x = index % width;\n\t\t\t\t\tuv.y = index / width;\n\n\t\t\t\t\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n\t\t\t\t}\n\n\t\t\t\t/* bvh_struct_definitions.glsl.js */\n\t\t\t\tstruct BVH {\n\n\t\t\t\t\tusampler2D index;\n\t\t\t\t\tsampler2D position;\n\n\t\t\t\t\tsampler2D bvhBounds;\n\t\t\t\t\tusampler2D bvhContents;\n\n\t\t\t\t};\n\n\t\t\t\t/* bvh_ray_functions.glsl.js */\n\t\t\t\t#ifndef TRI_INTERSECT_EPSILON\n\t\t\t\t#define TRI_INTERSECT_EPSILON 1e-5\n\t\t\t\t#endif\n\n\t\t\t\t// Raycasting\n\t\t\t\tbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t\t\t\t\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t\t\t\t\t// https://tavianator.com/2011/ray_box.html\n\t\t\t\t\tvec3 invDir = 1.0 / rayDirection;\n\n\t\t\t\t\t// find intersection distances for each plane\n\t\t\t\t\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\t\t\t\t\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t\t\t\t\t// get the min and max distances from each intersection\n\t\t\t\t\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\t\t\t\t\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t\t\t\t\t// get the furthest hit distance\n\t\t\t\t\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\t\t\t\t\tfloat t0 = max( t.x, t.y );\n\n\t\t\t\t\t// get the minimum hit distance\n\t\t\t\t\tt = min( tMaxHit.xx, tMaxHit.yz );\n\t\t\t\t\tfloat t1 = min( t.x, t.y );\n\n\t\t\t\t\t// set distance to 0.0 if the ray starts inside the box\n\t\t\t\t\tdist = max( t0, 0.0 );\n\n\t\t\t\t\treturn t1 >= dist;\n\n\t\t\t\t}\n\n\t\t\t\tbool intersectsTriangle(\n\t\t\t\t\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\t\t\t\t\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n\t\t\t\t) {\n\n\t\t\t\t\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\t\t\t\t\tvec3 edge1 = b - a;\n\t\t\t\t\tvec3 edge2 = c - a;\n\t\t\t\t\tnorm = cross( edge1, edge2 );\n\n\t\t\t\t\tfloat det = - dot( rayDirection, norm );\n\t\t\t\t\tfloat invdet = 1.0 / det;\n\n\t\t\t\t\tvec3 AO = rayOrigin - a;\n\t\t\t\t\tvec3 DAO = cross( AO, rayDirection );\n\n\t\t\t\t\tvec4 uvt;\n\t\t\t\t\tuvt.x = dot( edge2, DAO ) * invdet;\n\t\t\t\t\tuvt.y = - dot( edge1, DAO ) * invdet;\n\t\t\t\t\tuvt.z = dot( AO, norm ) * invdet;\n\t\t\t\t\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t\t\t\t\t// set the hit information\n\t\t\t\t\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\t\t\t\t\tdist = uvt.z;\n\t\t\t\t\tside = sign( det );\n\t\t\t\t\tnorm = side * normalize( norm );\n\n\t\t\t\t\t// add an epsilon to avoid misses between triangles\n\t\t\t\t\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\t\t\t\t\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tbool intersectTriangles(\n\t\t\t\t\t// geometry info and triangle range\n\t\t\t\t\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t\t\t\t\t// ray\n\t\t\t\t\tvec3 rayOrigin, vec3 rayDirection,\n\n\t\t\t\t\t// outputs\n\t\t\t\t\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\t\t\t\t\tinout float side, inout float dist\n\t\t\t\t) {\n\n\t\t\t\t\tbool found = false;\n\t\t\t\t\tvec3 localBarycoord, localNormal;\n\t\t\t\t\tfloat localDist, localSide;\n\t\t\t\t\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\t\t\t\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\t\t\t\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\t\t\t\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t\t\t\t\t&& localDist < minDistance\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tminDistance = localDist;\n\n\t\t\t\t\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\t\t\t\t\tfaceNormal = localNormal;\n\n\t\t\t\t\t\t\tside = localSide;\n\t\t\t\t\t\t\tbarycoord = localBarycoord;\n\t\t\t\t\t\t\tdist = localDist;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn found;\n\n\t\t\t\t}\n\n\t\t\t\tbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\t\t\t\t\tuint cni2 = currNodeIndex * 2u;\n\t\t\t\t\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\t\t\t\t\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\t\t\t\t\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n\t\t\t\t}\n\n\t\t\t\tbool _bvhIntersectFirstHit(\n\t\t\t\t\t// bvh info\n\t\t\t\t\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t\t\t\t\t// ray\n\t\t\t\t\tvec3 rayOrigin, vec3 rayDirection,\n\n\t\t\t\t\t// output variables split into separate variables due to output precision\n\t\t\t\t\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\t\t\t\t\tinout float side, inout float dist\n\t\t\t\t) {\n\n\t\t\t\t\t// stack needs to be twice as long as the deepest tree we expect because\n\t\t\t\t\t// we push both the left and right child onto the stack every traversal\n\t\t\t\t\tint ptr = 0;\n\t\t\t\t\tuint stack[ BVH_STACK_DEPTH ];\n\t\t\t\t\tstack[ 0 ] = 0u;\n\n\t\t\t\t\tfloat triangleDistance = INFINITY;\n\t\t\t\t\tbool found = false;\n\t\t\t\t\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\t\t\t\t\tuint currNodeIndex = stack[ ptr ];\n\t\t\t\t\t\tptr --;\n\n\t\t\t\t\t\t// check if we intersect the current bounds\n\t\t\t\t\t\tfloat boundsHitDistance;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t\t\t\t\t|| boundsHitDistance > triangleDistance\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\t\t\t\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\t\t\t\t\tuint offset = boundsInfo.y;\n\n\t\t\t\t\t\t\tfound = intersectTriangles(\n\t\t\t\t\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\t\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\t\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t\t\t\t\t) || found;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\t\t\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\t\t\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\t\t\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\t\t\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\t\t\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t\t\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t\t\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t\t\t\t\t// traversed first\n\t\t\t\t\t\t\tptr ++;\n\t\t\t\t\t\t\tstack[ ptr ] = c2;\n\n\t\t\t\t\t\t\tptr ++;\n\t\t\t\t\t\t\tstack[ ptr ] = c1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn found;\n\n\t\t\t\t}\n\n\t\t\t\t/* main */\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( 0.0 );\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tfloat rayDist;\n\n\t\t\t\t\tside = 1.0;\n\t\t\t\t\t_bvhIntersectFirstHit(\n\t\t\t\t\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\n\t\t\t\t\t\tpoint.xyz, vec3( 0, 0, 1 ), faceIndices, faceNormal, barycoord, side, rayDist\n\t\t\t\t\t);\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n\nconst params = {\n\n\tresolution: 75,\n\n};\n\nlet renderer, bvh, sdfTex, generateSdfPass;\n\ninit();\n\nfunction init() {\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// sdf pass to generate the 3d texture\n\tgenerateSdfPass = new FullScreenQuad( new GenerateSDFMaterial() );\n\n\tconst geometry = new THREE.TorusKnotGeometry( 1, 0.4, 1000, 500 );\n\t// const geometry = new THREE.TorusKnotGeometry( 1, 0.4, 100, 10 );\n\tbvh = new MeshBVH( geometry, { maxLeafSize: 1 } );\n\n\tupdateSDF();\n\n}\n\n// update the sdf texture based on the selected parameters\nfunction updateSDF() {\n\n\tconst dim = params.resolution;\n\n\t// create a new 3d render target texture\n\tconst floatLinearExtSupported = renderer.extensions.get( 'OES_texture_float_linear' );\n\tsdfTex = new THREE.WebGL3DRenderTarget( dim, dim, dim );\n\tsdfTex.texture.format = THREE.RedFormat;\n\tsdfTex.texture.type = floatLinearExtSupported ? THREE.FloatType : THREE.HalfFloatType;\n\tsdfTex.texture.minFilter = THREE.LinearFilter;\n\tsdfTex.texture.magFilter = THREE.LinearFilter;\n\n\t// prep the sdf generation material pass\n\tgenerateSdfPass.material.uniforms.bvh.value.updateFrom( bvh );\n\n\t// render into each layer\n\tfor ( let i = 0; i < dim; i ++ ) {\n\n\t\trenderer.setRenderTarget( sdfTex, i );\n\t\tgenerateSdfPass.render( renderer );\n\n\t}\n\n\t// initiate read back to get a rough estimate of time taken to generate the sdf\n\trenderer.readRenderTargetPixels( sdfTex, 0, 0, 1, 1, new Float32Array( 4 ) );\n\trenderer.setRenderTarget( null );\n\n\tconsole.log( 'DONE' );\n\n}\n"],"names":["GenerateSDFMaterial","THREE.ShaderMaterial","params","MeshBVHUniformStruct","renderer","bvh","sdfTex","generateSdfPass","init","THREE.WebGLRenderer","FullScreenQuad","geometry","THREE.TorusKnotGeometry","MeshBVH","updateSDF","dim","floatLinearExtSupported","THREE.WebGL3DRenderTarget","THREE.RedFormat","THREE.FloatType","THREE.HalfFloatType","THREE.LinearFilter","i"],"mappings":"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"}