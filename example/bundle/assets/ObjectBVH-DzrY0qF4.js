import{n as v,b as O,Y as k,M as C,i as D,V as G,K as V}from"./ExtendedTriangle-hsPasuNU.js";import{B as H,N as I,I as S}from"./MeshBVH-DQV6PBDm.js";const y=new D,u=new v,B=new v,R=new O,g=new V,f=new G,M=new k,p=new C,_={};function K(l,i){if(this.boundsTree)return this.boundsTree.raycast(l,i),!1}class U extends H{constructor(i,e={}){e={precise:!1,includeInstances:!0,matrixWorld:Array.isArray(i)?new v:i.matrixWorld,maxLeafSize:1,...e},super();const n=new Set;P(i,n);const a=Array.from(n),o=Math.ceil(Math.log2(a.length)),r=N(o);this.objects=a,this.idBits=o,this.idMask=r,this.primitiveBuffer=null,this.primitiveBufferStride=1,this.precise=e.precise,this.includeInstances=e.includeInstances,this.matrixWorld=e.matrixWorld,this.init(e)}init(i){const{objects:e,idBits:n}=this;this.primitiveBuffer=new Uint32Array(this._countPrimitives(e)),this._fillPrimitiveBuffer(e,n,this.primitiveBuffer),super.init(i)}writePrimitiveBounds(i,e,n){const{primitiveBuffer:a}=this;B.copy(this.matrixWorld).invert(),this._getPrimitiveBoundingBox(a[i],B,R);const{min:o,max:r}=R;e[n+0]=o.x,e[n+1]=o.y,e[n+2]=o.z,e[n+3]=r.x,e[n+4]=r.y,e[n+5]=r.z}getRootRanges(){return[{offset:0,count:this.primitiveBuffer.length}]}shapecast(i){return super.shapecast({...i,intersectsPrimitive:i.intersectsObject,scratchPrimitive:null,iterate:z})}raycast(i,e=[]){const{matrixWorld:n,includeInstances:a}=this,{firstHitOnly:o}=i,r=[];B.copy(n).invert(),M.copy(i.ray).applyMatrix4(B);let d=1/0,m=null;return this.shapecast({boundsTraverseOrder:s=>s.distanceToPoint(M.origin),intersectsBounds:s=>o?M.intersectBox(s,f)?(f.applyMatrix4(n),i.ray.origin.distanceTo(f)<d?S:I):I:M.intersectsBox(s)?S:I,intersectsObject(s,c){if(s.visible){if(s.isInstancedMesh&&a)p.geometry=s.geometry,p.material=s.material,s.getMatrixAt(c,p.matrixWorld),p.matrixWorld.premultiply(s.matrixWorld),p.raycast(i,r),r.forEach(t=>{t.object=s,t.instanceId=c}),p.material=null;else if(s.isBatchedMesh&&a){if(!s.getVisibleAt(c))return;const t=s.getGeometryIdAt(c),h=s.getGeometryRangeAt(t,_);y.index=s.geometry.index,y.attributes.position=s.geometry.attributes.position,y.setDrawRange(h.start,h.count),p.geometry=y,p.material=s.material,s.getMatrixAt(c,p.matrixWorld),p.matrixWorld.premultiply(s.matrixWorld),p.raycast(i,r),r.forEach(x=>{x.object=s,x.batchId=c}),p.material=null,y.index=null,y.attributes.position=null,y.setDrawRange(0,1/0)}else s.raycast(i,r);o?r.forEach(t=>{t.distance<d&&(d=t.distance,m=t)}):e.push(...r)}}}),o&&m&&e.push(m),e}_getPrimitiveBoundingBox(i,e,n){const{objects:a,idMask:o,idBits:r,precise:d,includeInstances:m}=this,s=w(i,o),c=E(i,r,o),t=a[s];if(!m&&(t.isInstancedMesh||t.isBatchedMesh))t.boundingBox||t.computeBoundingBox(),t.boundingSphere||t.computeBoundingSphere(),u.copy(t.matrixWorld).premultiply(e),g.copy(t.boundingSphere).applyMatrix4(u),n.copy(t.boundingBox).applyMatrix4(u),A(n,g);else if(d)if(t.isInstancedMesh)t.getMatrixAt(c,u),u.premultiply(t.matrixWorld).premultiply(e),b(t.geometry,u,n);else if(t.isBatchedMesh){const h=t.getGeometryIdAt(c),x=t.getGeometryRangeAt(h,_);y.index=t.geometry.index,y.attributes.position=t.geometry.attributes.position,y.setDrawRange(x.start,x.count),t.getMatrixAt(c,u),u.premultiply(t.matrixWorld).premultiply(e),b(y,u,n)}else u.copy(t.matrixWorld).premultiply(e),n.setFromObject(t,!0).applyMatrix4(e);else if(t.isInstancedMesh)t.geometry.boundingBox||t.geometry.computeBoundingBox(),t.geometry.boundingSphere||t.geometry.computeBoundingSphere(),t.getMatrixAt(c,u),u.premultiply(t.matrixWorld).premultiply(e),g.copy(t.geometry.boundingSphere).applyMatrix4(u),n.copy(t.geometry.boundingBox).applyMatrix4(u),A(n,g);else if(t.isBatchedMesh){const h=t.getGeometryIdAt(c);t.getMatrixAt(c,u),u.premultiply(t.matrixWorld).premultiply(e),t.getBoundingSphereAt(h,g).applyMatrix4(u),t.getBoundingBoxAt(h,n).applyMatrix4(u),A(n,g)}else n.setFromObject(t,!1).applyMatrix4(e)}_countPrimitives(i){const{includeInstances:e}=this;let n=0;return i.forEach(a=>{a.isInstancedMesh&&e?n+=a.count:a.isBatchedMesh&&e?n+=a.instanceCount:n++}),n}_fillPrimitiveBuffer(i,e,n){const{includeInstances:a}=this;let o=0;i.forEach((r,d)=>{if(r.isInstancedMesh&&a){const m=r.count;for(let s=0;s<m;s++)n[o]=s<<e|d,o++}else if(r.isBatchedMesh&&a){const{instanceCount:m,maxInstanceCount:s}=r;let c=0,t=0;for(;c<m&&t<s;){t++;try{r.getVisibleAt(c),n[o]=c<<e|d,c++,o++}catch{}}}else n[o]=d,o++})}}function N(l){let i=0;for(let e=0;e<l;e++)i=i<<1|1;return i}function w(l,i){return l&i}function E(l,i,e){return(l&~e)>>i}function P(l,i=new Set){Array.isArray(l)?l.forEach(e=>P(e,i)):l.traverse(e=>{(e.isMesh||e.isLine||e.isPoints)&&i.add(e)})}function b(l,i,e){e.makeEmpty();const n=l.drawRange,a=l.index,o=l.attributes.position,r=n.start,d=a?a.count:o.count,m=Math.min(d-r,n.count);for(let s=r,c=r+m;s<c;s++){let t=s;a&&(t=a.getX(t)),f.fromBufferAttribute(o,t).applyMatrix4(i),e.expandByPoint(f)}return e}function z(l,i,e,n,a,o){const{primitiveBuffer:r,objects:d,idMask:m,idBits:s}=e;for(let c=l,t=i+l;c<t;c++){const h=r[c],x=w(h,m),T=E(h,s,m),W=d[x];if(n(W,T,a,o))return!0}return!1}function A(l,i){f.copy(i.center).addScalar(-i.radius),l.min.max(f),f.copy(i.center).addScalar(i.radius),l.max.min(f)}export{U as O,K as o};
//# sourceMappingURL=ObjectBVH-DzrY0qF4.js.map
