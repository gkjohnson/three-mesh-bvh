{"version":3,"file":"MeshBVHUniformStruct-5h9E4Xx4.js","sources":["../../../src/webgl/VertexAttributeTexture.js","../../../src/webgl/MeshBVHUniformStruct.js"],"sourcesContent":["import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE, LEAFNODE_MASK_32 } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = LEAFNODE_MASK_32 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightNodeIndex = uint32Array[ nodeIndex32 + 6 ];\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightNodeIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n"],"names":["countToStringFormat","count","countToFormat","RedFormat","RGFormat","RGBAFormat","countToIntFormat","RedIntegerFormat","RGIntegerFormat","RGBAIntegerFormat","VertexAttributeTexture","DataTexture","NearestFilter","attr","overrideItemSize","originalItemSize","originalCount","itemSize","normalized","originalBufferCons","byteCount","targetType","finalStride","FloatType","UnsignedIntType","IntType","type","format","normalizeValue","targetBufferCons","internalFormat","UnsignedByteType","ByteType","ShortType","UnsignedShortType","dimension","length","dataArray","originalNormalized","i","ii","UIntVertexAttributeTexture","FloatVertexAttributeTexture","MeshBVHUniformStruct","bvh","geometry","bvhToTextures","indirectBuffer","array","getIndexArray","getVertexCount","BufferAttribute","dereferenceIndex","index","position","bvhBounds","bvhContents","target","unpacked","indexArray","l","i3","v3","c","boundsTexture","contentsTexture","roots","root","uint16Array","uint32Array","float32Array","nodeCount","BYTES_PER_NODE","boundsDimension","boundsArray","contentsDimension","contentsArray","nodeIndex32","nodeIndex16","boundsIndex","BOUNDING_DATA_INDEX","b","IS_LEAF","COUNT","offset","OFFSET","mergedLeafCount","LEAFNODE_MASK_32","rightNodeIndex","splitAxis","SPLIT_AXIS"],"mappings":"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"}