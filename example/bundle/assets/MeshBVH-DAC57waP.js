import{B as Pn,V as z,n as it,dC as Pt,aO as ut,o as pn,dD as vn,b as j,J as Mt,U as xt,y as Dn,t as Fn,aN as Mn,x as yn}from"./ExtendedTriangle-DttJMGjs.js";const Sn=0,Nn=1,Vn=2,Vi=0,Ii=1,xn=2,jt=1.25,An=1,bt=32,Xt=65535,In=Math.pow(2,-24),Yt=Symbol("SKIP_GENERATION");function $n(i){return i.index?i.index.count:i.attributes.position.count}function O(i){return $n(i)/3}function kn(i,n=ArrayBuffer){return i>65535?new Uint32Array(new n(4*i)):new Uint16Array(new n(2*i))}function qn(i,n){if(!i.index){const t=i.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=kn(t,e);i.setIndex(new Pn(s,1));for(let c=0;c<t;c++)s[c]=c}}function Cn(i,n){const t=O(i),e=n||i.drawRange,s=e.start/3,c=(e.start+e.count)/3,r=Math.max(0,s),l=Math.min(t,c)-r;return[{offset:Math.floor(r),count:Math.floor(l)}]}function Un(i,n){if(!i.groups||!i.groups.length)return Cn(i,n);const t=[],e=new Set,s=n||i.drawRange,c=s.start/3,r=(s.start+s.count)/3;for(const o of i.groups){const y=o.start/3,f=(o.start+o.count)/3;e.add(Math.max(c,y)),e.add(Math.min(r,f))}const l=Array.from(e.values()).sort((o,y)=>o-y);for(let o=0;o<l.length-1;o++){const y=l[o],f=l[o+1];t.push({offset:Math.floor(y),count:Math.floor(f-y)})}return t}function Xn(i,n){const t=O(i),e=Un(i,n).sort((r,l)=>r.offset-l.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let c=0;return e.forEach(({count:r})=>c+=r),t!==c}function Zt(i,n,t,e,s){let c=1/0,r=1/0,l=1/0,o=-1/0,y=-1/0,f=-1/0,u=1/0,a=1/0,p=1/0,d=-1/0,b=-1/0,h=-1/0;for(let w=n*6,x=(n+t)*6;w<x;w+=6){const m=i[w+0],g=i[w+1],A=m-g,T=m+g;A<c&&(c=A),T>o&&(o=T),m<u&&(u=m),m>d&&(d=m);const B=i[w+2],P=i[w+3],S=B-P,M=B+P;S<r&&(r=S),M>y&&(y=M),B<a&&(a=B),B>b&&(b=B);const U=i[w+4],_=i[w+5],C=U-_,L=U+_;C<l&&(l=C),L>f&&(f=L),U<p&&(p=U),U>h&&(h=U)}e[0]=c,e[1]=r,e[2]=l,e[3]=o,e[4]=y,e[5]=f,s[0]=u,s[1]=a,s[2]=p,s[3]=d,s[4]=b,s[5]=h}function Hn(i,n=null,t=null,e=null){const s=i.attributes.position,c=i.index?i.index.array:null,r=O(i),l=s.normalized;let o;n===null?o=new Float32Array(r*6):o=n,t=t||0,e=e||r;const y=s.array,f=s.offset||0;let u=3;s.isInterleavedBufferAttribute&&(u=s.data.stride);const a=["getX","getY","getZ"];for(let p=t;p<t+e;p++){const d=p*3,b=p*6;let h=d+0,w=d+1,x=d+2;c&&(h=c[h],w=c[w],x=c[x]),l||(h=h*u+f,w=w*u+f,x=x*u+f);for(let m=0;m<3;m++){let g,A,T;l?(g=s[a[m]](h),A=s[a[m]](w),T=s[a[m]](x)):(g=y[h+m],A=y[w+m],T=y[x+m]);let B=g;A<B&&(B=A),T<B&&(B=T);let P=g;A>P&&(P=A),T>P&&(P=T);const S=(P-B)/2,M=m*2;o[b+M+0]=B+S,o[b+M+1]=S+(Math.abs(B)+S)*In}}return o}function v(i,n,t){return t.min.x=n[i],t.min.y=n[i+1],t.min.z=n[i+2],t.max.x=n[i+3],t.max.y=n[i+4],t.max.z=n[i+5],t}function mn(i){let n=-1,t=-1/0;for(let e=0;e<3;e++){const s=i[e+3]-i[e];s>t&&(t=s,n=e)}return n}function hn(i,n){n.set(i)}function gn(i,n,t){let e,s;for(let c=0;c<3;c++){const r=c+3;e=i[c],s=n[c],t[c]=e<s?e:s,e=i[r],s=n[r],t[r]=e>s?e:s}}function St(i,n,t){for(let e=0;e<3;e++){const s=n[i+2*e],c=n[i+2*e+1],r=s-c,l=s+c;r<t[e]&&(t[e]=r),l>t[e+3]&&(t[e+3]=l)}}function At(i){const n=i[3]-i[0],t=i[4]-i[1],e=i[5]-i[2];return 2*(n*t+t*e+e*n)}const Y=32,jn=(i,n)=>i.candidate-n.candidate,K=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function Yn(i,n,t,e,s,c){let r=-1,l=0;if(c===Sn)r=mn(n),r!==-1&&(l=(n[r]+n[r+3])/2);else if(c===Nn)r=mn(i),r!==-1&&(l=Zn(t,e,s,r));else if(c===Vn){const o=At(i);let y=jt*s;const f=e*6,u=(e+s)*6;for(let a=0;a<3;a++){const p=n[a],h=(n[a+3]-p)/Y;if(s<Y/4){const w=[...K];w.length=s;let x=0;for(let g=f;g<u;g+=6,x++){const A=w[x];A.candidate=t[g+2*a],A.count=0;const{bounds:T,leftCacheBounds:B,rightCacheBounds:P}=A;for(let S=0;S<3;S++)P[S]=1/0,P[S+3]=-1/0,B[S]=1/0,B[S+3]=-1/0,T[S]=1/0,T[S+3]=-1/0;St(g,t,T)}w.sort(jn);let m=s;for(let g=0;g<m;g++){const A=w[g];for(;g+1<m&&w[g+1].candidate===A.candidate;)w.splice(g+1,1),m--}for(let g=f;g<u;g+=6){const A=t[g+2*a];for(let T=0;T<m;T++){const B=w[T];A>=B.candidate?St(g,t,B.rightCacheBounds):(St(g,t,B.leftCacheBounds),B.count++)}}for(let g=0;g<m;g++){const A=w[g],T=A.count,B=s-A.count,P=A.leftCacheBounds,S=A.rightCacheBounds;let M=0;T!==0&&(M=At(P)/o);let U=0;B!==0&&(U=At(S)/o);const _=An+jt*(M*T+U*B);_<y&&(r=a,y=_,l=A.candidate)}}else{for(let m=0;m<Y;m++){const g=K[m];g.count=0,g.candidate=p+h+m*h;const A=g.bounds;for(let T=0;T<3;T++)A[T]=1/0,A[T+3]=-1/0}for(let m=f;m<u;m+=6){let T=~~((t[m+2*a]-p)/h);T>=Y&&(T=Y-1);const B=K[T];B.count++,St(m,t,B.bounds)}const w=K[Y-1];hn(w.bounds,w.rightCacheBounds);for(let m=Y-2;m>=0;m--){const g=K[m],A=K[m+1];gn(g.bounds,A.rightCacheBounds,g.rightCacheBounds)}let x=0;for(let m=0;m<Y-1;m++){const g=K[m],A=g.count,T=g.bounds,P=K[m+1].rightCacheBounds;A!==0&&(x===0?hn(T,Ct):gn(T,Ct,Ct)),x+=A;let S=0,M=0;x!==0&&(S=At(Ct)/o);const U=s-x;U!==0&&(M=At(P)/o);const _=An+jt*(S*x+M*U);_<y&&(r=a,y=_,l=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:l}}function Zn(i,n,t,e){let s=0;for(let c=n,r=n+t;c<r;c++)s+=i[c*6+e*2];return s/t}class Kt{constructor(){this.boundingData=new Float32Array(6)}}function Kn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,y=c.axis*2;for(;;){for(;r<=l&&t[r*6+y]<o;)r++;for(;r<=l&&t[l*6+y]>=o;)l--;if(r<l){for(let f=0;f<3;f++){let u=n[r*3+f];n[r*3+f]=n[l*3+f],n[l*3+f]=u}for(let f=0;f<6;f++){let u=t[r*6+f];t[r*6+f]=t[l*6+f],t[l*6+f]=u}r++,l--}else return r}}function Jn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,y=c.axis*2;for(;;){for(;r<=l&&t[r*6+y]<o;)r++;for(;r<=l&&t[l*6+y]>=o;)l--;if(r<l){let f=i[r];i[r]=i[l],i[l]=f;for(let u=0;u<6;u++){let a=t[r*6+u];t[r*6+u]=t[l*6+u],t[l*6+u]=a}r++,l--}else return r}}function V(i,n){return n[i+15]===65535}function I(i,n){return n[i+6]}function $(i,n){return n[i+14]}function k(i){return i+8}function q(i,n){return n[i+6]}function Ln(i,n){return n[i+7]}function $i(i){return i}let En,Tt,kt,zn;const Wn=Math.pow(2,32);function nn(i){return"count"in i?1:1+nn(i.left)+nn(i.right)}function Qn(i,n,t){return En=new Float32Array(t),Tt=new Uint32Array(t),kt=new Uint16Array(t),zn=new Uint8Array(t),en(i,n)}function en(i,n){const t=i/4,e=i/2,s="count"in n,c=n.boundingData;for(let r=0;r<6;r++)En[t+r]=c[r];if(s)if(n.buffer){const r=n.buffer;zn.set(new Uint8Array(r),i);for(let l=i,o=i+r.byteLength;l<o;l+=bt){const y=l/2;V(y,kt)||(Tt[l/4+6]+=t)}return i+r.byteLength}else{const r=n.offset,l=n.count;return Tt[t+6]=r,kt[e+14]=l,kt[e+15]=Xt,i+bt}else{const r=n.left,l=n.right,o=n.splitAxis;let y;if(y=en(i+bt,r),y/4>Wn)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Tt[t+6]=y/4,y=en(y,l),Tt[t+7]=o,y}}function On(i,n){const t=(i.index?i.index.count:i.attributes.position.count)/3,e=t>2**16,s=e?4:2,c=n?new SharedArrayBuffer(t*s):new ArrayBuffer(t*s),r=e?new Uint32Array(c):new Uint16Array(c);for(let l=0,o=r.length;l<o;l++)r[l]=l;return r}function Gn(i,n,t,e,s){const{maxDepth:c,verbose:r,maxLeafTris:l,strategy:o,onProgress:y,indirect:f}=s,u=i._indirectBuffer,a=i.geometry,p=a.index?a.index.array:null,d=f?Jn:Kn,b=O(a),h=new Float32Array(6);let w=!1;const x=new Kt;return Zt(n,t,e,x.boundingData,h),g(x,t,e,h),x;function m(A){y&&y(A/b)}function g(A,T,B,P=null,S=0){if(!w&&S>=c&&(w=!0,r&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),B<=l||S>=c)return m(T+B),A.offset=T,A.count=B,A;const M=Yn(A.boundingData,P,n,T,B,o);if(M.axis===-1)return m(T+B),A.offset=T,A.count=B,A;const U=d(u,p,n,T,B,M);if(U===T||U===T+B)m(T+B),A.offset=T,A.count=B;else{A.splitAxis=M.axis;const _=new Kt,C=T,L=U-T;A.left=_,Zt(n,C,L,_.boundingData,h),g(_,C,L,h,S+1);const E=new Kt,D=U,Z=B-L;A.right=E,Zt(n,D,Z,E.boundingData,h),g(E,D,Z,h,S+1)}return A}}function ti(i,n){const t=i.geometry;n.indirect&&(i._indirectBuffer=On(t,n.useSharedArrayBuffer),Xn(t,n.range)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),i._indirectBuffer||qn(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Cn(t,n.range),c=Hn(t,null,s[0].offset,s[0].count),r=n.indirect?s:Un(t,n.range);i._roots=r.map(l=>{const o=Gn(i,c,l.offset,l.count,n),y=nn(o),f=new e(bt*y);return Qn(0,o,f),f})}class N{constructor(n,t,e){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new it,this.invMatrix=new it,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new Pt),this.alignedSatBounds=new Array(3).fill().map(()=>new Pt),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}N.prototype.update=(function(){return function(){const n=this.matrix,t=this.min,e=this.max,s=this.points;for(let y=0;y<=1;y++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const a=1*y|2*f|4*u,p=s[a];p.x=y?e.x:t.x,p.y=f?e.y:t.y,p.z=u?e.z:t.z,p.applyMatrix4(n)}const c=this.satBounds,r=this.satAxes,l=s[0];for(let y=0;y<3;y++){const f=r[y],u=c[y],a=1<<y,p=s[a];f.subVectors(l,p),u.setFromPoints(f,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();N.prototype.intersectsBox=(function(){const i=new Pt;return function(t){this.needsUpdate&&this.update();const e=t.min,s=t.max,c=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(i.min=e.x,i.max=s.x,l[0].isSeparated(i)||(i.min=e.y,i.max=s.y,l[1].isSeparated(i))||(i.min=e.z,i.max=s.z,l[2].isSeparated(i)))return!1;for(let o=0;o<3;o++){const y=r[o],f=c[o];if(i.setFromBox(y,t),f.isSeparated(i))return!1}return!0}})();N.prototype.intersectsTriangle=(function(){const i=new ut,n=new Array(3),t=new Pt,e=new Pt,s=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const l=this.satBounds,o=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let a=0;a<3;a++){const p=l[a],d=o[a];if(t.setFromPoints(d,n),p.isSeparated(t))return!1}const y=r.satBounds,f=r.satAxes,u=this.points;for(let a=0;a<3;a++){const p=y[a],d=f[a];if(t.setFromPoints(d,u),p.isSeparated(t))return!1}for(let a=0;a<3;a++){const p=o[a];for(let d=0;d<4;d++){const b=f[d];if(s.crossVectors(p,b),t.setFromPoints(s,n),e.setFromPoints(s,u),t.isSeparated(e))return!1}}return!0}})();N.prototype.closestPointToPoint=(function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}})();N.prototype.distanceToPoint=(function(){const i=new z;return function(t){return this.closestPointToPoint(t,i),t.distanceTo(i)}})();N.prototype.distanceToBox=(function(){const i=["x","y","z"],n=new Array(12).fill().map(()=>new pn),t=new Array(12).fill().map(()=>new pn),e=new z,s=new z;return function(r,l=0,o=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||y)&&(r.getCenter(s),this.closestPointToPoint(s,e),r.closestPointToPoint(e,s),o&&o.copy(e),y&&y.copy(s)),0;const f=l*l,u=r.min,a=r.max,p=this.points;let d=1/0;for(let h=0;h<8;h++){const w=p[h];s.copy(w).clamp(u,a);const x=w.distanceToSquared(s);if(x<d&&(d=x,o&&o.copy(w),y&&y.copy(s),x<f))return Math.sqrt(x)}let b=0;for(let h=0;h<3;h++)for(let w=0;w<=1;w++)for(let x=0;x<=1;x++){const m=(h+1)%3,g=(h+2)%3,A=w<<m|x<<g,T=1<<h|w<<m|x<<g,B=p[A],P=p[T];n[b].set(B,P);const M=i[h],U=i[m],_=i[g],C=t[b],L=C.start,E=C.end;L[M]=u[M],L[U]=w?u[U]:a[U],L[_]=x?u[_]:a[U],E[M]=a[M],E[U]=w?u[U]:a[U],E[_]=x?u[_]:a[U],b++}for(let h=0;h<=1;h++)for(let w=0;w<=1;w++)for(let x=0;x<=1;x++){s.x=h?a.x:u.x,s.y=w?a.y:u.y,s.z=x?a.z:u.z,this.closestPointToPoint(s,e);const m=s.distanceToSquared(e);if(m<d&&(d=m,o&&o.copy(e),y&&y.copy(s),m<f))return Math.sqrt(m)}for(let h=0;h<12;h++){const w=n[h];for(let x=0;x<12;x++){const m=t[x];vn(w,m,e,s);const g=e.distanceToSquared(s);if(g<d&&(d=g,o&&o.copy(e),y&&y.copy(s),g<f))return Math.sqrt(g)}}return Math.sqrt(d)}})();class un{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class ni extends un{constructor(){super(()=>new ut)}}const X=new ni;class ii{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const R=new ii;let W,ft;const et=[],Ut=new un(()=>new j);function ei(i,n,t,e,s,c){W=Ut.getPrimitive(),ft=Ut.getPrimitive(),et.push(W,ft),R.setBuffer(i._roots[n]);const r=sn(0,i.geometry,t,e,s,c);R.clearBuffer(),Ut.releasePrimitive(W),Ut.releasePrimitive(ft),et.pop(),et.pop();const l=et.length;return l>0&&(ft=et[l-1],W=et[l-2]),r}function sn(i,n,t,e,s=null,c=0,r=0){const{float32Array:l,uint16Array:o,uint32Array:y}=R;let f=i*2;if(V(f,o)){const a=I(i,y),p=$(f,o);return v(i,l,W),e(a,p,!1,r,c+i,W)}else{let M=function(_){const{uint16Array:C,uint32Array:L}=R;let E=_*2;for(;!V(E,C);)_=k(_),E=_*2;return I(_,L)},U=function(_){const{uint16Array:C,uint32Array:L}=R;let E=_*2;for(;!V(E,C);)_=q(_,L),E=_*2;return I(_,L)+$(E,C)};const a=k(i),p=q(i,y);let d=a,b=p,h,w,x,m;if(s&&(x=W,m=ft,v(d,l,x),v(b,l,m),h=s(x),w=s(m),w<h)){d=p,b=a;const _=h;h=w,w=_,x=m}x||(x=W,v(d,l,x));const g=V(d*2,o),A=t(x,g,h,r+1,c+d);let T;if(A===xn){const _=M(d),L=U(d)-_;T=e(_,L,!0,r+1,c+d,x)}else T=A&&sn(d,n,t,e,s,c,r+1);if(T)return!0;m=ft,v(b,l,m);const B=V(b*2,o),P=t(m,B,w,r+1,c+b);let S;if(P===xn){const _=M(b),L=U(b)-_;S=e(_,L,!0,r+1,c+b,m)}else S=P&&sn(b,n,t,e,s,c,r+1);return!!S}}const mt=new z,Jt=new z;function si(i,n,t={},e=0,s=1/0){const c=e*e,r=s*s;let l=1/0,o=null;if(i.shapecast({boundsTraverseOrder:f=>(mt.copy(n).clamp(f.min,f.max),mt.distanceToSquared(n)),intersectsBounds:(f,u,a)=>a<l&&a<r,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,mt);const a=n.distanceToSquared(mt);return a<l&&(Jt.copy(mt),l=a,o=u),a<c}}),l===1/0)return null;const y=Math.sqrt(l);return t.point?t.point.copy(Jt):t.point=Jt.clone(),t.distance=y,t.faceIndex=o,t}const Lt=parseInt(Mn)>=169,ri=parseInt(Mn)<=161,G=new z,tt=new z,nt=new z,Et=new Mt,zt=new Mt,Rt=new Mt,wn=new z,Bn=new z,dn=new z,ht=new z;function oi(i,n,t,e,s,c,r,l){let o;if(c===Dn?o=i.intersectTriangle(e,t,n,!0,s):o=i.intersectTriangle(n,t,e,c!==Fn,s),o===null)return null;const y=i.origin.distanceTo(s);return y<r||y>l?null:{distance:y,point:s.clone()}}function ci(i,n,t,e,s,c,r,l,o,y,f){G.fromBufferAttribute(n,c),tt.fromBufferAttribute(n,r),nt.fromBufferAttribute(n,l);const u=oi(i,G,tt,nt,ht,o,y,f);if(u){if(e){Et.fromBufferAttribute(e,c),zt.fromBufferAttribute(e,r),Rt.fromBufferAttribute(e,l),u.uv=new Mt;const p=xt.getInterpolation(ht,G,tt,nt,Et,zt,Rt,u.uv);Lt||(u.uv=p)}if(s){Et.fromBufferAttribute(s,c),zt.fromBufferAttribute(s,r),Rt.fromBufferAttribute(s,l),u.uv1=new Mt;const p=xt.getInterpolation(ht,G,tt,nt,Et,zt,Rt,u.uv1);Lt||(u.uv1=p),ri&&(u.uv2=u.uv1)}if(t){wn.fromBufferAttribute(t,c),Bn.fromBufferAttribute(t,r),dn.fromBufferAttribute(t,l),u.normal=new z;const p=xt.getInterpolation(ht,G,tt,nt,wn,Bn,dn,u.normal);u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1),Lt||(u.normal=p)}const a={a:c,b:r,c:l,normal:new z,materialIndex:0};if(xt.getNormal(G,tt,nt,a.normal),u.face=a,u.faceIndex=c,Lt){const p=new z;xt.getBarycoord(ht,G,tt,nt,p),u.barycoord=p}}return u}function Ht(i,n,t,e,s,c,r){const l=e*3;let o=l+0,y=l+1,f=l+2;const u=i.index;i.index&&(o=u.getX(o),y=u.getX(y),f=u.getX(f));const{position:a,normal:p,uv:d,uv1:b}=i.attributes,h=ci(t,a,p,d,b,o,y,f,n,c,r);return h?(h.faceIndex=e,s&&s.push(h),h):null}function F(i,n,t,e){const s=i.a,c=i.b,r=i.c;let l=n,o=n+1,y=n+2;t&&(l=t.getX(l),o=t.getX(o),y=t.getX(y)),s.x=e.getX(l),s.y=e.getY(l),s.z=e.getZ(l),c.x=e.getX(o),c.y=e.getY(o),c.z=e.getZ(o),r.x=e.getX(y),r.y=e.getY(y),r.z=e.getZ(y)}function li(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:y}=i;for(let f=e,u=e+s;f<u;f++)Ht(o,n,t,f,c,r,l)}function ai(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let y=1/0,f=null;for(let u=e,a=e+s;u<a;u++){let p;p=Ht(l,n,t,u,null,c,r),p&&p.distance<y&&(f=p,y=p.distance)}return f}function fi(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,y=l.attributes.position;for(let f=i,u=n+i;f<u;f++){let a;if(a=f,F(r,a*3,o,y),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function ui(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,y=0;const f=i._roots;for(let a=0,p=f.length;a<p;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),u(0,y),y+=c.byteLength;function u(a,p,d=!1){const b=a*2;if(l[b+15]===Xt){const w=r[a+6],x=l[b+14];let m=1/0,g=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=3*w,M=3*(w+x);S<M;S++){let U=e[S];const _=s.getX(U),C=s.getY(U),L=s.getZ(U);_<m&&(m=_),_>T&&(T=_),C<g&&(g=C),C>B&&(B=C),L<A&&(A=L),L>P&&(P=L)}return o[a+0]!==m||o[a+1]!==g||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=g,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const w=a+8,x=r[a+6],m=w+p,g=x+p;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(g),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=u(w,p,A));let U=!1;S&&(U=u(x,p,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=w+C,E=x+C,D=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=D<pt?D:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function Q(i,n,t,e,s){let c,r,l,o,y,f;const u=1/t.direction.x,a=1/t.direction.y,p=1/t.direction.z,d=t.origin.x,b=t.origin.y,h=t.origin.z;let w=n[i],x=n[i+3],m=n[i+1],g=n[i+3+1],A=n[i+2],T=n[i+3+2];return u>=0?(c=(w-d)*u,r=(x-d)*u):(c=(x-d)*u,r=(w-d)*u),a>=0?(l=(m-b)*a,o=(g-b)*a):(l=(g-b)*a,o=(m-b)*a),c>o||l>r||((l>c||isNaN(c))&&(c=l),(o<r||isNaN(r))&&(r=o),p>=0?(y=(A-h)*p,f=(T-h)*p):(y=(T-h)*p,f=(A-h)*p),c>f||y>r)?!1:((y>c||c!==c)&&(c=y),(f<r||r!==r)&&(r=f),c<=s&&r>=e)}function pi(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:y}=i;for(let f=e,u=e+s;f<u;f++){let a=y?y[f]:f;Ht(o,n,t,a,c,r,l)}}function yi(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let y=1/0,f=null;for(let u=e,a=e+s;u<a;u++){let p;p=Ht(l,n,t,o?o[u]:u,null,c,r),p&&p.distance<y&&(f=p,y=p.distance)}return f}function xi(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,y=l.attributes.position;for(let f=i,u=n+i;f<u;f++){let a;if(a=t.resolveTriangleIndex(f),F(r,a*3,o,y),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function Ai(i,n,t,e,s,c,r){R.setBuffer(i._roots[n]),rn(0,i,t,e,s,c,r),R.clearBuffer()}function rn(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:y}=R,f=i*2;if(V(f,o)){const a=I(i,y),p=$(f,o);li(n,t,e,a,p,s,c,r)}else{const a=k(i);Q(a,l,e,c,r)&&rn(a,n,t,e,s,c,r);const p=q(i,y);Q(p,l,e,c,r)&&rn(p,n,t,e,s,c,r)}}const mi=["x","y","z"];function hi(i,n,t,e,s,c){R.setBuffer(i._roots[n]);const r=on(0,i,t,e,s,c);return R.clearBuffer(),r}function on(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=R;let y=i*2;if(V(y,l)){const u=I(i,o),a=$(y,l);return ai(n,t,e,u,a,s,c)}else{const u=Ln(i,o),a=mi[u],d=e.direction[a]>=0;let b,h;d?(b=k(i),h=q(i,o)):(b=q(i,o),h=k(i));const x=Q(b,r,e,s,c)?on(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[h+u]:A>=r[h+u+3])return x}const g=Q(h,r,e,s,c)?on(h,n,t,e,s,c):null;return x&&g?x.distance<=g.distance?x:g:x||g||null}}const vt=new j,st=new ut,rt=new ut,gt=new it,Tn=new N,Dt=new N;function gi(i,n,t,e){R.setBuffer(i._roots[n]);const s=cn(0,i,t,e);return R.clearBuffer(),s}function cn(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=R;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),Tn.set(t.boundingBox.min,t.boundingBox.max,e),s=Tn),V(o,r)){const f=n.geometry,u=f.index,a=f.attributes.position,p=t.index,d=t.attributes.position,b=I(i,l),h=$(o,r);if(gt.copy(e).invert(),t.boundsTree)return v(i,c,Dt),Dt.matrix.copy(gt),Dt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Dt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b*3,g=(h+b)*3;m<g;m+=3)if(F(rt,m,u,a),rt.needsUpdate=!0,x.intersectsTriangle(rt))return!0;return!1}});{const w=O(t);for(let x=b*3,m=(h+b)*3;x<m;x+=3){F(st,x,u,a),st.a.applyMatrix4(gt),st.b.applyMatrix4(gt),st.c.applyMatrix4(gt),st.needsUpdate=!0;for(let g=0,A=w*3;g<A;g+=3)if(F(rt,g,p,d),rt.needsUpdate=!0,st.intersectsTriangle(rt))return!0}}}else{const f=i+8,u=l[i+6];return v(f,c,vt),!!(s.intersectsBox(vt)&&cn(f,n,t,e,s)||(v(u,c,vt),s.intersectsBox(vt)&&cn(u,n,t,e,s)))}}const Ft=new it,Wt=new N,wt=new N,wi=new z,Bi=new z,di=new z,Ti=new z;function bi(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Wt.set(n.boundingBox.min,n.boundingBox.max,t),Wt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,y=l.index,f=n.attributes.position,u=n.index,a=X.getPrimitive(),p=X.getPrimitive();let d=wi,b=Bi,h=null,w=null;s&&(h=di,w=Ti);let x=1/0,m=null,g=null;return Ft.copy(t).invert(),wt.matrix.copy(Ft),i.shapecast({boundsTraverseOrder:A=>Wt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(wt.min.copy(A.min),wt.max.copy(A.max),wt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:P=>wt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){F(p,3*M,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let _=A,C=A+T;_<C;_++){F(a,3*_,y,o),a.needsUpdate=!0;const L=a.distanceToTriangle(p,d,h);if(L<x&&(b.copy(d),w&&w.copy(h),x=L,m=_,g=M),L<c)return!0}}}});{const B=O(n);for(let P=0,S=B;P<S;P++){F(p,3*P,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){F(a,3*M,y,o),a.needsUpdate=!0;const _=a.distanceToTriangle(p,d,h);if(_<x&&(b.copy(d),w&&w.copy(h),x=_,m=M,g=P),_<c)return!0}}}}}),X.releasePrimitive(a),X.releasePrimitive(p),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(Ft),b.applyMatrix4(Ft),s.distance=b.sub(s.point).length(),s.faceIndex=g),e)}function _i(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,y=0;const f=i._roots;for(let a=0,p=f.length;a<p;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),u(0,y),y+=c.byteLength;function u(a,p,d=!1){const b=a*2;if(l[b+15]===Xt){const w=r[a+6],x=l[b+14];let m=1/0,g=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=w,M=w+x;S<M;S++){const U=3*i.resolveTriangleIndex(S);for(let _=0;_<3;_++){let C=U+_;C=e?e[C]:C;const L=s.getX(C),E=s.getY(C),D=s.getZ(C);L<m&&(m=L),L>T&&(T=L),E<g&&(g=E),E>B&&(B=E),D<A&&(A=D),D>P&&(P=D)}}return o[a+0]!==m||o[a+1]!==g||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=g,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const w=a+8,x=r[a+6],m=w+p,g=x+p;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(g),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=u(w,p,A));let U=!1;S&&(U=u(x,p,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=w+C,E=x+C,D=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=D<pt?D:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function Pi(i,n,t,e,s,c,r){R.setBuffer(i._roots[n]),ln(0,i,t,e,s,c,r),R.clearBuffer()}function ln(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:y}=R,f=i*2;if(V(f,o)){const a=I(i,y),p=$(f,o);pi(n,t,e,a,p,s,c,r)}else{const a=k(i);Q(a,l,e,c,r)&&ln(a,n,t,e,s,c,r);const p=q(i,y);Q(p,l,e,c,r)&&ln(p,n,t,e,s,c,r)}}const Mi=["x","y","z"];function Si(i,n,t,e,s,c){R.setBuffer(i._roots[n]);const r=an(0,i,t,e,s,c);return R.clearBuffer(),r}function an(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=R;let y=i*2;if(V(y,l)){const u=I(i,o),a=$(y,l);return yi(n,t,e,u,a,s,c)}else{const u=Ln(i,o),a=Mi[u],d=e.direction[a]>=0;let b,h;d?(b=k(i),h=q(i,o)):(b=q(i,o),h=k(i));const x=Q(b,r,e,s,c)?an(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[h+u]:A>=r[h+u+3])return x}const g=Q(h,r,e,s,c)?an(h,n,t,e,s,c):null;return x&&g?x.distance<=g.distance?x:g:x||g||null}}const Nt=new j,ot=new ut,ct=new ut,Bt=new it,bn=new N,Vt=new N;function Ci(i,n,t,e){R.setBuffer(i._roots[n]);const s=fn(0,i,t,e);return R.clearBuffer(),s}function fn(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=R;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),bn.set(t.boundingBox.min,t.boundingBox.max,e),s=bn),V(o,r)){const f=n.geometry,u=f.index,a=f.attributes.position,p=t.index,d=t.attributes.position,b=I(i,l),h=$(o,r);if(Bt.copy(e).invert(),t.boundsTree)return v(i,c,Vt),Vt.matrix.copy(Bt),Vt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Vt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b,g=h+b;m<g;m++)if(F(ct,3*n.resolveTriangleIndex(m),u,a),ct.needsUpdate=!0,x.intersectsTriangle(ct))return!0;return!1}});{const w=O(t);for(let x=b,m=h+b;x<m;x++){const g=n.resolveTriangleIndex(x);F(ot,3*g,u,a),ot.a.applyMatrix4(Bt),ot.b.applyMatrix4(Bt),ot.c.applyMatrix4(Bt),ot.needsUpdate=!0;for(let A=0,T=w*3;A<T;A+=3)if(F(ct,A,p,d),ct.needsUpdate=!0,ot.intersectsTriangle(ct))return!0}}}else{const f=i+8,u=l[i+6];return v(f,c,Nt),!!(s.intersectsBox(Nt)&&fn(f,n,t,e,s)||(v(u,c,Nt),s.intersectsBox(Nt)&&fn(u,n,t,e,s)))}}const It=new it,Qt=new N,dt=new N,Ui=new z,Li=new z,Ei=new z,zi=new z;function Ri(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Qt.set(n.boundingBox.min,n.boundingBox.max,t),Qt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,y=l.index,f=n.attributes.position,u=n.index,a=X.getPrimitive(),p=X.getPrimitive();let d=Ui,b=Li,h=null,w=null;s&&(h=Ei,w=zi);let x=1/0,m=null,g=null;return It.copy(t).invert(),dt.matrix.copy(It),i.shapecast({boundsTraverseOrder:A=>Qt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(dt.min.copy(A.min),dt.max.copy(A.max),dt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree){const B=n.boundsTree;return B.shapecast({boundsTraverseOrder:P=>dt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){const _=B.resolveTriangleIndex(M);F(p,3*_,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let C=A,L=A+T;C<L;C++){const E=i.resolveTriangleIndex(C);F(a,3*E,y,o),a.needsUpdate=!0;const D=a.distanceToTriangle(p,d,h);if(D<x&&(b.copy(d),w&&w.copy(h),x=D,m=C,g=M),D<c)return!0}}}})}else{const B=O(n);for(let P=0,S=B;P<S;P++){F(p,3*P,u,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){const _=i.resolveTriangleIndex(M);F(a,3*_,y,o),a.needsUpdate=!0;const C=a.distanceToTriangle(p,d,h);if(C<x&&(b.copy(d),w&&w.copy(h),x=C,m=M,g=P),C<c)return!0}}}}}),X.releasePrimitive(a),X.releasePrimitive(p),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(It),b.applyMatrix4(It),s.distance=b.sub(s.point).length(),s.faceIndex=g),e)}function vi(){return typeof SharedArrayBuffer<"u"}function ki(i,n){if(i===null)return i;if(i.buffer){const t=i.buffer;if(t.constructor===n)return i;const e=i.constructor,s=new e(new n(t.byteLength));return s.set(i),s}else{if(i.constructor===n)return i;const t=new n(i.byteLength);return new Uint8Array(t).set(new Uint8Array(i)),t}}const _t=new R.constructor,qt=new R.constructor,J=new un(()=>new j),lt=new j,at=new j,Ot=new j,Gt=new j;let tn=!1;function Di(i,n,t,e){if(tn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");tn=!0;const s=i._roots,c=n._roots;let r,l=0,o=0;const y=new it().copy(t).invert();for(let f=0,u=s.length;f<u;f++){_t.setBuffer(s[f]),o=0;const a=J.getPrimitive();v(0,_t.float32Array,a),a.applyMatrix4(y);for(let p=0,d=c.length;p<d&&(qt.setBuffer(c[p]),r=H(0,0,t,y,e,l,o,0,0,a),qt.clearBuffer(),o+=c[p].length,!r);p++);if(J.releasePrimitive(a),_t.clearBuffer(),l+=s[f].length,r)break}return tn=!1,r}function H(i,n,t,e,s,c=0,r=0,l=0,o=0,y=null,f=!1){let u,a;f?(u=qt,a=_t):(u=_t,a=qt);const p=u.float32Array,d=u.uint32Array,b=u.uint16Array,h=a.float32Array,w=a.uint32Array,x=a.uint16Array,m=i*2,g=n*2,A=V(m,b),T=V(g,x);let B=!1;if(T&&A)f?B=s(I(n,w),$(n*2,x),I(i,d),$(i*2,b),o,r+n,l,c+i):B=s(I(i,d),$(i*2,b),I(n,w),$(n*2,x),l,c+i,o,r+n);else if(T){const P=J.getPrimitive();v(n,h,P),P.applyMatrix4(t);const S=k(i),M=q(i,d);v(S,p,lt),v(M,p,at);const U=P.intersectsBox(lt),_=P.intersectsBox(at);B=U&&H(n,S,e,t,s,r,c,o,l+1,P,!f)||_&&H(n,M,e,t,s,r,c,o,l+1,P,!f),J.releasePrimitive(P)}else{const P=k(n),S=q(n,w);v(P,h,Ot),v(S,h,Gt);const M=y.intersectsBox(Ot),U=y.intersectsBox(Gt);if(M&&U)B=H(i,P,t,e,s,c,r,l,o+1,y,f)||H(i,S,t,e,s,c,r,l,o+1,y,f);else if(M)if(A)B=H(i,P,t,e,s,c,r,l,o+1,y,f);else{const _=J.getPrimitive();_.copy(Ot).applyMatrix4(t);const C=k(i),L=q(i,d);v(C,p,lt),v(L,p,at);const E=_.intersectsBox(lt),D=_.intersectsBox(at);B=E&&H(P,C,e,t,s,r,c,o,l+1,_,!f)||D&&H(P,L,e,t,s,r,c,o,l+1,_,!f),J.releasePrimitive(_)}else if(U)if(A)B=H(i,S,t,e,s,c,r,l,o+1,y,f);else{const _=J.getPrimitive();_.copy(Gt).applyMatrix4(t);const C=k(i),L=q(i,d);v(C,p,lt),v(L,p,at);const E=_.intersectsBox(lt),D=_.intersectsBox(at);B=E&&H(S,C,e,t,s,r,c,o,l+1,_,!f)||D&&H(S,L,e,t,s,r,c,o,l+1,_,!f),J.releasePrimitive(_)}}return B}const $t=new N,_n=new j,Fi={strategy:Sn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Rn{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,s=n._roots,c=n._indirectBuffer,r=e.getIndex();let l;return t.cloneBuffers?l={roots:s.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:c?c.slice():null}:l={roots:s,index:r?r.array:null,indirectBuffer:c},l}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:s,roots:c,indirectBuffer:r}=n,l=new Rn(t,{...e,[Yt]:!0});if(l._roots=c,l._indirectBuffer=r||null,e.setIndex){const o=t.getIndex();if(o===null){const y=new Pn(n.index,1,!1);t.setIndex(y)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return l}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Fi,[Yt]:!1},t),t.useSharedArrayBuffer&&!vi())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Yt]||(ti(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new j))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(n=null){return(this.indirect?_i:ui)(this,n)}traverse(n,t=0){const e=this._roots[t],s=new Uint32Array(e),c=new Uint16Array(e);r(0);function r(l,o=0){const y=l*2,f=c[y+15]===Xt;if(f){const u=s[l+6],a=c[y+14];n(o,f,new Float32Array(e,l*4,6),u,a)}else{const u=l+bt/4,a=s[l+6],p=s[l+7];n(o,f,new Float32Array(e,l*4,6),p)||(r(u,o+1),r(a,o+1))}}}raycast(n,t=yn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=[],o=t.isMaterial,y=Array.isArray(t),f=r.groups,u=o?t.side:t,a=this.indirect?Pi:Ai;for(let p=0,d=c.length;p<d;p++){const b=y?t[f[p].materialIndex].side:u,h=l.length;if(a(this,p,b,n,l,e,s),y){const w=f[p].materialIndex;for(let x=h,m=l.length;x<m;x++)l[x].face.materialIndex=w}}return l}raycastFirst(n,t=yn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=t.isMaterial,o=Array.isArray(t);let y=null;const f=r.groups,u=l?t.side:t,a=this.indirect?Si:hi;for(let p=0,d=c.length;p<d;p++){const b=o?t[f[p].materialIndex].side:u,h=a(this,p,b,n,e,s);h!=null&&(y==null||h.distance<y.distance)&&(y=h,o&&(h.face.materialIndex=f[p].materialIndex))}return y}intersectsGeometry(n,t){let e=!1;const s=this._roots,c=this.indirect?Ci:gi;for(let r=0,l=s.length;r<l&&(e=c(this,r,n,t),!e);r++);return e}shapecast(n){const t=X.getPrimitive(),e=this.indirect?xi:fi;let{boundsTraverseOrder:s,intersectsBounds:c,intersectsRange:r,intersectsTriangle:l}=n;if(r&&l){const u=r;r=(a,p,d,b,h)=>u(a,p,d,b,h)?!0:e(a,p,this,l,d,b,t)}else r||(l?r=(u,a,p,d)=>e(u,a,this,l,p,d,t):r=(u,a,p)=>p);let o=!1,y=0;const f=this._roots;for(let u=0,a=f.length;u<a;u++){const p=f[u];if(o=ei(this,u,c,r,s,y),o)break;y+=p.byteLength}return X.releasePrimitive(t),o}bvhcast(n,t,e){let{intersectsRanges:s,intersectsTriangles:c}=e;const r=X.getPrimitive(),l=this.geometry.index,o=this.geometry.attributes.position,y=this.indirect?d=>{const b=this.resolveTriangleIndex(d);F(r,b*3,l,o)}:d=>{F(r,d*3,l,o)},f=X.getPrimitive(),u=n.geometry.index,a=n.geometry.attributes.position,p=n.indirect?d=>{const b=n.resolveTriangleIndex(d);F(f,b*3,u,a)}:d=>{F(f,d*3,u,a)};if(c){const d=(b,h,w,x,m,g,A,T)=>{for(let B=w,P=w+x;B<P;B++){p(B),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let S=b,M=b+h;S<M;S++)if(y(S),r.needsUpdate=!0,c(r,f,S,B,m,g,A,T))return!0}return!1};if(s){const b=s;s=function(h,w,x,m,g,A,T,B){return b(h,w,x,m,g,A,T,B)?!0:d(h,w,x,m,g,A,T,B)}}else s=d}return Di(this,n,t,s)}intersectsBox(n,t){return $t.set(n.min,n.max,t),$t.needsUpdate=!0,this.shapecast({intersectsBounds:e=>$t.intersectsBox(e),intersectsTriangle:e=>$t.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},s={},c=0,r=1/0){return(this.indirect?Ri:bi)(this,n,t,e,s,c,r)}closestPointToPoint(n,t={},e=0,s=1/0){return si(this,n,t,e,s)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{v(0,new Float32Array(e),_n),n.union(_n)}),n}}export{Nn as A,bt as B,Sn as C,Ii as I,Rn as M,Vi as N,I as O,q as R,Vn as S,jt as T,xn as a,$n as b,ki as c,V as d,qn as e,$ as f,kn as g,Ln as h,vi as i,$i as j,An as k,v as l};
