import{i as W,B as I,aS as U,V as S,aT as B,n as E}from"./ExtendedTriangle-DttJMGjs.js";const g=new S,A=new S,w=new S,V=new B,T=new S,C=new S,X=new B,N=new B,z=new E,Y=new E;function v(i,t){if(!i&&!t)return;const e=i.count===t.count,n=i.normalized===t.normalized,o=i.array.constructor===t.array.constructor,r=i.itemSize===t.itemSize;if(!e||!n||!o||!r)throw new Error}function k(i,t=null){const e=i.array.constructor,n=i.normalized,o=i.itemSize,r=t===null?i.count:t;return new I(new e(o*r),o,n)}function Z(i,t,e=0){if(i.isInterleavedBufferAttribute){const n=i.itemSize;for(let o=0,r=i.count;o<r;o++){const l=o+e;t.setX(l,i.getX(o)),n>=2&&t.setY(l,i.getY(o)),n>=3&&t.setZ(l,i.getZ(o)),n>=4&&t.setW(l,i.getW(o))}}else{const n=t.array,o=n.constructor,r=n.BYTES_PER_ELEMENT*i.itemSize*e;new o(n.buffer,r,i.array.length).set(i.array)}}function H(i,t,e){const n=i.elements,o=t.elements;for(let r=0,l=o.length;r<l;r++)n[r]+=o[r]*e}function j(i,t,e){const n=i.skeleton,o=i.geometry,r=n.bones,l=n.boneInverses;X.fromBufferAttribute(o.attributes.skinIndex,t),N.fromBufferAttribute(o.attributes.skinWeight,t),z.elements.fill(0);for(let s=0;s<4;s++){const a=N.getComponent(s);if(a!==0){const d=X.getComponent(s);Y.multiplyMatrices(r[d].matrixWorld,l[d]),H(z,Y,a)}}return z.multiply(i.bindMatrix).premultiply(i.bindMatrixInverse),e.transformDirection(z),e}function _(i,t,e,n,o){T.set(0,0,0);for(let r=0,l=i.length;r<l;r++){const s=t[r],a=i[r];s!==0&&(C.fromBufferAttribute(a,n),e?T.addScaledVector(C,s):T.addScaledVector(C.sub(o),s))}o.add(T)}function R(i,t={useGroups:!1,updateIndex:!1,skipAttributes:[]},e=new W){const n=i[0].index!==null,{useGroups:o=!1,updateIndex:r=!1,skipAttributes:l=[]}=t,s=new Set(Object.keys(i[0].attributes)),a={};let d=0;e.clearGroups();for(let c=0;c<i.length;++c){const u=i[c];let b=0;if(n!==(u.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const f in u.attributes){if(!s.has(f))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+f+'" attribute exists among all geometries, or in none of them.');a[f]===void 0&&(a[f]=[]),a[f].push(u.attributes[f]),b++}if(b!==s.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(o){let f;if(n)f=u.index.count;else if(u.attributes.position!==void 0)f=u.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");e.addGroup(d,f,c),d+=f}}if(n){let c=!1;if(!e.index){let u=0;for(let b=0;b<i.length;++b)u+=i[b].index.count;e.setIndex(new I(new Uint32Array(u),1,!1)),c=!0}if(r||c){const u=e.index;let b=0,f=0;for(let p=0;p<i.length;++p){const x=i[p],y=x.index;if(l[p]!==!0)for(let M=0;M<y.count;++M)u.setX(b,y.getX(M)+f),b++;f+=x.attributes.position.count}}}for(const c in a){const u=a[c];if(!(c in e.attributes)){let p=0;for(const x in u)p+=u[x].count;e.setAttribute(c,k(a[c][0],p))}const b=e.attributes[c];let f=0;for(let p=0,x=u.length;p<x;p++){const y=u[p];l[p]!==!0&&Z(y,b,f),f+=y.count}}return e}function q(i,t){if(i===null||t===null)return i===t;if(i.length!==t.length)return!1;for(let e=0,n=i.length;e<n;e++)if(i[e]!==t[e])return!1;return!0}function D(i){const{index:t,attributes:e}=i;if(t)for(let n=0,o=t.count;n<o;n+=3){const r=t.getX(n),l=t.getX(n+2);t.setX(n,l),t.setX(n+2,r)}else for(const n in e){const o=e[n],r=o.itemSize;for(let l=0,s=o.count;l<s;l+=3)for(let a=0;a<r;a++){const d=o.getComponent(l,a),c=o.getComponent(l+2,a);o.setComponent(l,a,c),o.setComponent(l+2,a,d)}}return i}class L{constructor(t){this.matrixWorld=new E,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,o=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=o,n){n.boneTexture||n.computeBoneTexture(),n.update();const r=n.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==r.length?this.boneMatrices=r.slice():this.boneMatrices.set(r)}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&q(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class P{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach(n=>{n.traverseVisible(o=>{o.isMesh&&e.push(o)})}),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map(()=>new W),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach(e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)}),t}generate(t=new W){let e=[];const{meshes:n,useGroups:o,_intermediateGeometry:r,_diffMap:l}=this;for(let s=0,a=n.length;s<a;s++){const d=n[s],c=r[s],u=l.get(d);!u||u.didChange(d)?(this._convertToStaticGeometry(d,c),e.push(!1),u?u.update():l.set(d,new L(d))):e.push(!0)}if(r.length===0){t.setIndex(null);const s=t.attributes;for(const a in s)t.deleteAttribute(a);for(const a in this.attributes)t.setAttribute(this.attributes[a],new I(new Float32Array(0),4,!1))}else R(r,{useGroups:o,skipAttributes:e},t);for(const s in t.attributes)t.attributes[s].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new W){const n=t.geometry,o=this.applyWorldTransforms,r=this.attributes.includes("normal"),l=this.attributes.includes("tangent"),s=n.attributes,a=e.attributes;!e.index&&n.index&&(e.index=n.index.clone()),a.position||e.setAttribute("position",k(s.position)),r&&!a.normal&&s.normal&&e.setAttribute("normal",k(s.normal)),l&&!a.tangent&&s.tangent&&e.setAttribute("tangent",k(s.tangent)),v(n.index,e.index),v(s.position,a.position),r&&v(s.normal,a.normal),l&&v(s.tangent,a.tangent);const d=s.position,c=r?s.normal:null,u=l?s.tangent:null,b=n.morphAttributes.position,f=n.morphAttributes.normal,p=n.morphAttributes.tangent,x=n.morphTargetsRelative,y=t.morphTargetInfluences,M=new U;M.getNormalMatrix(t.matrixWorld),n.index&&e.index.array.set(n.index.array);for(let m=0,h=s.position.count;m<h;m++)g.fromBufferAttribute(d,m),c&&A.fromBufferAttribute(c,m),u&&(V.fromBufferAttribute(u,m),w.fromBufferAttribute(u,m)),y&&(b&&_(b,y,x,m,g),f&&_(f,y,x,m,A),p&&_(p,y,x,m,w)),t.isSkinnedMesh&&(t.applyBoneTransform(m,g),c&&j(t,m,A),u&&j(t,m,w)),o&&g.applyMatrix4(t.matrixWorld),a.position.setXYZ(m,g.x,g.y,g.z),c&&(o&&A.applyNormalMatrix(M),a.normal.setXYZ(m,A.x,A.y,A.z)),u&&(o&&w.transformDirection(t.matrixWorld),a.tangent.setXYZW(m,w.x,w.y,w.z,V.w));for(const m in this.attributes){const h=this.attributes[m];h==="position"||h==="tangent"||h==="normal"||!(h in s)||(a[h]||e.setAttribute(h,k(s[h])),v(s[h],a[h]),Z(s[h],a[h]))}return t.matrixWorld.determinant()<0&&D(e),e}}export{P as S};
